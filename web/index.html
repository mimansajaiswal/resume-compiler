<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Resume Compiler</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.css">
  <style>
    :root {
      --oatmeal: #d5cec0;
      --earth: #b8ad9a;
      --charcoal: #2c2c2c;
      --linen: #f4f1ec;
      --linen-dark: #e8e4dc;
      --purple: #7d6b8a;
      --pink: #c4909a;
      --mono: "SF Mono", "Fira Code", "Cascadia Code", "JetBrains Mono", "Consolas", "Courier New", monospace;
      --editor-pane-width: 45%;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .hidden {
      display: none !important;
    }

    .visually-hidden {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    body {
      font-family: var(--mono);
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: var(--oatmeal);
      color: var(--charcoal);
    }

    header {
      background: var(--charcoal);
      color: var(--linen);
      padding: 0.55rem 1.2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      z-index: 10;
    }

    header h1 {
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    header .subtitle {
      font-size: 0.65rem;
      letter-spacing: 0.08em;
      color: var(--earth);
      text-transform: uppercase;
      margin-top: 0.1rem;
    }

    .header-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
      min-width: 0;
    }

    .paper-size-wrap {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      color: var(--earth);
      font-size: 0.62rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-weight: 700;
    }

    .share-menu {
      position: relative;
    }

    #btn-share {
      background: transparent;
      color: var(--earth);
    }

    #btn-share:hover {
      background: rgba(255, 255, 255, 0.06);
      color: var(--linen);
    }

    .share-menu-panel {
      position: absolute;
      top: calc(100% + 0.28rem);
      right: 0;
      min-width: 13.4rem;
      background: #353535;
      border: 1px solid #696252;
      box-shadow: 0 10px 22px rgba(26, 23, 18, 0.28);
      z-index: 70;
      display: none;
      flex-direction: column;
      gap: 0.26rem;
      padding: 0.3rem;
    }

    .share-menu.open .share-menu-panel {
      display: flex;
    }

    .share-menu-panel button {
      border: 1px solid #6e6558;
      background: transparent;
      color: var(--linen);
      font-family: var(--mono);
      font-size: 0.61rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      text-align: left;
      padding: 0.36rem 0.44rem;
      cursor: pointer;
      width: 100%;
    }

    .share-menu-panel button:hover {
      background: rgba(255, 255, 255, 0.09);
      border-color: #8b806f;
    }

    .share-menu-panel button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .share-menu-panel button.hidden {
      display: none;
    }

    .upload-menu {
      position: relative;
    }

    .upload-menu-panel {
      position: absolute;
      top: calc(100% + 0.28rem);
      left: 0;
      min-width: 16.2rem;
      background: #f5eee3;
      border: 1px solid #b8ad99;
      box-shadow: 0 10px 22px rgba(26, 23, 18, 0.2);
      z-index: 70;
      display: none;
      flex-direction: column;
      gap: 0.38rem;
      padding: 0.42rem;
    }

    .upload-menu.open .upload-menu-panel {
      display: flex;
    }

    .upload-menu-panel button {
      border: 1px solid #8e826f;
      background: #332f2a;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.58rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0.33rem 0.5rem;
      cursor: pointer;
      min-height: 1.62rem;
      text-align: left;
    }

    .upload-menu-panel button:hover {
      background: #45403a;
    }

    .upload-url-block {
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 0.24rem;
    }

    .upload-url-block label {
      font-size: 0.57rem;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #514a3f;
    }

    .upload-url-block input {
      border: 1px solid var(--earth);
      background: #fffaf2;
      color: var(--charcoal);
      font-family: var(--mono);
      font-size: 0.6rem;
      padding: 0.34rem 0.42rem;
      min-width: 0;
      height: 1.8rem;
    }

    .upload-url-block .helper {
      font-size: 0.54rem;
      color: #6a6052;
      letter-spacing: 0.02em;
      line-height: 1.35;
    }

    .native-select-hidden {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      margin: -1px !important;
      padding: 0 !important;
      border: 0 !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    .custom-select {
      position: relative;
      min-width: 7.25rem;
    }

    .custom-select-trigger {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.3rem 0.45rem;
      border: 1px solid var(--earth);
      background: var(--linen);
      color: var(--charcoal);
      font-family: var(--mono);
      font-size: 0.67rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease;
    }

    .custom-select-trigger:hover {
      border-color: #9b8f7c;
      background: #f9f6f0;
    }

    .custom-select.open .custom-select-trigger {
      border-color: var(--pink);
      background: #fff9fa;
    }

    .custom-select-value {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: left;
    }

    .custom-select-chevron {
      flex: 0 0 auto;
      width: 0.45rem;
      height: 0.45rem;
      border-right: 1px solid currentColor;
      border-bottom: 1px solid currentColor;
      transform: rotate(45deg) translateY(-1px);
      transition: transform 0.14s ease;
      opacity: 0.8;
      margin-right: 0.1rem;
    }

    .custom-select.open .custom-select-chevron {
      transform: rotate(-135deg) translateY(-1px);
    }

    .custom-select-menu {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 0.28rem);
      background: #fffdf8;
      border: 1px solid var(--earth);
      box-shadow: 0 10px 22px rgba(43, 39, 30, 0.12);
      max-height: 14rem;
      overflow-y: auto;
      z-index: 40;
      display: none;
      padding: 0.25rem;
    }

    .custom-select.open .custom-select-menu {
      display: block;
    }

    .custom-select-option {
      width: 100%;
      border: 0;
      background: transparent;
      color: #3f3a31;
      text-align: left;
      padding: 0.36rem 0.44rem;
      font-family: var(--mono);
      font-size: 0.67rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      cursor: pointer;
    }

    .custom-select-option:hover {
      background: #f1ebe2;
    }

    .custom-select-option.selected {
      background: #e8dfd2;
      color: #2f2a22;
      font-weight: 700;
    }

    .paper-size-wrap .custom-select {
      min-width: 5.6rem;
    }

    .paper-size-wrap .custom-select-trigger {
      background: transparent;
      color: var(--linen);
      border-color: var(--earth);
      font-size: 0.65rem;
      padding: 0.22rem 0.36rem;
    }

    .paper-size-wrap .custom-select-trigger:hover {
      background: rgba(255, 255, 255, 0.07);
      border-color: var(--linen-dark);
    }

    .paper-size-wrap .custom-select.open .custom-select-trigger {
      background: rgba(255, 255, 255, 0.12);
      border-color: var(--linen);
    }

    .paper-size-wrap .custom-select-menu {
      background: #353535;
      border-color: #696252;
    }

    .paper-size-wrap .custom-select-option {
      color: var(--linen);
    }

    .paper-size-wrap .custom-select-option:hover {
      background: #45413a;
    }

    .paper-size-wrap .custom-select-option.selected {
      background: #5b5448;
      color: #fff;
    }

    .header-actions button {
      padding: 0.3rem 0.85rem;
      border: 1px solid var(--earth);
      border-radius: 0;
      font-family: var(--mono);
      font-size: 0.7rem;
      font-weight: 600;
      cursor: pointer;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      transition: all 0.15s;
    }

    .btn-with-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.34rem;
    }

    .btn-with-icon svg {
      width: 0.78rem;
      height: 0.78rem;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.9;
      stroke-linecap: round;
      stroke-linejoin: round;
      flex: 0 0 auto;
    }

    #btn-download {
      background: var(--pink);
      color: var(--charcoal);
      border-color: var(--pink);
    }

    #btn-download:hover {
      background: #b37e87;
    }

    #btn-download:disabled {
      background: #666;
      color: #999;
      border-color: #666;
      cursor: not-allowed;
    }

    #btn-download-typ {
      background: transparent;
      color: var(--earth);
    }

    #btn-download-typ:hover {
      background: rgba(255, 255, 255, 0.06);
      color: var(--linen);
    }

    .main-container {
      display: flex;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .mobile-view-toggle {
      display: none;
      border-bottom: 1px solid var(--earth);
      background: #eae3d7;
      padding: 0.35rem 0.7rem;
      gap: 0.35rem;
    }

    .mobile-view-toggle button {
      border: 1px solid #9f927f;
      background: #f5f0e7;
      color: #4a4338;
      font-family: var(--mono);
      font-size: 0.64rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0.28rem 0.55rem;
      cursor: pointer;
      flex: 1;
    }

    .mobile-view-toggle button.active {
      background: #2f2d2a;
      border-color: #2f2d2a;
      color: #f7f2ea;
    }

    .editor-panel {
      width: var(--editor-pane-width);
      min-width: 300px;
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--earth);
      background: var(--linen);
      overflow: hidden;
      position: relative;
    }

    .settings-launch {
      border: 1px solid #8e826f;
      background: #332f2a;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.62rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0.32rem 0.54rem;
      cursor: pointer;
      min-height: 1.8rem;
    }

    .settings-launch:hover {
      background: #45403a;
    }

    .settings-launch[aria-expanded="true"] {
      background: #4e483f;
    }

    .settings-scrim {
      position: absolute;
      inset: 0;
      background: rgba(24, 21, 17, 0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.16s ease;
      z-index: 34;
    }

    .settings-scrim.open {
      opacity: 1;
      pointer-events: auto;
    }

    .settings-flyout {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: min(31rem, 96%);
      background: #ece5d9;
      border-right: 1px solid #b7ab98;
      transform: translateX(-102%);
      transition: transform 0.18s ease;
      z-index: 35;
      display: flex;
      flex-direction: column;
      box-shadow: 10px 0 26px rgba(34, 30, 24, 0.18);
    }

    .settings-flyout.open {
      transform: translateX(0);
    }

    .settings-flyout-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.45rem;
      padding: 0.52rem 0.72rem;
      border-bottom: 1px solid #cdbfae;
      background: #e3d9ca;
      flex-shrink: 0;
    }

    .settings-flyout-header strong {
      font-size: 0.66rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #3e382f;
    }

    .settings-flyout-header button {
      border: 1px solid #9e927f;
      background: #f6efe3;
      color: #393329;
      font-family: var(--mono);
      font-size: 0.6rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 0.28rem 0.44rem;
      cursor: pointer;
    }

    .settings-flyout-header button:hover {
      background: #ece2d3;
    }

    .settings-flyout-body {
      flex: 1;
      min-height: 0;
      overflow: auto;
    }

    .settings-quick-actions {
      display: grid;
      gap: 0.3rem;
      padding: 0.56rem 0.72rem 0.6rem;
      border-bottom: 1px solid #cfc2b1;
      background: #e7dece;
    }

    .settings-paper-control {
      display: grid;
      gap: 0.24rem;
      max-width: 12rem;
    }

    .settings-paper-control label {
      font-size: 0.6rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-weight: 700;
      color: #443d33;
    }

    .settings-paper-control .custom-select {
      min-width: 0;
      width: 100%;
    }

    .settings-danger-zone {
      border-top: 1px solid #c6b7a5;
      background: #e7ddd0;
      padding: 0.64rem 0.72rem 0.72rem;
      display: grid;
      gap: 0.34rem;
    }

    .settings-danger-zone .danger-title {
      font-size: 0.61rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-weight: 700;
      color: #5b3b40;
    }

    .settings-danger-zone .danger-copy {
      font-size: 0.58rem;
      line-height: 1.45;
      color: #6a504d;
      letter-spacing: 0.025em;
      max-width: 26rem;
    }

    .settings-danger-zone #btn-reset {
      justify-self: start;
      border: 1px solid #a7747d;
      background: #c4909a;
      color: #2f1f23;
      font-family: var(--mono);
      font-size: 0.62rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-weight: 700;
      min-height: 1.8rem;
      padding: 0.3rem 0.56rem;
      cursor: pointer;
    }

    .settings-danger-zone #btn-reset:hover {
      background: #b8818b;
    }

    .settings-accordion {
      border-bottom: 1px solid var(--earth);
      background: #ece5d9;
    }

    .settings-toggle {
      border-bottom: 1px solid #d0c5b3;
    }

    .settings-toggle:last-child {
      border-bottom: 0;
    }

    .settings-toggle summary {
      list-style: none;
      cursor: pointer;
      padding: 0.42rem 0.72rem;
      font-size: 0.64rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #3e382f;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #e9e1d5;
    }

    .settings-toggle summary::-webkit-details-marker {
      display: none;
    }

    .settings-toggle summary::after {
      content: "Open";
      font-size: 0.57rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      color: #6e6456;
    }

    .settings-toggle[open] summary::after {
      content: "Close";
    }

    .settings-toggle[open] summary {
      background: #e3d9ca;
    }

    .settings-body {
      padding: 0.52rem 0.7rem 0.58rem;
      background: #efebe3;
    }

    .pane-resizer {
      width: 10px;
      flex: 0 0 10px;
      border-left: 1px solid #b8ad9a;
      border-right: 1px solid #c8beaf;
      background: linear-gradient(180deg, #ddd5c8, #d2c8b9);
      cursor: col-resize;
      position: relative;
    }

    .pane-resizer::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 3px;
      height: 2.2rem;
      transform: translate(-50%, -50%);
      border-radius: 3px;
      background: rgba(63, 58, 49, 0.38);
      box-shadow: -3px 0 0 rgba(63, 58, 49, 0.2), 3px 0 0 rgba(63, 58, 49, 0.2);
    }

    .main-container.is-resizing,
    .main-container.is-resizing * {
      cursor: col-resize !important;
      user-select: none !important;
    }

    .tabs {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.34rem;
      flex-shrink: 0;
      padding: 0.42rem 0.6rem;
      background: var(--linen-dark);
      border-bottom: 1px solid var(--earth);
    }

    .tab-list {
      display: flex;
      align-items: center;
      gap: 0.36rem;
      min-width: 0;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 0.04rem;
    }

    .tab {
      padding: 0.32rem 0.66rem;
      cursor: pointer;
      font-family: var(--mono);
      font-size: 0.65rem;
      font-weight: 700;
      letter-spacing: 0.055em;
      text-transform: uppercase;
      color: #776d5e;
      background: #ece6dd;
      border: 1px solid transparent;
      transition: all 0.15s;
      user-select: none;
      white-space: nowrap;
    }

    .tab:hover {
      color: var(--charcoal);
      border-color: #c7bca8;
    }

    .tab.active {
      color: var(--linen);
      background: var(--charcoal);
      border-color: var(--charcoal);
    }

    .tab.hidden {
      display: none;
    }

    .tab.disabled {
      opacity: 0.48;
      cursor: not-allowed;
      border-style: dashed;
    }

    .tab.disabled:hover {
      color: #776d5e;
      border-color: transparent;
      background: #ece6dd;
    }

    .tab-actions {
      display: flex;
      gap: 0.28rem;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
    }

    .tab-actions button {
      height: 1.38rem;
      padding: 0 0.46rem;
      border: 1px solid var(--earth);
      border-radius: 2px;
      background: var(--linen);
      font-family: var(--mono);
      font-size: 0.56rem;
      font-weight: 600;
      cursor: pointer;
      color: var(--charcoal);
      letter-spacing: 0.045em;
      text-transform: uppercase;
      line-height: 1;
      white-space: nowrap;
    }

    .tab-actions button:hover {
      background: var(--oatmeal);
    }

    .tab-actions button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .tab-actions .tab-bib-only {
      display: none;
    }

    .tab-actions .tab-bib-only.visible {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .resume-view-toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.22rem;
      border: 1px solid #b8ac98;
      background: #ebe3d6;
      padding: 0.12rem;
      margin-left: 0.08rem;
    }

    .resume-view-toggle button {
      min-width: 4rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
      border-color: transparent;
      background: transparent;
      color: #655c4e;
      font-size: 0.54rem;
      font-weight: 700;
      padding: 0 0.44rem;
    }

    .resume-view-toggle button svg {
      width: 0.7rem;
      height: 0.7rem;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.85;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.72;
      transition: opacity 0.15s ease, stroke 0.15s ease;
    }

    .resume-view-toggle button:hover {
      background: #f4eee5;
      border-color: #c5b7a4;
    }

    .resume-view-toggle button.active {
      background: #2f2d2a;
      color: #f7f2ea;
      border-color: #2f2d2a;
    }

    .resume-view-toggle button.active svg {
      opacity: 1;
    }

    .resume-view-toggle button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .schema-help {
      border-bottom: 1px solid var(--earth);
      background: var(--linen-dark);
      padding: 0.35rem 0.7rem;
      font-size: 0.66rem;
      line-height: 1.45;
      color: var(--charcoal);
    }

    .schema-help summary {
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--charcoal);
    }

    .schema-help code {
      font-family: var(--mono);
      font-size: 0.64rem;
      background: #ece7dd;
      padding: 0.02rem 0.2rem;
    }

    .bib-import-panel {
      border-bottom: 1px solid var(--earth);
      background: #ece6dc;
      padding: 0.44rem 0.68rem 0.48rem;
      display: grid;
      grid-template-columns: minmax(10.2rem, 0.95fr) minmax(11rem, 2fr) auto auto;
      gap: 0.34rem;
      align-items: center;
    }

    .bib-import-panel.hidden {
      display: none;
    }

    .bib-import-panel .bib-import-status {
      grid-column: 1 / -1;
      font-size: 0.6rem;
      color: #665d4f;
      letter-spacing: 0.03em;
      line-height: 1.35;
    }

    .bib-import-panel .bib-import-status.warning {
      color: #7b5614;
      font-weight: 700;
    }

    .bib-import-panel input {
      border: 1px solid var(--earth);
      background: #f6f1e8;
      color: var(--charcoal);
      font-family: var(--mono);
      font-size: 0.63rem;
      padding: 0.36rem 0.42rem;
      min-width: 0;
      height: 2.05rem;
    }

    .bib-import-panel button {
      border: 1px solid #8e826f;
      background: #332f2a;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.6rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      font-weight: 700;
      height: 2.05rem;
      padding: 0 0.58rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .bib-import-panel button.secondary {
      border-color: var(--earth);
      background: #f8f3eb;
      color: #433d34;
      font-weight: 600;
    }

    .bib-import-panel button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .bib-import-panel .custom-select {
      min-width: 0;
      width: 100%;
    }

    .bib-import-panel .custom-select-trigger {
      height: 2.05rem;
      padding: 0.25rem 0.42rem;
      font-size: 0.62rem;
    }

    .override-panel {
      background: transparent;
      padding: 0;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.45rem 0.55rem;
    }

    .override-item {
      display: flex;
      flex-direction: column;
      gap: 0.16rem;
    }

    .override-item.hidden {
      display: none;
    }

    .override-item label {
      font-size: 0.62rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #5a5449;
    }

    .override-item.span-2 {
      grid-column: span 2;
    }

    .override-panel .custom-select {
      min-width: 0;
    }

    .override-panel input[type="text"],
    .override-panel input[type="password"] {
      border: 1px solid var(--earth);
      background: #f6f1e8;
      color: var(--charcoal);
      font-family: var(--mono);
      font-size: 0.63rem;
      padding: 0.38rem 0.44rem;
      min-width: 0;
      height: 2.05rem;
    }

    .override-panel textarea {
      border: 1px solid var(--earth);
      background: #f6f1e8;
      color: var(--charcoal);
      font-family: var(--mono);
      font-size: 0.63rem;
      padding: 0.38rem 0.44rem;
      min-width: 0;
      min-height: 5rem;
      resize: vertical;
    }

    .toggle-inline {
      display: inline-flex;
      gap: 0.42rem;
      align-items: center;
      font-size: 0.62rem;
      font-weight: 700;
      letter-spacing: 0.035em;
      text-transform: none;
      color: #514a3f;
      cursor: pointer;
    }

    .toggle-inline input {
      width: 0.9rem;
      height: 0.9rem;
      accent-color: #39342d;
    }

    .override-item .helper-text {
      font-size: 0.57rem;
      color: #685f50;
      line-height: 1.35;
      letter-spacing: 0.02em;
      margin-top: 0.05rem;
    }

    .mode-segmented {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      border: 1px solid var(--earth);
      background: #e4ddcf;
      padding: 0.14rem;
      gap: 0.14rem;
    }

    .mode-segmented label {
      position: relative;
      margin: 0;
      padding: 0;
      cursor: pointer;
    }

    .mode-segmented input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .mode-segmented span {
      display: block;
      text-align: center;
      font-family: var(--mono);
      font-size: 0.66rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 0.28rem 0.35rem;
      color: #5d5549;
      border: 1px solid transparent;
      background: #f5f0e7;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }

    .mode-segmented input:checked+span {
      background: #2f2d2a;
      color: #f7f2ea;
      border-color: #2f2d2a;
      font-weight: 700;
    }

    .mode-segmented input:disabled+span {
      opacity: 0.46;
      cursor: not-allowed;
      filter: saturate(0.4);
    }

    .compile-controls {
      --compile-control-height: 1.52rem;
      border: 1px solid var(--earth);
      background: #f4efe7;
      padding: 0.2rem 0.24rem;
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      grid-template-areas: "mode compile";
      column-gap: 0.3rem;
      row-gap: 0;
      align-items: stretch;
    }

    .compile-controls .mode-segmented {
      grid-area: mode;
      border: 0;
      background: transparent;
      padding: 0;
      gap: 0.16rem;
      align-self: stretch;
    }

    .compile-controls .mode-segmented span {
      min-height: var(--compile-control-height);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 0.42rem;
      line-height: 1.1;
    }

    .compile-now-btn {
      border: 1px solid #8b816f;
      background: #322f2b;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.61rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0 0.56rem;
      cursor: pointer;
      min-width: 4.9rem;
      min-height: var(--compile-control-height);
      height: var(--compile-control-height);
      grid-area: compile;
      justify-self: end;
      align-self: stretch;
    }

    .compile-now-btn:hover {
      background: #433f3a;
    }

    .compile-now-btn:disabled {
      cursor: not-allowed;
      opacity: 0.45;
      background: #756f66;
      border-color: #756f66;
      color: #dfd8ce;
    }

    .preview-toolbar-top {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 0.4rem;
      min-height: 1.1rem;
    }

    .compile-mode-hint {
      font-size: 0.57rem;
      color: #655d50;
      letter-spacing: 0.02em;
      text-transform: none;
      font-weight: 600;
      padding: 0 0.05rem 0 0;
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1 1 auto;
      width: auto;
      min-width: 0;
    }

    .compile-mode-hint.pending {
      color: #9b6b1a;
    }

    .editor-wrapper {
      flex: 1;
      position: relative;
      min-height: 0;
      overflow: hidden;
    }

    .editor-wrapper .cm-container {
      position: absolute;
      inset: 0;
    }

    .editor-wrapper .cm-container.hidden {
      display: none;
    }

    .resume-ai-workspace {
      border-bottom: 1px solid var(--earth);
      background: #e9e2d5;
      padding: 0.52rem 0.68rem 0.6rem;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 0.48rem;
      max-height: 42vh;
      overflow: auto;
      min-height: 0;
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
    }

    .resume-ai-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.45rem;
      flex-wrap: wrap;
    }

    .resume-ai-header.hidden {
      display: none;
    }

    #resume-ai-workflow {
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 0.62rem;
    }

    .resume-ai-title {
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.055em;
      text-transform: uppercase;
      color: #3f372e;
    }

    .resume-ai-subtitle {
      font-size: 0.57rem;
      color: #62584b;
      letter-spacing: 0.02em;
    }

    .ai-panel-row {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .ai-panel-row.hidden {
      display: none;
    }

    .ai-panel-row label {
      font-size: 0.61rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #5a5449;
    }

    .ai-panel-row textarea {
      min-height: 6rem;
      resize: vertical;
      border: 1px solid var(--earth);
      background: #f8f3eb;
      color: #2f2c27;
      padding: 0.48rem 0.54rem;
      font-family: var(--mono);
      font-size: 0.65rem;
      line-height: 1.5;
      letter-spacing: 0.015em;
    }

    .ai-panel-row select {
      border: 1px solid var(--earth);
      background: #f8f3eb;
      color: #2f2c27;
      padding: 0.34rem 0.42rem;
      font-family: var(--mono);
      font-size: 0.62rem;
      letter-spacing: 0.02em;
      text-transform: none;
      min-height: 1.9rem;
    }

    .ai-panel-row .helper-text {
      font-size: 0.55rem;
      color: #655b4e;
      letter-spacing: 0.02em;
      line-height: 1.4;
    }

    .ai-jd-panel {
      border: 1px solid #cfbfac;
      background: #efe8dc;
    }

    .ai-jd-panel summary {
      list-style: none;
      cursor: pointer;
      padding: 0.4rem 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.45rem;
      font-size: 0.61rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #554d40;
      border-bottom: 1px solid #d7c9b7;
      background: #e8dfd1;
    }

    .ai-jd-panel summary::after {
      content: 'Open ▸';
      margin-left: auto;
      font-size: 0.53rem;
      letter-spacing: 0.03em;
      color: #675b4c;
      text-transform: uppercase;
      font-weight: 700;
    }

    .ai-jd-panel[open] summary::after {
      content: 'Close ▾';
    }

    .ai-jd-panel summary::-webkit-details-marker {
      display: none;
    }

    .ai-jd-panel .ai-panel-row {
      padding: 0.46rem;
    }

    .ai-view-segmented {
      max-width: 12rem;
    }

    #cm-ai-output-container {
      position: absolute;
      inset: 0;
    }

    #cm-ai-output {
      height: 100%;
    }

    #cm-ai-output.hidden {
      display: none;
    }

    .ai-output-placeholder {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 0.9rem;
      font-size: 0.64rem;
      color: #665d50;
      text-align: center;
      letter-spacing: 0.02em;
      line-height: 1.5;
      background: #f4efe6;
      border-top: 1px solid var(--earth);
    }

    #ai-output-diff {
      position: absolute;
      inset: 0;
      margin: 0;
      overflow: auto;
      font-family: var(--mono);
      font-size: 0.63rem;
      line-height: 1.45;
      letter-spacing: 0.01em;
      color: #2f2c27;
      padding: 0.48rem 0.95rem 0.48rem 0.54rem;
      background: #f4efe6;
      white-space: pre;
    }

    #ai-output-diff.hidden {
      display: none;
    }

    #ai-output-diff .diff-line {
      display: block;
    }

    #ai-output-diff .diff-add {
      background: #d9eee0;
      color: #28523b;
    }

    #ai-output-diff .diff-del {
      background: #f3dcdf;
      color: #6e2e39;
    }

    #ai-output-diff .diff-same {
      color: #3c3832;
    }

    .ai-diff-overview {
      position: absolute;
      top: 0.36rem;
      bottom: 0.36rem;
      right: 0.14rem;
      width: 0.34rem;
      border-radius: 999px;
      background: rgba(114, 103, 87, 0.22);
      pointer-events: auto;
      z-index: 3;
      overflow: hidden;
    }

    .ai-diff-overview.hidden {
      display: none;
    }

    .ai-diff-overview-marker {
      position: absolute;
      left: 0;
      right: 0;
      border-radius: 999px;
      min-height: 0.14rem;
      opacity: 0.95;
      cursor: pointer;
    }

    .ai-diff-overview-marker.add {
      background: #4f8e63;
    }

    .ai-diff-overview-marker.del {
      background: #a24f5f;
    }

    .ai-output-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    #btn-ai-copy {
      border: 1px solid #8e826f;
      background: #332f2a;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.6rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0.44rem 0.6rem;
      cursor: pointer;
      min-height: 2.05rem;
    }

    #btn-ai-copy:hover {
      background: #45403a;
    }

    #btn-ai-copy:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .ai-selection-anchor {
      position: fixed;
      width: 1px;
      height: 1px;
      left: 0;
      top: 0;
      pointer-events: none;
      opacity: 0;
      z-index: 89;
      anchor-name: --ai-selection-anchor;
    }

    .ai-selection-popover {
      position: fixed;
      z-index: 90;
      width: min(21.5rem, calc(100vw - 1rem));
      border: 1px solid #9a8a74;
      background: #f7f1e8;
      box-shadow: 0 12px 22px rgba(28, 24, 18, 0.28);
      padding: 0.44rem;
      display: grid;
      gap: 0.34rem;
    }

    @media (min-width: 768px) {
      @supports (position-anchor: --ai-selection-anchor) and (position-area: bottom center) {
        .ai-selection-popover {
          position-anchor: --ai-selection-anchor;
          position-area: bottom center;
          inset: auto;
        }
      }

      @supports (position-anchor: --ai-selection-anchor) and (position-area: block-end center) {
        .ai-selection-popover {
          position-anchor: --ai-selection-anchor;
          position-area: block-end center;
          position-try-fallbacks: flip-block, flip-inline, flip-block flip-inline;
          inset: auto;
        }
      }
    }

    .ai-selection-popover-title {
      font-size: 0.58rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #4b4134;
    }

    .ai-selection-popover textarea {
      min-height: 3.05rem;
      max-height: 8.2rem;
      resize: vertical;
      border: 1px solid var(--earth);
      background: #fff9f1;
      color: #2f2c27;
      padding: 0.35rem 0.44rem;
      font-family: var(--mono);
      font-size: 0.6rem;
      line-height: 1.4;
    }

    .ai-selection-popover-actions {
      display: flex;
      gap: 0.28rem;
      flex-wrap: wrap;
    }

    .ai-selection-popover-actions button {
      border: 1px solid #8e826f;
      background: #332f2a;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.58rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0.32rem 0.5rem;
      cursor: pointer;
      min-height: 1.72rem;
    }

    .ai-selection-popover-actions button:hover {
      background: #45403a;
    }

    .ai-selection-popover-actions button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .ai-selection-popover-actions button.secondary {
      background: #efe6d7;
      color: #4e4438;
      border-color: #b39f83;
    }

    .ai-selection-popover-actions button.secondary:hover {
      background: #e8dece;
    }

    .ai-status {
      border: 1px dashed #9f907b;
      background: #eee6d8;
      color: #62594c;
      font-size: 0.6rem;
      line-height: 1.45;
      padding: 0.4rem 0.48rem;
      letter-spacing: 0.02em;
    }

    .ai-status.error {
      color: #7a3340;
      border-color: #b87c86;
      background: #f0dde1;
      font-weight: 700;
    }

    .ai-status.success {
      color: #2f5a3f;
      border-color: #7fa18d;
      background: #dce9e1;
      font-weight: 700;
    }

    .resume-ai-gate {
      border: 1px dashed #a4937d;
      background: #efe7db;
      color: #574e40;
      font-size: 0.62rem;
      line-height: 1.5;
      letter-spacing: 0.02em;
      padding: 0.5rem 0.56rem;
    }

    .resume-ai-gate strong {
      display: block;
      font-size: 0.63rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #3e372d;
      margin-bottom: 0.2rem;
    }

    .resume-ai-gate button {
      margin-top: 0.4rem;
      border: 1px solid #8e826f;
      background: #332f2a;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.58rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0.3rem 0.52rem;
      cursor: pointer;
      min-height: 1.65rem;
    }

    .resume-ai-gate button:hover {
      background: #45403a;
    }

    .ai-settings-actions {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      align-items: flex-start;
    }

    .ai-settings-actions button {
      border: 1px solid #8e826f;
      background: #332f2a;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.6rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0.34rem 0.56rem;
      cursor: pointer;
      min-height: 1.8rem;
    }

    .ai-settings-actions button:hover {
      background: #45403a;
    }

    .ai-settings-actions button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .ai-verify-status {
      font-size: 0.58rem;
      line-height: 1.4;
      letter-spacing: 0.02em;
      color: #62594c;
    }

    .ai-verify-status.error {
      color: #7a3340;
      font-weight: 700;
    }

    .ai-verify-status.success {
      color: #2f5a3f;
      font-weight: 700;
    }

    .CodeMirror {
      height: 100% !important;
      font-family: var(--mono);
      font-size: 0.78rem;
      line-height: 1.55;
      background: var(--linen) !important;
      color: var(--charcoal) !important;
    }

    .CodeMirror-gutters {
      background: var(--linen-dark) !important;
      border-right: 1px solid var(--earth) !important;
    }

    .CodeMirror-linenumber {
      color: var(--earth) !important;
    }

    .CodeMirror-cursor {
      border-left-color: var(--purple) !important;
      border-left-width: 2px !important;
    }

    .CodeMirror-selected,
    .CodeMirror-focused .CodeMirror-selected {
      background: rgba(125, 107, 138, 0.15) !important;
    }

    .CodeMirror-activeline-background {
      background: rgba(125, 107, 138, 0.06) !important;
    }

    .cm-s-default .cm-atom {
      color: var(--purple);
    }

    .cm-s-default .cm-number {
      color: var(--pink);
    }

    .cm-s-default .cm-string {
      color: #6a7d5a;
    }

    .cm-s-default .cm-keyword {
      color: var(--purple);
    }

    .cm-s-default .cm-meta {
      color: var(--pink);
    }

    .cm-s-default .cm-comment {
      color: var(--earth);
    }

    @media (max-width: 1024px) {

      .CodeMirror,
      .CodeMirror pre,
      .CodeMirror-line,
      .CodeMirror-line-like {
        -webkit-user-select: text !important;
        user-select: text !important;
        -webkit-touch-callout: default;
      }
    }

    .preview-panel {
      flex: 1;
      overflow: hidden;
      background: var(--oatmeal);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      padding: 0 1rem 1rem;
      gap: 0;
      position: relative;
    }

    .preview-toolbar {
      width: min(760px, 100%);
      margin: 0 auto 0.55rem;
      background: #efe7db;
      border: 1px solid var(--earth);
      padding: 0.26rem 0.4rem 0.3rem;
      display: flex;
      flex-direction: column;
      gap: 0.16rem;
      position: relative;
      z-index: 2;
      box-shadow: 0 2px 8px rgba(49, 42, 32, 0.1);
    }

    .preview-toolbar .toolbar-label {
      font-size: 0.56rem;
      font-weight: 700;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      color: #5a5449;
    }

    .preview-pages {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      width: 100%;
      padding: 0.1rem 0 0.4rem;
    }

    .preview-scroll {
      flex: 1;
      min-height: 0;
      overflow: auto;
      width: 100%;
      position: relative;
    }

    .preview-panel .page {
      background: #fff;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
      border: 1px solid var(--earth);
      max-width: 100%;
    }

    .preview-panel .page svg {
      display: block;
      max-width: 100%;
      height: auto;
    }

    .preview-feedback {
      position: absolute;
      inset: 0.4rem;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 15;
    }

    .preview-panel.compiling .preview-feedback {
      display: flex;
    }

    .preview-panel.compiling .preview-pages {
      opacity: 0.58;
      filter: saturate(0.82);
    }

    .preview-feedback-card {
      padding: 0.8rem 0.92rem;
      background: rgba(248, 243, 234, 0.97);
      border: 1px dashed #a89b87;
      display: flex;
      align-items: center;
      gap: 0.55rem;
      box-shadow: 0 2px 10px rgba(37, 33, 27, 0.08);
      max-width: 100%;
    }

    .preview-feedback-spinner {
      width: 0.85rem;
      height: 0.85rem;
      border: 2px solid rgba(125, 107, 138, 0.2);
      border-top-color: var(--purple);
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      flex: 0 0 auto;
    }

    .preview-feedback-text {
      font-size: 0.67rem;
      color: #534d41;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 700;
    }

    .preview-panel.has-error .preview-feedback-card {
      background: rgba(244, 222, 226, 0.96);
      border-color: var(--pink);
    }

    .preview-panel.has-error .preview-feedback-text {
      color: #6f2d38;
    }

    .status-bar {
      background: var(--charcoal);
      color: var(--earth);
      padding: 0.25rem 1.2rem;
      font-family: var(--mono);
      font-size: 0.65rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .status-bar.error {
      color: var(--pink);
    }

    .status-bar.compiling {
      color: var(--earth);
    }

    .status-bar.ready {
      color: #8a9a7d;
    }

    .status-bar.pending {
      color: #d8be7b;
    }

    .credit-bar {
      background: #2d2a26;
      color: #a79a88;
      padding: 0.2rem 1.2rem 0.24rem;
      font-family: var(--mono);
      font-size: 0.58rem;
      letter-spacing: 0.03em;
      border-top: 1px solid #3d3831;
      line-height: 1.45;
    }

    .credit-bar a {
      color: #d7c1a9;
      text-decoration: underline;
      text-underline-offset: 0.1em;
    }

    .credit-bar a:hover {
      color: #f0d8bd;
    }

    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(44, 44, 44, 0.94);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--linen);
      z-index: 100;
      gap: 1rem;
    }

    .loading-overlay .spinner {
      width: 32px;
      height: 32px;
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-top-color: var(--pink);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .loading-overlay p {
      font-family: var(--mono);
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--earth);
    }

    .confirm-modal {
      position: fixed;
      inset: 0;
      background: rgba(23, 21, 18, 0.62);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 120;
      padding: 1rem;
    }

    .confirm-modal.open {
      display: flex;
    }

    .confirm-dialog {
      width: min(420px, 100%);
      background: #f6f1e7;
      border: 1px solid #9d927f;
      box-shadow: 0 12px 30px rgba(28, 26, 22, 0.24);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }

    .confirm-dialog h2 {
      font-size: 0.82rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #312d25;
    }

    .confirm-dialog p {
      font-size: 0.69rem;
      line-height: 1.5;
      color: #4a4439;
      letter-spacing: 0.02em;
    }

    .confirm-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.45rem;
    }

    .confirm-actions button {
      border: 1px solid #9d927f;
      background: transparent;
      color: #3a352c;
      font-family: var(--mono);
      font-size: 0.68rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 0.33rem 0.7rem;
      cursor: pointer;
    }

    .confirm-actions button:hover {
      background: #ece4d7;
    }

    .confirm-actions .danger {
      background: #c4909a;
      border-color: #c4909a;
      color: #2d1f22;
      font-weight: 700;
    }

    .confirm-actions .danger:hover {
      background: #b47f89;
    }

    @media (max-width: 1024px) {
      header {
        gap: 0.4rem;
        flex-wrap: wrap;
      }

      .header-actions {
        width: 100%;
        justify-content: flex-start;
        gap: 0.4rem;
      }

      .mobile-view-toggle {
        display: flex;
      }

      .main-container {
        flex-direction: column;
      }

      .editor-panel,
      .pane-resizer,
      .preview-panel {
        width: 100%;
        min-width: 0;
      }

      .editor-panel {
        border-right: none;
        border-bottom: 1px solid var(--earth);
      }

      .pane-resizer {
        display: none;
      }

      .preview-panel {
        border-top: 1px solid var(--earth);
      }

      .main-container.mobile-editor .preview-panel {
        display: none;
      }

      .main-container.mobile-preview .editor-panel {
        display: none;
      }

      .main-container.mobile-editor,
      .main-container.mobile-preview {
        flex: 1;
        min-height: 0;
      }

      .main-container.mobile-editor .editor-panel,
      .main-container.mobile-preview .preview-panel {
        display: flex;
        flex: 1 1 auto;
        min-height: 0;
      }

      .main-container.mobile-editor .editor-wrapper,
      .main-container.mobile-preview .preview-scroll {
        flex: 1 1 auto;
        min-height: 0;
      }
    }

    @media (max-width: 768px) {
      header {
        padding: 0.5rem 0.7rem;
      }

      header h1 {
        font-size: 0.76rem;
      }

      header .subtitle {
        font-size: 0.58rem;
      }

      .header-actions {
        width: 100%;
        display: flex;
        flex-wrap: nowrap;
        overflow-x: auto;
        gap: 0.26rem;
        padding-bottom: 0.06rem;
      }

      .header-actions button,
      .header-actions .share-menu,
      .header-actions .paper-size-wrap {
        width: auto;
        flex: 0 0 auto;
      }

      .paper-size-wrap {
        justify-content: flex-start;
        padding: 0.18rem 0.24rem;
        border: 1px solid #6a5f4f;
        background: rgba(255, 255, 255, 0.04);
        gap: 0.24rem;
      }

      .paper-size-wrap .custom-select {
        min-width: 0;
        width: auto;
      }

      .share-menu-panel {
        left: auto;
        right: 0;
        min-width: 12rem;
      }

      .header-actions .btn-with-icon span {
        display: none;
      }

      .header-actions button {
        min-width: 2rem;
        padding: 0.28rem 0.34rem;
      }

      .paper-size-wrap .custom-select-trigger {
        font-size: 0.58rem;
        padding: 0.2rem 0.24rem;
      }

      .main-container {
        flex-direction: column;
      }

      .editor-panel {
        width: 100%;
        min-width: 0;
        border-right: none;
      }

      .settings-flyout {
        width: min(34rem, 100%);
      }

      .pane-resizer {
        display: none;
      }

      .preview-panel {
        padding: 0 0.7rem 0.7rem;
      }

      .preview-feedback {
        inset: 0.3rem;
      }

      .tabs {
        gap: 0.42rem;
      }

      .tab {
        padding: 0.28rem 0.5rem;
        font-size: 0.6rem;
      }

      .tab-actions {
        justify-content: flex-start;
        flex-wrap: nowrap;
        overflow-x: auto;
        padding-bottom: 0.04rem;
      }

      .tab-actions button {
        flex: 0 0 auto;
      }

      #btn-undo,
      #btn-redo,
      #btn-upload,
      #btn-upload-refresh,
      #btn-upload-gist {
        min-width: 2rem;
        padding: 0 0.34rem;
      }

      #btn-undo span,
      #btn-redo span,
      #btn-upload span,
      #btn-upload-refresh span,
      #btn-upload-gist span,
      #btn-resume-view-original span,
      #btn-resume-view-ai span {
        display: none;
      }

      .resume-view-toggle {
        margin-left: 0;
      }

      .resume-view-toggle button {
        min-width: 2rem;
        padding: 0 0.32rem;
      }

      .resume-ai-workspace {
        max-height: 48vh;
        padding: 0.46rem 0.56rem 0.54rem;
      }

      .upload-menu-panel {
        min-width: 14.1rem;
        left: 0;
      }

      .override-item.span-2 {
        grid-column: span 1;
      }

      .override-panel {
        grid-template-columns: 1fr;
      }

      .compile-controls {
        grid-template-columns: minmax(0, 1fr) auto;
        grid-template-areas: "mode compile";
        row-gap: 0;
      }

      .compile-mode-hint {
        text-align: left;
        padding-left: 0;
      }

      .bib-import-panel {
        grid-template-columns: 1fr;
      }

      .compile-now-btn {
        grid-area: compile;
        width: auto;
      }

      .preview-toolbar-top {
        gap: 0.3rem;
      }

      .preview-toolbar {
        width: 100%;
        padding: 0.26rem 0.3rem 0.32rem;
      }

      .paper-size-wrap>span {
        display: inline;
      }
    }

    @media (max-width: 520px) {
      .header-actions .paper-size-wrap>span {
        display: none;
      }

      .header-actions button {
        padding: 0.26rem 0.3rem;
      }

      .settings-flyout {
        width: 100%;
      }

      .resume-ai-workspace {
        max-height: 52vh;
      }

      .upload-menu-panel {
        left: 0;
        right: auto;
      }

      .ai-selection-popover {
        width: calc(100vw - 0.7rem);
        max-width: calc(100vw - 0.7rem);
        padding: 0.38rem;
      }

      .ai-selection-popover textarea {
        min-height: 2.8rem;
      }
    }
  </style>
</head>

<body>

  <div class="loading-overlay" id="loading-overlay">
    <div class="spinner"></div>
    <p>initializing typst compiler...</p>
  </div>

  <header>
    <div>
      <h1>Resume Compiler</h1>
      <div class="subtitle">yaml + typst // pdf generator</div>
    </div>
    <div class="header-actions">
      <button id="btn-settings" class="settings-launch btn-with-icon" type="button" aria-expanded="false"
        aria-controls="settings-flyout">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M4 21v-7"></path>
          <path d="M4 10V3"></path>
          <path d="M12 21v-9"></path>
          <path d="M12 8V3"></path>
          <path d="M20 21v-5"></path>
          <path d="M20 12V3"></path>
          <path d="M2 14h4"></path>
          <path d="M10 8h4"></path>
          <path d="M18 16h4"></path>
        </svg>
        <span>Settings</span>
      </button>
      <button id="btn-download-typ" class="btn-with-icon">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M8 7h8M8 11h8M8 15h5"></path>
          <path d="M5 4h14v16H5z"></path>
        </svg>
        <span>Download resume.typ</span>
      </button>
      <div class="share-menu" id="share-menu">
        <button id="btn-share" class="btn-with-icon" type="button" aria-haspopup="menu" aria-expanded="false">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M10 13.5l4-3"></path>
            <path d="M10 10.5l4 3"></path>
            <circle cx="7" cy="12" r="2.2"></circle>
            <circle cx="17" cy="8" r="2.2"></circle>
            <circle cx="17" cy="16" r="2.2"></circle>
          </svg>
          <span>Share</span>
        </button>
        <div class="share-menu-panel" id="share-menu-panel" role="menu" aria-label="Share URL options">
          <button id="btn-share-without-key" type="button" role="menuitem">Copy URL (Without Keys)</button>
          <button id="btn-share-with-key" type="button" role="menuitem">Copy URL (With AI/GitHub Key)</button>
        </div>
      </div>
      <button id="btn-download" class="btn-with-icon" disabled>
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 4v10"></path>
          <path d="M8.5 10.5L12 14l3.5-3.5"></path>
          <path d="M4 18h16"></path>
        </svg>
        <span>Download PDF</span>
      </button>
    </div>
  </header>

  <div class="mobile-view-toggle" id="mobile-view-toggle">
    <button type="button" data-mobile-view="editor" class="active">Editor</button>
    <button type="button" data-mobile-view="preview">Preview PDF</button>
  </div>

  <div class="main-container mobile-editor">
    <div class="editor-panel">
      <div class="settings-scrim" id="settings-scrim"></div>
      <aside class="settings-flyout" id="settings-flyout" aria-hidden="true">
        <div class="settings-flyout-header">
          <strong>Settings</strong>
          <button id="btn-settings-close" type="button">Close</button>
        </div>
        <div class="settings-flyout-body">
          <div class="settings-quick-actions">
            <div class="settings-paper-control">
              <label for="paper-size">Paper Size</label>
              <select id="paper-size">
                <option value="letter">Letter</option>
                <option value="a4">A4</option>
              </select>
            </div>
          </div>
          <div class="settings-accordion">
            <details class="settings-toggle" id="panel-overrides" open>
              <summary>Compile Overrides</summary>
              <div class="settings-body">
                <div class="override-panel">
                  <div class="override-item">
                    <label for="override-variant">Length</label>
                    <select id="override-variant">
                      <option value="default">default</option>
                      <option value="short">short</option>
                    </select>
                  </div>
                  <div class="override-item">
                    <label for="override-source">Source</label>
                    <select id="override-source">
                      <option value="resume">resume yaml</option>
                      <option value="bibtex">bibtex</option>
                    </select>
                  </div>
                  <div class="override-item">
                    <label for="override-link-mode">Link Mode</label>
                    <select id="override-link-mode">
                      <option value="links">links on</option>
                      <option value="no-js">no-js</option>
                    </select>
                  </div>
                  <div class="override-item">
                    <label for="override-links-disabled-behavior">Link-Off Rendering</label>
                    <select id="override-links-disabled-behavior">
                      <option value="label">Keep Label Only</option>
                      <option value="label_with_url">Label + [url]</option>
                    </select>
                  </div>
                  <div class="override-item">
                    <label for="override-pubnums">Publication Numbers</label>
                    <select id="override-pubnums">
                      <option value="on">Show [n]</option>
                      <option value="off">Hide [n]</option>
                    </select>
                  </div>
                  <div class="override-item">
                    <label for="override-contact">Contact Style</label>
                    <select id="override-contact">
                      <option value="label">Label</option>
                      <option value="icon_label">Icon + Label</option>
                    </select>
                  </div>
                  <div class="override-item">
                    <label for="override-font">General Font</label>
                    <select id="override-font">
                      <option value="New Computer Modern">New Computer Modern</option>
                      <option value="Libertinus Serif">Libertinus Serif</option>
                      <option value="TeX Gyre Termes">TeX Gyre Termes</option>
                      <option value="TeX Gyre Pagella">TeX Gyre Pagella</option>
                      <option value="DejaVu Serif">DejaVu Serif</option>
                    </select>
                  </div>
                  <div class="override-item">
                    <label for="override-mono-font">Monospace Font</label>
                    <select id="override-mono-font">
                      <option value="DejaVu Sans Mono">DejaVu Sans Mono</option>
                      <option value="Libertinus Mono">Libertinus Mono</option>
                      <option value="New Computer Modern Mono">New Computer Modern Mono</option>
                      <option value="Fira Code">Fira Code</option>
                      <option value="JetBrains Mono">JetBrains Mono</option>
                      <option value="Cascadia Mono">Cascadia Mono</option>
                    </select>
                  </div>
                </div>
              </div>
            </details>
            <details class="settings-toggle" id="panel-ai-settings">
              <summary>AI Settings</summary>
              <div class="settings-body">
                <div class="override-panel">
                  <div class="override-item">
                    <label for="ai-provider">AI Provider</label>
                    <select id="ai-provider">
                      <option value="disabled">Disabled</option>
                      <option value="openai">OpenAI</option>
                      <option value="gemini">Gemini</option>
                      <option value="openrouter">OpenRouter</option>
                      <option value="groq">Groq</option>
                      <option value="claude">Claude</option>
                    </select>
                  </div>
                  <div class="override-item">
                    <label for="ai-model">AI Model</label>
                    <input id="ai-model" type="text" placeholder="Provider model id">
                  </div>
                  <div class="override-item span-2 ai-key-item">
                    <label for="ai-api-key">AI API Key (for generation + optional secure sharing)</label>
                    <input id="ai-api-key" type="password" placeholder="Paste API key (stored in this browser)">
                    <div class="helper-text">Share supports two options: without keys, or with available AI/GitHub keys.
                    </div>
                  </div>
                  <div class="override-item span-2">
                    <div class="ai-settings-actions">
                      <button id="btn-ai-verify" type="button">Verify AI Settings</button>
                      <div id="ai-verify-status" class="ai-verify-status">Not verified.</div>
                    </div>
                  </div>
                  <div class="override-item span-2 ai-search-item" id="ai-search-item">
                    <label class="toggle-inline" for="ai-web-search">
                      <input id="ai-web-search" type="checkbox" checked>
                      <span>Allow provider web-search tools (if supported)</span>
                    </label>
                    <div class="helper-text">Generation always uses original <code>Resume (YAML)</code> as source.</div>
                  </div>
                  <div class="override-item span-2" id="ai-prompt-item">
                    <label for="ai-user-prompt">Resume Rewrite Instructions</label>
                    <textarea id="ai-user-prompt" spellcheck="false"
                      placeholder="Optional: focus areas like impact quantification, ATS keywords, concise bullets..."></textarea>
                    <div class="helper-text">Used when generating AI resume variants for <code>resume.yml</code>.</div>
                  </div>
                </div>
              </div>
            </details>
            <details class="settings-toggle" id="panel-integrations">
              <summary>Integrations</summary>
              <div class="settings-body">
                <div class="override-panel">
                  <div class="override-item span-2">
                    <label for="github-token">GitHub Token (Gist Sync)</label>
                    <input id="github-token" type="password" placeholder="github_pat_...">
                    <div class="helper-text">Stored only in this browser. Verify this token to enable private GitHub URL
                      loading and gist updates.</div>
                  </div>
                  <div class="override-item span-2">
                    <div class="ai-settings-actions">
                      <button id="btn-github-verify" type="button">Verify GitHub Token</button>
                      <div id="github-verify-status" class="ai-verify-status">Not verified.</div>
                    </div>
                    <div class="helper-text">Token should include <code>gist</code> scope and access to any private
                      repos you load from URL.</div>
                  </div>
                </div>
              </div>
            </details>
          </div>
          <div class="settings-danger-zone">
            <div class="danger-title">Danger Zone</div>
            <div class="danger-copy">Reset clears local settings, editor content, AI data, and saved URL sources in this
              browser.</div>
            <button id="btn-reset" class="btn-with-icon" type="button">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M4 12a8 8 0 1 0 2.3-5.7"></path>
                <path d="M4 4v5h5"></path>
              </svg>
              <span>Reset to Defaults</span>
            </button>
          </div>
        </div>
      </aside>
      <div class="tabs">
        <div class="tab-list">
          <div class="tab active" data-tab="resume">Resume (YAML)</div>
          <div class="tab" data-tab="config">Config (YAML)</div>
          <div class="tab" data-tab="config-short">Config Short (YAML)</div>
          <div class="tab" data-tab="bib">Publications (BibTeX)</div>
        </div>
        <div class="tab-actions">
          <button id="btn-undo" class="btn-with-icon" aria-label="Undo (Cmd/Ctrl+Z)">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="m9 14-5-5 5-5"></path>
              <path d="M4 9h10a5 5 0 1 1 0 10h-4"></path>
            </svg>
            <span>Undo</span>
          </button>
          <button id="btn-redo" class="btn-with-icon" aria-label="Redo (Cmd/Ctrl+Shift+Z or Ctrl+Y)">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="m15 14 5-5-5-5"></path>
              <path d="M20 9H10a5 5 0 1 0 0 10h4"></path>
            </svg>
            <span>Redo</span>
          </button>
          <button id="btn-bib-clean" class="tab-bib-only" aria-label="Clean BibTeX (when BibTeX tab is active)">Clean
            .bib</button>
          <button id="btn-bib-download" class="tab-bib-only"
            aria-label="Download BibTeX (when BibTeX tab is active)">Download .bib</button>
          <div class="upload-menu" id="upload-menu">
            <button id="btn-upload" class="btn-with-icon" aria-label="Upload options" aria-haspopup="menu"
              aria-expanded="false" type="button">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 16V4"></path>
                <path d="m7 9 5-5 5 5"></path>
                <path d="M4 20h16"></path>
              </svg>
              <span>Upload</span>
            </button>
            <div class="upload-menu-panel" id="upload-menu-panel" role="menu" aria-label="Upload source options">
              <button id="btn-upload-file" type="button" role="menuitem">Choose from Files</button>
              <div class="upload-url-block">
                <label for="upload-url-input">Gist URL</label>
                <input id="upload-url-input" type="url" spellcheck="false"
                  placeholder="https://gist.github.com/username/gist-id">
                <button id="btn-upload-url" type="button">Load from URL</button>
                <button id="btn-upload-refresh" type="button" aria-label="Refresh URL content from saved URL"
                  disabled>Refresh URL Content</button>
                <div class="helper">Loads into the current tab. Supports GitHub gist links and direct raw file URLs.
                </div>
              </div>
            </div>
          </div>
          <button id="btn-upload-gist" class="btn-with-icon hidden" aria-label="Update source gist" type="button"
            disabled>
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M10 14 7 17a4 4 0 1 1-6-6l3-3a4 4 0 0 1 6 6l-1 1"></path>
              <path d="m14 10 3-3a4 4 0 1 1 6 6l-3 3a4 4 0 0 1-6-6l1-1"></path>
              <path d="m8 16 8-8"></path>
            </svg>
            <span>Update Gist</span>
          </button>
          <div class="resume-view-toggle hidden" id="resume-view-toggle" role="group" aria-label="Resume view mode">
            <button id="btn-resume-view-original" type="button" class="active" aria-pressed="true">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M14 3H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path>
                <path d="M14 3v6h6"></path>
              </svg>
              <span>Original</span>
            </button>
            <button id="btn-resume-view-ai" type="button" aria-pressed="false">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="m12 3 1.55 3.95L17.5 8.5l-3.95 1.55L12 14l-1.55-3.95L6.5 8.5l3.95-1.55L12 3z"></path>
                <path d="m18.5 14.5.8 2.05 2.05.8-2.05.8-.8 2.05-.8-2.05-2.05-.8 2.05-.8.8-2.05z"></path>
                <path d="m5.5 14.5.6 1.55 1.55.6-1.55.6-.6 1.55-.6-1.55-1.55-.6 1.55-.6.6-1.55z"></path>
              </svg>
              <span>AI</span>
            </button>
          </div>
          <input type="file" id="file-input" name="source-file-input" aria-label="Upload source file"
            accept=".yml,.yaml,.bib,.txt" style="display:none">
        </div>
      </div>
      <div class="bib-import-panel hidden" id="bib-import-panel">
        <label for="bib-import-provider" class="visually-hidden">Bibliography import provider</label>
        <select id="bib-import-provider" name="bib-import-provider" aria-label="Bibliography import provider">
          <option value="dblp">DBLP Author ID</option>
          <option value="semantic">Semantic Scholar Author ID</option>
          <option value="google">Google Scholar ID</option>
        </select>
        <label for="bib-import-id" class="visually-hidden">Bibliography import identifier</label>
        <input id="bib-import-id" name="bib-import-id" aria-label="Bibliography import identifier" type="text"
          placeholder="Enter ID (or full profile URL). Example: j/Geffner:Blai or 1234567">
        <button id="btn-bib-import" type="button">Import + Merge</button>
        <button id="btn-bib-import-replace" class="secondary" type="button">Import + Replace</button>
        <div id="bib-import-status" class="bib-import-status">
          Imports merge generated BibTeX entries from a provider ID into the current `.bib`. Duplicate titles are
          flagged.
        </div>
      </div>
      <details class="schema-help">
        <summary>Supported Keys</summary>
        <div id="supported-keys-content">
          <div>Loading tab-specific key hints...</div>
        </div>
      </details>
      <div class="resume-ai-workspace hidden" id="resume-ai-workspace">
        <div class="resume-ai-header" id="resume-ai-header">
          <div class="resume-ai-title">Resume AI Variant (Resume YAML Only)</div>
          <div class="resume-ai-subtitle">Original <code>resume.yml</code> remains unchanged.</div>
        </div>
        <div id="resume-ai-gate" class="resume-ai-gate hidden">
          <strong>AI setup required</strong>
          <div>AI is not verified yet. Verify provider/model/key to generate a tailored variant, compare Original vs AI diff, and enable AI output for compile/PDF.</div>
          <button id="btn-open-ai-settings" type="button">Open AI Settings</button>
        </div>
        <div id="resume-ai-workflow" class="hidden">
          <div class="override-item hidden" id="resume-use-generated-row">
            <label class="toggle-inline" for="resume-use-generated">
              <input id="resume-use-generated" type="checkbox">
              <span>Use AI Variant Resume for Compile/PDF</span>
            </label>
          </div>
          <details class="ai-jd-panel" id="ai-jd-panel" open>
            <summary>Target Job Description</summary>
            <div class="ai-panel-row">
              <label for="ai-job-description" class="visually-hidden">Target job description</label>
              <textarea id="ai-job-description" name="ai-job-description" aria-label="Target job description"
                spellcheck="false" placeholder="Paste the JD here to tailor a variant toward this role."></textarea>
            </div>
          </details>
          <div class="ai-panel-row hidden" id="ai-output-panel">
            <div class="ai-output-toolbar">
              <div class="mode-segmented ai-view-segmented" role="radiogroup" aria-label="Generated view mode">
                <label>
                  <input type="radio" name="ai-output-view" value="variant" checked>
                  <span>Variant</span>
                </label>
                <label>
                  <input type="radio" name="ai-output-view" value="diff">
                  <span>Diff</span>
                </label>
              </div>
              <button id="btn-ai-copy" type="button" disabled>Copy Variant</button>
            </div>
          </div>
          <div id="ai-status" class="ai-status">Set AI provider + key to generate resume variants from Resume YAML.
          </div>
          <div id="ai-selection-anchor" class="ai-selection-anchor hidden" aria-hidden="true"></div>
          <div id="ai-selection-popover" class="ai-selection-popover hidden" popover="manual"
            anchor="ai-selection-anchor" role="dialog" aria-label="Rewrite selected YAML">
            <div class="ai-selection-popover-title">Rewrite Selected Block</div>
            <label for="ai-selection-prompt" class="visually-hidden">Selected block rewrite prompt</label>
            <textarea id="ai-selection-prompt" name="ai-selection-prompt" aria-label="Selected block rewrite prompt"
              spellcheck="false" placeholder="Optional instruction for this selected block..."></textarea>
            <div class="ai-selection-popover-actions">
              <button id="btn-ai-selection-generate" type="button">Generate</button>
              <button id="btn-ai-selection-dismiss" class="secondary" type="button">Dismiss</button>
            </div>
          </div>
        </div>
      </div>
      <div class="editor-wrapper">
        <div class="cm-container" id="cm-resume"></div>
        <div class="cm-container hidden" id="cm-config"></div>
        <div class="cm-container hidden" id="cm-config-short"></div>
        <div class="cm-container hidden" id="cm-bib"></div>
        <div class="cm-container hidden" id="cm-ai-output-container">
          <div id="cm-ai-output"></div>
        </div>
        <pre id="ai-output-diff" class="hidden"></pre>
        <div id="ai-diff-overview" class="ai-diff-overview hidden"></div>
        <div class="ai-output-placeholder hidden" id="ai-output-placeholder">
          Select text in Variant view to rewrite it with AI.
        </div>
      </div>
    </div>
    <div class="pane-resizer" id="pane-resizer" role="separator" aria-orientation="vertical"
      aria-label="Resize editor and preview columns"></div>
    <div class="preview-panel" id="preview">
      <div class="preview-toolbar">
        <div class="preview-toolbar-top">
          <div class="toolbar-label">Compile</div>
          <div id="compile-mode-hint" class="compile-mode-hint">Auto compile on every change</div>
        </div>
        <div class="compile-controls">
          <div class="mode-segmented" role="radiogroup" aria-label="Compile mode">
            <label>
              <input type="radio" name="compile-mode" value="auto" checked>
              <span>auto</span>
            </label>
            <label>
              <input type="radio" name="compile-mode" value="manual">
              <span>manual</span>
            </label>
          </div>
          <button id="btn-compile-now" class="compile-now-btn" type="button">Compile</button>
        </div>
      </div>
      <div class="preview-scroll" id="preview-scroll">
        <div class="preview-pages" id="preview-pages"></div>
        <div class="preview-feedback" id="preview-feedback" aria-live="polite">
          <div class="preview-feedback-card">
            <div class="preview-feedback-spinner"></div>
            <div class="preview-feedback-text" id="preview-feedback-text">Compiling changes...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="confirm-modal" id="confirm-modal" aria-hidden="true">
    <div class="confirm-dialog" role="dialog" aria-modal="true" aria-labelledby="confirm-title"
      aria-describedby="confirm-message">
      <h2 id="confirm-title">Confirm action</h2>
      <p id="confirm-message">Proceed?</p>
      <div class="confirm-actions">
        <button type="button" id="confirm-cancel">Cancel</button>
        <button type="button" id="confirm-accept" class="danger">Confirm</button>
      </div>
    </div>
  </div>

  <div class="status-bar" id="status-bar">Loading...</div>
  <div class="credit-bar">
    Built by <a href="https://mimansajaiswal.github.io" target="_blank" rel="noopener noreferrer">Mimansa Jaiswal</a>
    · See more <a href="https://mimansajaiswal.github.io/tools/" target="_blank" rel="noopener noreferrer">Tools Made
      with LLMs</a>
    · Code: <a href="https://github.com/mimansajaiswal/resume-compiler" target="_blank"
      rel="noopener noreferrer">resume-compiler</a>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/mode/yaml/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/mode/stex/stex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/diff@5.2.0/dist/diff.min.js"></script>
  <script type="module"
    src="https://cdn.jsdelivr.net/npm/@myriaddreamin/typst.ts@0.7.0-rc2/dist/esm/contrib/all-in-one-lite.bundle.js"
    id="typst">
    </script>

  <script type="module">

    const DEFAULT_RESUME_YAML = `personal:
  name: Your Name
  email: your.email@example.com
  url: https://yourwebsite.com
  titles:
    - Your Title

work:
  - name: Company Name
    url: https://company.com
    positions:
      - name: Senior Research Engineer
        startDate: 2024-01-01
        endDate: present
        content:
          - "Describe your current-role accomplishments here"
      - name: Research Engineer
        startDate: 2022-01-01
        endDate: 2023-12-01
        content:
          - "Describe your previous role at the same company here"

education:
  - name: University Name
    location: City, State
    studyType: B.S.
    area: Your Major
    startDate: 2020-09-01
    endDate: 2024-05-01
    content:
      - "*Advisor*: Prof. Example Person"

# Generic section example (auto-rendered even if omitted from section_order):
community_service:
  - name: Theorem Proving Reading Group
    startDate: 2023-01-01
    endDate: present
    content:
      - "Organize monthly paper discussions and proof clinics."

skills:
  - category: Technical Skills
    skills:
      - Skill 1
      - Skill 2
      - Skill 3
`;

    const DEFAULT_CONFIG_YAML = `variant: long
paper_size: "letter"
fonts:
  font: "Libertinus Serif"
  mono_font: "DejaVu Sans Mono"
  font_size: 10pt
  name_font_size: 1.4em
  section_font_size: 1em
  publications_font_size: 9.6pt
  awards_font_size: 10pt
  page_number_font_size: 0.85em
  header_title_font_size: 0.9em
  location_font_size: 0.8em
  work_role_font_size: 0.98em
layout:
  margin: 0.5in
  line_spacing: 0.38em
  list_spacing: 0.7em
  section_spacing: 1.38em
  post_section_spacing: 0.9em
  entry_spacing: 0.71em
  entry_inner_spacing: 0.55em
  pub_spacing: 0.7em
  publications_line_spacing: 0.38em
  publications_heading_tighten: 0pt
  skill_spacing: 0.7em
  header_rule_top_spacing: 0.6em
  header_bottom_spacing: 0.35em
  contact_separator_spacing: 0.35em
  last_updated_bottom_spacing: 0.23em
styling:
  section_smallcaps: false
  secondary_color: "#111111"
  link_color: "#1C398D"
  section_rule_color: "#9F9FA8"
  section_rule_thickness: 0.6pt
  section_heading_sticky: true
  header_rule_color: "#9F9FA8"
  publications_link_style: "compact"
  publication_title_bold: false
  publication_autobold_authors: true
  publication_bold_author_names: []
  contact_font_size: 0.85em
  summary_font_size: 1em
  last_updated_font_size: 0.8em
  last_updated_label: "Last Updated on"
  contact_display_mode: "icon_label"
  contact_icon_spacing: 0.21em
visibility:
  show_location: false
  show_phone: true
  show_interests_summary: false
  show_languages: true
  show_interests: false
  show_references: false
  show_last_updated: true
  enable_links: true
  links_disabled_behavior: "label"
  show_publication_numbers: false
section_titles:
  work: "Experience"
  education: "Education"
  publications: "Publications"
  projects: "Projects"
  awards: "Honors and Awards"
  skills: "Skills"
section_order:
  - work
  - education
  - skills
`;

    const DEFAULT_SHORT_CONFIG_YAML = `variant: short
paper_size: "letter"
fonts:
  font: "Libertinus Serif"
  mono_font: "DejaVu Sans Mono"
  font_size: 10.2pt
  name_font_size: 1.5em
  section_font_size: 1em
  publications_font_size: 9.6pt
  awards_font_size: 10pt
  page_number_font_size: 0.8em
  header_title_font_size: 0.84em
  location_font_size: 0.74em
  work_role_font_size: 0.96em
layout:
  margin: 0.5in
  line_spacing: 0.33em
  skills_line_spacing: 0.33em
  list_spacing: 0.54em
  section_spacing: 1em
  post_section_spacing: 0.68em
  entry_spacing: 0.5em
  entry_inner_spacing: 0.42em
  pub_spacing: 0.54em
  publications_line_spacing: 0.33em
  publications_heading_tighten: 0pt
  skill_spacing: 0.54em
  header_rule_top_spacing: 0.36em
  header_bottom_spacing: 0.22em
  contact_separator_spacing: 0.18em
  last_updated_bottom_spacing: 0.18em
styling:
  section_smallcaps: false
  secondary_color: "#111111"
  link_color: "#1C398D"
  section_rule_color: "#9F9FA8"
  section_rule_thickness: 0.6pt
  section_heading_sticky: true
  header_rule_color: "#9F9FA8"
  publications_link_style: "compact"
  publication_title_bold: false
  publication_autobold_authors: true
  publication_bold_author_names: []
  contact_font_size: 0.74em
  summary_font_size: 0.92em
  last_updated_font_size: 0.66em
  last_updated_label: "Last Updated on"
  contact_display_mode: "icon_label"
  contact_icon_spacing: 0.16em
visibility:
  show_location: false
  show_phone: true
  show_interests_summary: false
  show_languages: false
  show_interests: false
  show_references: false
  show_last_updated: true
  enable_links: true
  links_disabled_behavior: "label"
  show_publication_numbers: false
section_titles:
  work: "Experience"
  education: "Education"
  publications: "Publications"
  projects: "Projects"
  awards: "Honors and Activities"
  skills: "Skills"
section_order:
  - work
  - publications
  - education
  - awards
  - skills
`;

    const DEFAULT_BIB = `@article{example2024,
  title={Your Paper Title},
  author={Last, First and Other, Author},
  journal={Conference or Journal Name},
  year={2024},
  url={https://example.com/paper.pdf}
}
`;

    const APP_STORAGE_SCOPE = (() => {
      const path = (window.location.pathname || '/').replace(/\/+$/, '');
      if (!path || path === '/') return 'root';
      const normalized = path
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
      return normalized || 'root';
    })();
    const APP_STORAGE_PREFIX = `resume_compiler__${APP_STORAGE_SCOPE}__`;
    const lsKey = (name) => `${APP_STORAGE_PREFIX}${name}`;

    const CACHE_VERSION = '2026-02-11-ai-subtab-v3';
    const LS_CACHE_VERSION = lsKey('cache_version');
    const LS_RESUME = lsKey('resume_yaml');
    const LS_CONFIG = lsKey('config_yaml');
    const LS_CONFIG_SHORT = lsKey('config_short_yaml');
    const LS_BIB = lsKey('publications_bib');
    const LS_PAPER = lsKey('paper_size');
    const LS_OVERRIDE_MODE_LEGACY = lsKey('override_mode');
    const LS_OVERRIDE_VARIANT = lsKey('override_variant');
    const LS_OVERRIDE_SOURCE = lsKey('override_source');
    const LS_OVERRIDE_LINK_MODE = lsKey('override_link_mode');
    const LS_COMPILE_MODE = lsKey('compile_mode');
    const LS_ACTIVE_TAB = lsKey('active_tab');
    const LS_MOBILE_VIEW = lsKey('mobile_view');
    const LS_EDITOR_HISTORY = lsKey('editor_history_v1');
    const LS_OVERRIDE_LINKS_DISABLED_BEHAVIOR = lsKey('override_links_disabled_behavior');
    const LS_OVERRIDE_PUBNUMS = lsKey('override_pubnums');
    const LS_OVERRIDE_CONTACT = lsKey('override_contact');
    const LS_OVERRIDE_FONT = lsKey('override_font');
    const LS_OVERRIDE_MONO_FONT = lsKey('override_mono_font');
    const LS_EDITOR_PANE_WIDTH = lsKey('editor_pane_width');
    const LS_RESUME_CUSTOMIZED = lsKey('resume_customized');
    const LS_AI_PROVIDER = lsKey('ai_provider');
    const LS_AI_MODEL = lsKey('ai_model');
    const LS_AI_API_KEY = lsKey('ai_api_key');
    const LS_GITHUB_TOKEN = lsKey('github_token');
    const LS_GITHUB_VERIFIED = lsKey('github_verified');
    const LS_AI_WEB_SEARCH = lsKey('ai_web_search');
    const LS_AI_USER_PROMPT = lsKey('ai_user_prompt');
    const LS_AI_JOB_DESCRIPTION = lsKey('ai_job_description');
    const LS_AI_SELECTION_PROMPT = lsKey('ai_selection_prompt');
    const LS_AI_OUTPUT = lsKey('ai_output_yaml');
    const LS_AI_OUTPUT_VIEW = lsKey('ai_output_view');
    const LS_AI_VERIFIED = lsKey('ai_verified');
    const LS_RESUME_VIEW = lsKey('resume_view');
    const LS_RESUME_COMPILE_SOURCE = lsKey('resume_compile_source');
    const LS_REMOTE_UPLOAD_SOURCES = lsKey('remote_upload_sources');
    const LS_RESUME_AI_PANEL_HEIGHT_LEGACY = lsKey('resume_ai_panel_height');
    const LS_PANEL_RESUME_AI_OPEN_LEGACY = lsKey('panel_resume_ai_open');
    const LS_PANEL_OVERRIDES_OPEN = lsKey('panel_overrides_open');
    const LS_PANEL_AI_SETTINGS_OPEN = lsKey('panel_ai_settings_open');
    const LS_PANEL_INTEGRATIONS_OPEN = lsKey('panel_integrations_open');
    const LS_PANEL_AI_JD_OPEN = lsKey('panel_ai_jd_open');
    const URL_STATE_PARAM = 'state';
    const LS_KEYS = [
      LS_CACHE_VERSION,
      LS_RESUME,
      LS_CONFIG,
      LS_CONFIG_SHORT,
      LS_BIB,
      LS_PAPER,
      LS_OVERRIDE_MODE_LEGACY,
      LS_OVERRIDE_VARIANT,
      LS_OVERRIDE_SOURCE,
      LS_OVERRIDE_LINK_MODE,
      LS_COMPILE_MODE,
      LS_ACTIVE_TAB,
      LS_MOBILE_VIEW,
      LS_EDITOR_HISTORY,
      LS_OVERRIDE_LINKS_DISABLED_BEHAVIOR,
      LS_OVERRIDE_PUBNUMS,
      LS_OVERRIDE_CONTACT,
      LS_OVERRIDE_FONT,
      LS_OVERRIDE_MONO_FONT,
      LS_EDITOR_PANE_WIDTH,
      LS_RESUME_CUSTOMIZED,
      LS_AI_PROVIDER,
      LS_AI_MODEL,
      LS_AI_API_KEY,
      LS_GITHUB_TOKEN,
      LS_GITHUB_VERIFIED,
      LS_AI_WEB_SEARCH,
      LS_AI_USER_PROMPT,
      LS_AI_JOB_DESCRIPTION,
      LS_AI_SELECTION_PROMPT,
      LS_AI_OUTPUT,
      LS_AI_OUTPUT_VIEW,
      LS_AI_VERIFIED,
      LS_RESUME_VIEW,
      LS_RESUME_COMPILE_SOURCE,
      LS_REMOTE_UPLOAD_SOURCES,
      LS_RESUME_AI_PANEL_HEIGHT_LEGACY,
      LS_PANEL_RESUME_AI_OPEN_LEGACY,
      LS_PANEL_OVERRIDES_OPEN,
      LS_PANEL_AI_SETTINGS_OPEN,
      LS_PANEL_INTEGRATIONS_OPEN,
      LS_PANEL_AI_JD_OPEN,
    ];
    const EDITOR_CONTENT_KEYS = {
      resume: LS_RESUME,
      config: LS_CONFIG,
      'config-short': LS_CONFIG_SHORT,
      bib: LS_BIB,
    };
    const BIB_SOURCE_ALIASES = [
      '/publications.bib',
      '/default-publications.bib',
      '/web/publications.bib',
      '/web/default-publications.bib',
    ];

    const preview = document.getElementById('preview');
    const mainContainer = document.querySelector('.main-container');
    const paneResizer = document.getElementById('pane-resizer');
    const mobileViewButtons = Array.from(document.querySelectorAll('[data-mobile-view]'));
    const previewPages = document.getElementById('preview-pages');
    const previewFeedbackText = document.getElementById('preview-feedback-text');
    const statusBar = document.getElementById('status-bar');
    const btnDownload = document.getElementById('btn-download');
    const btnDownloadTyp = document.getElementById('btn-download-typ');
    const shareMenu = document.getElementById('share-menu');
    const btnShare = document.getElementById('btn-share');
    const btnShareWithoutKey = document.getElementById('btn-share-without-key');
    const btnShareWithKey = document.getElementById('btn-share-with-key');
    const btnSettings = document.getElementById('btn-settings');
    const btnSettingsClose = document.getElementById('btn-settings-close');
    const settingsFlyout = document.getElementById('settings-flyout');
    const settingsScrim = document.getElementById('settings-scrim');
    const btnUndo = document.getElementById('btn-undo');
    const btnRedo = document.getElementById('btn-redo');
    const btnBibClean = document.getElementById('btn-bib-clean');
    const btnBibDownload = document.getElementById('btn-bib-download');
    const uploadMenu = document.getElementById('upload-menu');
    const btnUpload = document.getElementById('btn-upload');
    const uploadMenuPanel = document.getElementById('upload-menu-panel');
    const btnUploadFile = document.getElementById('btn-upload-file');
    const uploadUrlInput = document.getElementById('upload-url-input');
    const btnUploadUrl = document.getElementById('btn-upload-url');
    const btnUploadRefresh = document.getElementById('btn-upload-refresh');
    const btnUploadGist = document.getElementById('btn-upload-gist');
    const resumeViewToggle = document.getElementById('resume-view-toggle');
    const btnResumeViewOriginal = document.getElementById('btn-resume-view-original');
    const btnResumeViewAi = document.getElementById('btn-resume-view-ai');
    const fileInput = document.getElementById('file-input');
    const btnCompileNow = document.getElementById('btn-compile-now');
    const btnReset = document.getElementById('btn-reset');
    const compileModeHint = document.getElementById('compile-mode-hint');
    const paperSize = document.getElementById('paper-size');
    const compileModeInputs = Array.from(document.querySelectorAll('input[name="compile-mode"]'));
    const overrideVariant = document.getElementById('override-variant');
    const overrideSource = document.getElementById('override-source');
    const overrideLinkMode = document.getElementById('override-link-mode');
    const overrideLinksDisabledBehavior = document.getElementById('override-links-disabled-behavior');
    const overridePubnums = document.getElementById('override-pubnums');
    const overrideContact = document.getElementById('override-contact');
    const overrideFont = document.getElementById('override-font');
    const overrideMonoFont = document.getElementById('override-mono-font');
    const panelOverrides = document.getElementById('panel-overrides');
    const panelAiSettings = document.getElementById('panel-ai-settings');
    const panelIntegrations = document.getElementById('panel-integrations');
    const resumeAiWorkspace = document.getElementById('resume-ai-workspace');
    const aiJdPanel = document.getElementById('ai-jd-panel');
    const resumeAiHeader = document.getElementById('resume-ai-header');
    const resumeAiGate = document.getElementById('resume-ai-gate');
    const resumeAiWorkflow = document.getElementById('resume-ai-workflow');
    const resumeUseGeneratedRow = document.getElementById('resume-use-generated-row');
    const resumeUseGenerated = document.getElementById('resume-use-generated');
    const aiOutputViewInputs = Array.from(document.querySelectorAll('input[name="ai-output-view"]'));
    const aiOutputDiffInput = aiOutputViewInputs.find((input) => input.value === 'diff') || null;
    const aiOutputDiff = document.getElementById('ai-output-diff');
    const aiDiffOverview = document.getElementById('ai-diff-overview');
    const aiOutputContainer = document.getElementById('cm-ai-output-container');
    const aiOutputEditorContainer = document.getElementById('cm-ai-output');
    const aiOutputPlaceholder = document.getElementById('ai-output-placeholder');
    const aiProvider = document.getElementById('ai-provider');
    const aiModel = document.getElementById('ai-model');
    const aiApiKey = document.getElementById('ai-api-key');
    const githubToken = document.getElementById('github-token');
    const btnGithubVerify = document.getElementById('btn-github-verify');
    const githubVerifyStatus = document.getElementById('github-verify-status');
    const aiWebSearch = document.getElementById('ai-web-search');
    const aiSearchItem = document.getElementById('ai-search-item');
    const aiPromptItem = document.getElementById('ai-prompt-item');
    const bibImportPanel = document.getElementById('bib-import-panel');
    const bibImportProvider = document.getElementById('bib-import-provider');
    const bibImportId = document.getElementById('bib-import-id');
    const btnBibImport = document.getElementById('btn-bib-import');
    const btnBibImportReplace = document.getElementById('btn-bib-import-replace');
    const bibImportStatus = document.getElementById('bib-import-status');
    const supportedKeysContent = document.getElementById('supported-keys-content');
    const overlay = document.getElementById('loading-overlay');
    const confirmModal = document.getElementById('confirm-modal');
    const confirmTitle = document.getElementById('confirm-title');
    const confirmMessage = document.getElementById('confirm-message');
    const confirmCancel = document.getElementById('confirm-cancel');
    const confirmAccept = document.getElementById('confirm-accept');
    const aiUserPrompt = document.getElementById('ai-user-prompt');
    const aiJobDescription = document.getElementById('ai-job-description');
    const aiOutputPanel = document.getElementById('ai-output-panel');
    const aiStatus = document.getElementById('ai-status');
    const aiSelectionAnchor = document.getElementById('ai-selection-anchor');
    const aiSelectionPopover = document.getElementById('ai-selection-popover');
    const aiSelectionPrompt = document.getElementById('ai-selection-prompt');
    const btnAiSelectionGenerate = document.getElementById('btn-ai-selection-generate');
    const btnAiSelectionDismiss = document.getElementById('btn-ai-selection-dismiss');
    const aiVerifyStatus = document.getElementById('ai-verify-status');
    const btnOpenAiSettings = document.getElementById('btn-open-ai-settings');
    const btnAiCopy = document.getElementById('btn-ai-copy');
    const btnAiVerify = document.getElementById('btn-ai-verify');

    const AI_PROVIDER_CONFIG = {
      openai: {
        label: 'OpenAI',
        defaultModel: 'gpt-4.1-mini',
      },
      gemini: {
        label: 'Gemini',
        defaultModel: 'gemini-2.0-flash',
      },
      openrouter: {
        label: 'OpenRouter',
        defaultModel: 'openai/gpt-4o-mini',
      },
      groq: {
        label: 'Groq',
        defaultModel: 'llama-3.3-70b-versatile',
      },
      claude: {
        label: 'Claude',
        defaultModel: 'claude-3-7-sonnet-latest',
      },
    };
    const AI_DEFAULT_PROMPT = `Rewrite the provided resume YAML into a stronger, ATS-friendly variant while keeping it truthful and grounded in the original data.

Rules:
- Keep valid YAML output only.
- Preserve top-level schema shape and key names.
- Maintain all factual details unless explicitly reworded for clarity.
- Improve bullet impact with concise action + outcome phrasing.
- Prioritize alignment to the provided job description.
- Keep dates, organizations, and role chronology intact.
- Avoid inventing experience or metrics.
- Return only YAML, no explanations or markdown fences.`;
    const AI_STATUS_DEFAULT_TEXT = 'Set AI provider + key to generate resume variants from Resume YAML.';
    const AI_UNVERIFIED_TAB_MESSAGE = 'AI is not verified yet, so variant generation is locked. Verify settings to generate tailored variants, compare Original vs AI diff, and enable AI output for compile/PDF.';
    const EDITOR_EXTRA_KEYS = {
      'Cmd-Z': () => performEditorUndo(),
      'Ctrl-Z': () => performEditorUndo(),
      'Cmd-Shift-Z': () => performEditorRedo(),
      'Ctrl-Shift-Z': () => performEditorRedo(),
      'Ctrl-Y': () => performEditorRedo(),
    };
    const HAS_COARSE_POINTER = !!(
      window.matchMedia
      && typeof window.matchMedia === 'function'
      && window.matchMedia('(pointer: coarse)').matches
    );
    const IS_TOUCH_DEVICE = !!(
      ('ontouchstart' in window)
      || (navigator.maxTouchPoints > 0)
      || (navigator.msMaxTouchPoints > 0)
      || HAS_COARSE_POINTER
    );
    const EDITOR_INPUT_STYLE = IS_TOUCH_DEVICE ? 'contenteditable' : 'textarea';
    const EDITOR_BASE_OPTIONS = {
      lineNumbers: true,
      tabSize: 2,
      indentWithTabs: false,
      lineWrapping: true,
      viewportMargin: 20,
      extraKeys: EDITOR_EXTRA_KEYS,
      inputStyle: EDITOR_INPUT_STYLE,
    };

    const cmResume = CodeMirror(document.getElementById('cm-resume'), {
      ...EDITOR_BASE_OPTIONS,
      mode: 'yaml',
    });

    const cmConfig = CodeMirror(document.getElementById('cm-config'), {
      ...EDITOR_BASE_OPTIONS,
      mode: 'yaml',
    });

    const cmConfigShort = CodeMirror(document.getElementById('cm-config-short'), {
      ...EDITOR_BASE_OPTIONS,
      mode: 'yaml',
    });

    const cmBib = CodeMirror(document.getElementById('cm-bib'), {
      ...EDITOR_BASE_OPTIONS,
      mode: 'text/x-bibtex',
    });

    const cmAiOutput = CodeMirror(aiOutputEditorContainer, {
      ...EDITOR_BASE_OPTIONS,
      mode: 'yaml',
    });

    const codeMirrorInputObservers = [];
    function wireCodeMirrorInputAccessibility(editor, editorKey) {
      const wrapper = editor && typeof editor.getWrapperElement === 'function'
        ? editor.getWrapperElement()
        : null;
      if (!wrapper) return;

      const applyAttributes = () => {
        const inputs = Array.from(wrapper.querySelectorAll('textarea'));
        inputs.forEach((inputEl, index) => {
          const suffix = index > 0 ? `-${index + 1}` : '';
          if (!inputEl.id) inputEl.id = `cm-${editorKey}-input${suffix}`;
          if (!inputEl.name) inputEl.name = `cm-${editorKey}-input${suffix}`;
          if (!inputEl.getAttribute('aria-label')) {
            inputEl.setAttribute('aria-label', `${editorKey} editor input`);
          }
          if (!inputEl.getAttribute('autocomplete')) {
            inputEl.setAttribute('autocomplete', 'off');
          }
        });
      };

      applyAttributes();
      const observer = new MutationObserver(() => {
        applyAttributes();
      });
      observer.observe(wrapper, { childList: true, subtree: true });
      codeMirrorInputObservers.push(observer);
    }
    wireCodeMirrorInputAccessibility(cmResume, 'resume');
    wireCodeMirrorInputAccessibility(cmConfig, 'config');
    wireCodeMirrorInputAccessibility(cmConfigShort, 'config-short');
    wireCodeMirrorInputAccessibility(cmBib, 'bib');
    wireCodeMirrorInputAccessibility(cmAiOutput, 'ai-output');

    let activeTab = 'resume';
    const editors = { resume: cmResume, config: cmConfig, "config-short": cmConfigShort, bib: cmBib };
    const containers = {
      resume: document.getElementById('cm-resume'),
      config: document.getElementById('cm-config'),
      "config-short": document.getElementById('cm-config-short'),
      bib: document.getElementById('cm-bib'),
    };

    let templateContent = '';
    let compileTimeout = null;
    let ready = false;
    let hasPendingManualChanges = false;
    let compileRequestId = 0;
    let activeCustomSelect = null;
    let pendingConfirmResolve = null;
    let pendingConfirmFocus = null;
    let suppressHistoryTracking = false;
    let historyPersistTimer = null;
    const editorHistoryTimers = {};
    const EDITOR_HISTORY_LIMIT = 25;
    const editorHistories = {};
    const DESKTOP_SPLIT_BREAKPOINT = 1024;
    const DEFAULT_EDITOR_WIDTH = 45;
    const MIN_EDITOR_WIDTH = 28;
    const MAX_EDITOR_WIDTH = 72;
    const GOOGLE_PROXY_PREFIX = 'https://r.jina.ai/http://';
    let bibtexTidyModulePromise = null;
    let aiRequestId = 0;
    let aiInFlight = false;
    let aiVerifyRequestId = 0;
    let aiVerifyInFlight = false;
    let aiSettingsVerified = false;
    let githubVerifyRequestId = 0;
    let githubVerifyInFlight = false;
    let githubTokenVerified = false;
    let suppressAiOutputChangeHandler = false;
    let aiSelectionContext = null;
    let resumeEditorView = 'original';
    let defaultResumeBySource = { resume: DEFAULT_RESUME_YAML, bibtex: DEFAULT_RESUME_YAML };
    let resumeCustomized = false;
    let remoteUploadSources = {};
    let pendingFileUploadTab = null;

    const TAB_SUPPORTED_KEYS_HTML = {
      resume: `
        <div><strong>Top level arrays:</strong> <code>work[]</code>, <code>education[]</code>, <code>skills[]</code>, optional <code>publications[]</code>, <code>projects[]</code>, <code>awards[]</code>, plus custom sections.</div>
        <div><strong><code>personal</code> object:</strong> required <code>name</code>; common optional fields <code>email</code>, <code>phone</code>, <code>url</code>, <code>location</code>, <code>titles[]</code>, <code>summary</code>.</div>
        <div><strong><code>work[]</code> structure:</strong> each entry has org <code>name</code>/<code>url</code> and <code>positions[]</code>; each position supports <code>name</code>, <code>startDate</code>, <code>endDate</code>, <code>location</code>, <code>summary</code>, <code>content[]</code>.</div>
        <div><strong><code>education[]</code> structure:</strong> <code>name</code>, <code>studyType</code>, <code>area</code>, <code>location</code>, <code>startDate</code>, <code>endDate</code>, <code>content[]</code>, <code>honors[]</code>, <code>courses[]</code>, <code>thesis</code>.</div>
        <div><strong><code>skills[]</code> structure:</strong> objects with <code>category</code> and <code>skills[]</code>; keep skill values as plain text strings.</div>
        <div><strong>Publications with BibTeX mode:</strong> use <code>bib_key</code> per publication item. In YAML-only mode, include explicit text fields like <code>title</code>, <code>authors</code>, <code>venue</code>, <code>year</code>, <code>url</code>.</div>
        <div><strong>Dates:</strong> preferred ISO-like values (<code>YYYY-MM-DD</code> or <code>YYYY-MM</code>) and <code>present</code> for ongoing roles.</div>
      `,
      config: `
        <div><strong>Main groups:</strong> <code>variant</code>, <code>paper_size</code>, <code>fonts</code>, <code>layout</code>, <code>styling</code>, <code>visibility</code>, <code>section_titles</code>, <code>section_order[]</code>.</div>
        <div><strong><code>fonts.*</code> keys:</strong> <code>font</code>, <code>mono_font</code>, <code>font_size</code>, <code>name_font_size</code>, <code>section_font_size</code>, plus section-specific size overrides.</div>
        <div><strong><code>layout.*</code> keys:</strong> <code>margin</code>, <code>line_spacing</code>, <code>entry_spacing</code>, <code>entry_inner_spacing</code>, <code>section_spacing</code>, <code>pub_spacing</code>, header spacing controls.</div>
        <div><strong><code>styling.*</code> keys:</strong> colors, heading behavior, publication emphasis, and <code>contact_display_mode</code> (<code>icon_label</code> or <code>label</code>).</div>
        <div><strong><code>visibility.*</code> keys:</strong> section toggles, link toggles, <code>links_disabled_behavior</code> (<code>label</code> or <code>label_with_url</code>), and publication numbering.</div>
        <div><strong><code>section_order[]</code>:</strong> ordered list of section ids (for example <code>work</code>, <code>publications</code>, <code>education</code>, <code>projects</code>, <code>skills</code>).</div>
      `,
      'config-short': `
        <div><strong>Same schema as config.yml:</strong> every key supported in <code>config</code> also works here.</div>
        <div><strong>Typical short edits:</strong> reduce <code>fonts.*</code> sizes, tighten <code>layout.*</code> spacing, and shorten <code>section_order[]</code>.</div>
        <div><strong>Variant selection:</strong> Length override controls whether <code>config.yml</code> or <code>config-short.yml</code> is used at compile time.</div>
      `,
      bib: `
        <div><strong>Supported entry types:</strong> <code>@article</code>, <code>@inproceedings</code>, <code>@book</code>, <code>@misc</code>, and other standard BibTeX types.</div>
        <div><strong>Recommended fields:</strong> citation key, <code>title</code>, <code>author</code>, <code>year</code>, and venue field (<code>journal</code> or <code>booktitle</code>), plus <code>url</code>/<code>doi</code> when available.</div>
        <div><strong>Import tools:</strong> DBLP / Semantic Scholar / Google Scholar IDs can merge into current entries or replace all entries.</div>
        <div><strong>Cleanup:</strong> <code>Clean .bib</code> normalizes formatting and helps detect duplicates by key/title.</div>
      `,
    };
    const BIB_IMPORT_PLACEHOLDERS = {
      dblp: 'Example: j/Geffner:Blai or https://dblp.org/pid/j/Geffner:Blai.html',
      semantic: 'Example: 1741102 or https://www.semanticscholar.org/author/.../1741102',
      google: 'Example: cLzCYMIAAAAJ or https://scholar.google.com/citations?user=cLzCYMIAAAAJ',
    };
    const GIST_DEFAULT_FILE_BY_TAB = {
      resume: 'resume.yml',
      config: 'config.yml',
      'config-short': 'config-short.yml',
      bib: 'publications.bib',
    };
    function supportsPopoverOpenSelector() {
      if (!window.CSS || typeof window.CSS.supports !== 'function') return false;
      try {
        return window.CSS.supports('selector(:popover-open)');
      } catch (_err) {
        return false;
      }
    }
    const SUPPORTS_POPOVER_API = !!(
      aiSelectionPopover
      && typeof aiSelectionPopover.showPopover === 'function'
      && typeof aiSelectionPopover.hidePopover === 'function'
    );
    const USE_NATIVE_POPOVER = SUPPORTS_POPOVER_API && supportsPopoverOpenSelector();
    const SUPPORTS_ANCHOR_POSITIONING = !!(
      window.CSS
      && typeof window.CSS.supports === 'function'
      && window.CSS.supports('position-anchor: --ai-selection-anchor')
      && (
        window.CSS.supports('position-area: bottom center')
        || window.CSS.supports('position-area: block-end center')
      )
    );

    function setStatus(text, level) {
      statusBar.textContent = text;
      statusBar.className = 'status-bar' + (level ? ' ' + level : '');
    }

    function setBibImportStatus(text, level = '') {
      bibImportStatus.textContent = text;
      bibImportStatus.classList.toggle('warning', level === 'warning');
    }

    function setAiStatus(text, level = '') {
      aiStatus.textContent = text;
      aiStatus.className = 'ai-status' + (level ? ` ${level}` : '');
      updateAiStatusVisibility();
    }

    function setAiVerifyStatus(text, level = '') {
      aiVerifyStatus.textContent = text;
      aiVerifyStatus.className = 'ai-verify-status' + (level ? ` ${level}` : '');
    }

    function setGithubVerifyStatus(text, level = '') {
      githubVerifyStatus.textContent = text;
      githubVerifyStatus.className = 'ai-verify-status' + (level ? ` ${level}` : '');
    }

    function updateAiStatusVisibility() {
      const text = String(aiStatus.textContent || '').trim();
      const shouldHide = !text || (isAiSettingsVerified() && text === AI_STATUS_DEFAULT_TEXT);
      aiStatus.classList.toggle('hidden', shouldHide);
    }

    function isAiSettingsVerified() {
      return !!aiSettingsVerified;
    }

    function setAiSettingsVerified(nextValue, options = {}) {
      const shouldPersist = options.persist !== false;
      aiSettingsVerified = !!nextValue;
      if (shouldPersist) {
        localStorage.setItem(LS_AI_VERIFIED, aiSettingsVerified ? '1' : '0');
      }
      updateAiVerificationVisibility();
    }

    function getAiProvider() {
      return normalizeAiProviderValue(aiProvider.value);
    }

    function getAiModelValue() {
      return String(aiModel.value || '').trim();
    }

    function getAiApiKeyValue() {
      return String(aiApiKey.value || '').trim();
    }

    function getGithubTokenValue() {
      return String(githubToken.value || '').trim();
    }

    function isGithubTokenVerified() {
      return !!githubTokenVerified && !!getGithubTokenValue();
    }

    function setGithubTokenVerified(nextValue, options = {}) {
      const shouldPersist = options.persist !== false;
      githubTokenVerified = !!nextValue && !!getGithubTokenValue();
      if (shouldPersist) {
        localStorage.setItem(LS_GITHUB_VERIFIED, githubTokenVerified ? '1' : '0');
      }
      if (githubTokenVerified) {
        setGithubVerifyStatus('GitHub token verified.', 'success');
      } else {
        setGithubVerifyStatus('Not verified.');
      }
      updateShareMenuVisibility();
      updateUploadGistButtonState();
    }

    function getAiOutputValue() {
      return String(cmAiOutput.getValue() || '');
    }

    function hasGeneratedAiOutput() {
      return !!String(getAiOutputValue() || '').trim();
    }

    function setAiOutputValue(value, options = {}) {
      const useSilentChange = options.silentChange === true;
      suppressAiOutputChangeHandler = useSilentChange;
      try {
        cmAiOutput.setValue(String(value || ''));
      } finally {
        suppressAiOutputChangeHandler = false;
      }
      renderAiDiffView();
      updateAiActionButtons();
    }

    function getAiWorkingYaml() {
      const currentOutput = String(getAiOutputValue() || '');
      if (currentOutput.trim()) return currentOutput;
      return cmResume.getValue();
    }

    function ensureAiOutputSeededFromOriginal(options = {}) {
      const hasOutput = !!String(getAiOutputValue() || '').trim();
      if (hasOutput) return false;
      setAiOutputValue(cmResume.getValue(), { silentChange: true });
      if (options.persist !== false) {
        persistPreferences();
      }
      return true;
    }

    function getDomSelectionRectWithin(rootEl) {
      if (!rootEl || !window.getSelection) return null;
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0 || selection.isCollapsed) return null;
      const range = selection.getRangeAt(0);
      const container = range.commonAncestorContainer;
      const containerEl = container && container.nodeType === Node.ELEMENT_NODE
        ? container
        : container && container.parentElement
          ? container.parentElement
          : null;
      if (!containerEl || !rootEl.contains(containerEl)) return null;
      let rect = range.getBoundingClientRect();
      if (rect && (rect.width > 0 || rect.height > 0)) {
        return {
          left: rect.left,
          top: rect.top,
          right: rect.right,
          bottom: rect.bottom,
          width: rect.width || (rect.right - rect.left),
          height: rect.height || (rect.bottom - rect.top),
        };
      }
      const rects = Array.from(range.getClientRects ? range.getClientRects() : []);
      if (!rects.length) return null;
      const left = Math.min(...rects.map((item) => item.left));
      const top = Math.min(...rects.map((item) => item.top));
      const right = Math.max(...rects.map((item) => item.right));
      const bottom = Math.max(...rects.map((item) => item.bottom));
      return {
        left,
        top,
        right,
        bottom,
        width: Math.max(1, right - left),
        height: Math.max(1, bottom - top),
      };
    }

    function getAiSelectionFromVariantView(workingYaml) {
      const doc = cmAiOutput.getDoc();
      const ranges = doc.listSelections();
      for (const range of ranges) {
        const fromPos = range.from();
        const toPos = range.to();
        const start = doc.indexFromPos(fromPos);
        const end = doc.indexFromPos(toPos);
        if (start === end) continue;
        const selectedText = doc.getRange(fromPos, toPos);
        if (!String(selectedText || '').trim()) continue;
        const wrapperEl = cmAiOutput.getWrapperElement();
        const startCoords = cmAiOutput.cursorCoords(fromPos, 'window');
        const endCoords = cmAiOutput.cursorCoords(toPos, 'window');
        const fallbackRect = {
          left: Math.min(startCoords.left, endCoords.left),
          top: Math.min(startCoords.top, endCoords.top),
          right: Math.max(startCoords.right || startCoords.left, endCoords.right || endCoords.left),
          bottom: Math.max(startCoords.bottom || startCoords.top, endCoords.bottom || endCoords.top),
        };
        fallbackRect.width = Math.max(1, fallbackRect.right - fallbackRect.left);
        fallbackRect.height = Math.max(1, fallbackRect.bottom - fallbackRect.top);
        const rect = getDomSelectionRectWithin(wrapperEl) || fallbackRect;
        return {
          source: 'variant',
          selectedText,
          start,
          end,
          fromPos,
          toPos,
          rect,
          workingYaml,
        };
      }
      return null;
    }

    function getAiSelectionContext() {
      if (getAiOutputViewMode() !== 'variant') return null;
      return getAiSelectionFromVariantView(getAiWorkingYaml());
    }

    function isAiSelectionPopoverOpen() {
      if (!aiSelectionPopover) return false;
      if (USE_NATIVE_POPOVER && typeof aiSelectionPopover.matches === 'function') {
        try {
          return aiSelectionPopover.matches(':popover-open');
        } catch (_err) {
          // Fall through to class-based visibility.
        }
      }
      return !aiSelectionPopover.classList.contains('hidden');
    }

    function showAiSelectionPopover() {
      if (!aiSelectionPopover) return;
      aiSelectionPopover.classList.remove('hidden');
      if (USE_NATIVE_POPOVER && !isAiSelectionPopoverOpen()) {
        try {
          aiSelectionPopover.showPopover();
        } catch (_err) {
          // Fall back to class-based visibility if popover API throws.
        }
      }
    }

    function hideAiSelectionPopover() {
      if (aiSelectionPopover) {
        if (USE_NATIVE_POPOVER && isAiSelectionPopoverOpen()) {
          try {
            aiSelectionPopover.hidePopover();
          } catch (_err) {
            // Ignore and continue with class-based hiding.
          }
        }
        aiSelectionPopover.classList.add('hidden');
      }
      if (aiSelectionAnchor) aiSelectionAnchor.classList.add('hidden');
      aiSelectionContext = null;
    }

    function clampToViewport(value, min, max) {
      if (!Number.isFinite(value)) return min;
      if (!Number.isFinite(min) || !Number.isFinite(max)) return value;
      return Math.max(min, Math.min(max, value));
    }

    function placeAiSelectionPopover(rect) {
      if (!rect || !aiSelectionPopover || !aiSelectionAnchor) return;
      const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      const scrollX = window.scrollX || window.pageXOffset || 0;
      const scrollY = window.scrollY || window.pageYOffset || 0;

      let anchorLeft = Number.isFinite(rect.left) ? rect.left : 0;
      let anchorTop = Number.isFinite(rect.top) ? rect.top : 0;
      let anchorRight = Number.isFinite(rect.right) ? rect.right : anchorLeft + (Number.isFinite(rect.width) ? rect.width : 1);
      let anchorBottom = Number.isFinite(rect.bottom) ? rect.bottom : anchorTop + (Number.isFinite(rect.height) ? rect.height : 1);
      const seemsPageRelative = (
        anchorTop > (vh + 4)
        || anchorBottom > (vh + 4)
        || anchorLeft > (vw + 4)
        || anchorRight > (vw + 4)
      ) && (scrollX !== 0 || scrollY !== 0);
      if (seemsPageRelative) {
        anchorLeft -= scrollX;
        anchorRight -= scrollX;
        anchorTop -= scrollY;
        anchorBottom -= scrollY;
      }
      const anchorWidth = Math.max(1, Number.isFinite(rect.width) ? rect.width : (anchorRight - anchorLeft));
      const anchorHeight = Math.max(1, Number.isFinite(rect.height) ? rect.height : (anchorBottom - anchorTop));

      aiSelectionAnchor.style.left = `${anchorLeft}px`;
      aiSelectionAnchor.style.top = `${anchorTop}px`;
      aiSelectionAnchor.style.width = `${anchorWidth}px`;
      aiSelectionAnchor.style.height = `${anchorHeight}px`;
      aiSelectionAnchor.classList.remove('hidden');

      if (SUPPORTS_ANCHOR_POSITIONING && vw >= 768) {
        aiSelectionPopover.style.left = '';
        aiSelectionPopover.style.top = '';
        return;
      }

      const viewportPadding = 8;
      const gap = 8;
      aiSelectionPopover.style.maxWidth = `${Math.max(220, vw - (viewportPadding * 2))}px`;
      const popRect = aiSelectionPopover.getBoundingClientRect();
      const centeredLeft = anchorLeft + (anchorWidth / 2) - (popRect.width / 2);
      const left = clampToViewport(centeredLeft, viewportPadding, Math.max(viewportPadding, vw - popRect.width - viewportPadding));

      const belowTop = anchorTop + anchorHeight + gap;
      const aboveTop = anchorTop - popRect.height - gap;
      const top = (belowTop + popRect.height <= vh - viewportPadding)
        ? belowTop
        : clampToViewport(aboveTop, viewportPadding, Math.max(viewportPadding, vh - popRect.height - viewportPadding));

      aiSelectionPopover.style.left = `${left}px`;
      aiSelectionPopover.style.top = `${top}px`;
    }

    function syncAiSelectionPopover(options = {}) {
      const aiViewActive = activeTab === 'resume' && getResumeEditorView() === 'ai';
      const verified = isAiSettingsVerified();
      const canSelectInView = getAiOutputViewMode() === 'variant' && hasGeneratedAiOutput();
      if (!aiViewActive || !verified || !canSelectInView || aiInFlight || aiVerifyInFlight) {
        hideAiSelectionPopover();
        return;
      }

      const context = options.context || getAiSelectionContext();
      if (!context || !context.rect) {
        hideAiSelectionPopover();
        return;
      }

      aiSelectionContext = context;
      if (btnAiSelectionGenerate) btnAiSelectionGenerate.disabled = false;
      showAiSelectionPopover();
      placeAiSelectionPopover(context.rect);
    }

    function getAiOutputViewMode() {
      const selected = aiOutputViewInputs.find((input) => input.checked);
      return selected && selected.value === 'diff' ? 'diff' : 'variant';
    }

    function updateAiOutputViewAvailability() {
      const hasOutput = hasGeneratedAiOutput();
      if (aiOutputDiffInput) {
        aiOutputDiffInput.disabled = !hasOutput;
      }
      if (!hasOutput && getAiOutputViewMode() === 'diff') {
        setAiOutputViewMode('variant', { persist: false });
      }
    }

    function updateAiOutputPanelVisibility() {
      const hasOutput = hasGeneratedAiOutput() && isAiSettingsVerified();
      aiOutputPanel.classList.toggle('hidden', !hasOutput);
      if (!hasOutput) {
        aiOutputDiff.textContent = '';
      }
      updateResumeEditorSurface();
    }

    function updateAiVerificationVisibility() {
      const verified = isAiSettingsVerified();
      if (resumeAiHeader) resumeAiHeader.classList.toggle('hidden', !verified);
      if (resumeAiGate) resumeAiGate.classList.toggle('hidden', verified);
      if (resumeAiWorkflow) resumeAiWorkflow.classList.toggle('hidden', !verified);
      if (aiSearchItem) aiSearchItem.classList.toggle('hidden', !verified);
      if (aiPromptItem) aiPromptItem.classList.toggle('hidden', !verified);
      if (verified) {
        ensureAiOutputSeededFromOriginal({ persist: false });
      }
      if (!verified) {
        setResumeCompileSource('original', { persist: false, triggerCompile: true });
        setAiOutputViewMode('variant', { persist: false });
        hideAiSelectionPopover();
      }
      updateAiStatusVisibility();
      updateAiOutputPanelVisibility();
      updateResumeEditorSurface();
    }

    function setAiOutputViewMode(mode, options = {}) {
      const normalized = mode === 'diff' && hasGeneratedAiOutput() ? 'diff' : 'variant';
      aiOutputViewInputs.forEach((input) => {
        input.checked = input.value === normalized;
      });
      updateResumeEditorSurface();
      if (normalized === 'variant' && hasGeneratedAiOutput()) cmAiOutput.refresh();
      if (options.persist !== false) {
        persistPreferences();
      }
    }

    function scrollAiDiffToLine(startLine, options = {}) {
      if (!aiOutputDiff) return;
      const numericLine = Number(startLine);
      if (!Number.isFinite(numericLine) || numericLine < 0) return;
      const lineElements = aiOutputDiff.querySelectorAll('.diff-line');
      if (!lineElements.length) return;
      const clampedIndex = Math.max(0, Math.min(lineElements.length - 1, Math.floor(numericLine)));
      const targetLine = lineElements[clampedIndex];
      if (!targetLine) return;
      const offset = Math.max(0, Math.round(aiOutputDiff.clientHeight * 0.18));
      const nextTop = Math.max(0, targetLine.offsetTop - offset);
      aiOutputDiff.scrollTo({
        top: nextTop,
        behavior: options.behavior === 'smooth' ? 'smooth' : 'auto',
      });
    }

    function renderAiDiffView() {
      const original = String(cmResume.getValue() || '');
      const generated = String(getAiOutputValue() || '');
      if (!generated.trim()) {
        aiOutputDiff.textContent = '';
        if (aiDiffOverview) aiDiffOverview.innerHTML = '';
        return;
      }
      if (generated === original) {
        aiOutputDiff.textContent = generated;
        if (aiDiffOverview) aiDiffOverview.innerHTML = '';
        return;
      }
      if (window.Diff && typeof window.Diff.diffLines === 'function') {
        const pieces = window.Diff.diffLines(original, generated);
        const lines = [];
        const overviewMarkers = [];
        let lineCursor = 0;
        pieces.forEach((piece) => {
          const cls = piece.added
            ? 'diff-add'
            : piece.removed
              ? 'diff-del'
              : 'diff-same';
          const prefix = piece.added ? '+' : (piece.removed ? '-' : ' ');
          const rawLines = splitYamlLines(piece.value);
          const startLine = lineCursor;
          rawLines.forEach((line, index) => {
            if (index === rawLines.length - 1 && line === '') return;
            lines.push({
              cls,
              text: `${prefix}${line}`,
            });
            lineCursor += 1;
          });
          if ((piece.added || piece.removed) && lineCursor > startLine) {
            overviewMarkers.push({
              type: piece.added ? 'add' : 'del',
              startLine,
              endLine: lineCursor - 1,
            });
          }
        });
        aiOutputDiff.innerHTML = lines.map(({ cls, text }) => {
          const escaped = text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          return `<span class="diff-line ${cls}">${escaped}</span>`;
        }).join('');
        if (aiDiffOverview) {
          const totalLines = Math.max(1, lines.length);
          aiDiffOverview.innerHTML = overviewMarkers.map((marker) => {
            const top = (marker.startLine / totalLines) * 100;
            const ratio = ((marker.endLine - marker.startLine + 1) / totalLines) * 100;
            const height = Math.max(0.5, ratio);
            return `<span class="ai-diff-overview-marker ${marker.type}" data-start-line="${marker.startLine}" style="top:${top.toFixed(4)}%;height:${height.toFixed(4)}%"></span>`;
          }).join('');
        }
        return;
      }
      aiOutputDiff.textContent = generated;
      if (aiDiffOverview) aiDiffOverview.innerHTML = '';
    }

    function setDetailsOpen(detailsEl, shouldOpen) {
      if (!detailsEl) return;
      detailsEl.open = !!shouldOpen;
    }

    function readStoredOpenState(storageKey, fallbackOpen) {
      const stored = localStorage.getItem(storageKey);
      if (stored === '1') return true;
      if (stored === '0') return false;
      return !!fallbackOpen;
    }

    function normalizeResumeCompileSource(value) {
      return value === 'generated' ? 'generated' : 'original';
    }

    function getResumeCompileSource() {
      return normalizeResumeCompileSource(resumeUseGenerated && resumeUseGenerated.checked ? 'generated' : 'original');
    }

    function setResumeCompileSource(value, options = {}) {
      const normalized = normalizeResumeCompileSource(value);
      const shouldUseGenerated = normalized === 'generated';
      if (resumeUseGenerated) resumeUseGenerated.checked = shouldUseGenerated;
      if (options.persist !== false) {
        persistPreferences();
      }
      if (options.triggerCompile === true) {
        compileAfterResumeSourceToggle();
      }
    }

    function getResumeContentForCompile() {
      const generated = String(getAiOutputValue() || '').trim();
      if (getResumeCompileSource() === 'generated' && generated) {
        return generated;
      }
      return cmResume.getValue();
    }

    function ensureValidResumeCompileSource(options = {}) {
      const hasOutput = !!String(getAiOutputValue() || '').trim();
      if (!hasOutput && getResumeCompileSource() === 'generated') {
        setResumeCompileSource('original', { persist: false });
        if (options.triggerCompile === true) {
          compileAfterResumeSourceToggle();
        }
        return true;
      }
      return false;
    }

    function setSettingsFlyoutOpen(nextOpen) {
      const shouldOpen = !!nextOpen;
      settingsFlyout.classList.toggle('open', shouldOpen);
      settingsFlyout.setAttribute('aria-hidden', shouldOpen ? 'false' : 'true');
      settingsScrim.classList.toggle('open', shouldOpen);
      btnSettings.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    }

    function hasShareableAiKey() {
      return !!getAiApiKeyValue();
    }

    function hasShareableGithubKey() {
      return !!getGithubTokenValue();
    }

    function hasAnyShareableKey() {
      return hasShareableAiKey() || hasShareableGithubKey();
    }

    function getShareWithKeyLabel() {
      const hasAi = hasShareableAiKey();
      const hasGithub = hasShareableGithubKey();
      if (hasAi && hasGithub) return 'Copy URL (With AI + GitHub Keys)';
      if (hasAi) return 'Copy URL (With AI Key)';
      if (hasGithub) return 'Copy URL (With GitHub Key)';
      return 'Copy URL (With Keys)';
    }

    function updateShareMenuVisibility() {
      const hasKey = hasAnyShareableKey();
      btnShareWithKey.classList.toggle('hidden', !hasKey);
      btnShareWithKey.textContent = getShareWithKeyLabel();
      btnShareWithoutKey.textContent = hasKey ? 'Copy URL (Without Keys)' : 'Copy URL';
      btnShare.setAttribute('aria-haspopup', hasKey ? 'menu' : 'false');
      if (!hasKey) closeShareMenu();
    }

    function setShareMenuOpen(nextOpen) {
      const shouldOpen = !!nextOpen;
      if (shouldOpen && !hasAnyShareableKey()) {
        shareMenu.classList.remove('open');
        btnShare.setAttribute('aria-expanded', 'false');
        return;
      }
      shareMenu.classList.toggle('open', shouldOpen);
      btnShare.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    }

    function closeShareMenu() {
      setShareMenuOpen(false);
    }

    async function copyShareFromMenu(includeAnyKey) {
      const includeKeys = includeAnyKey === true && hasAnyShareableKey();
      const controls = [btnShare, btnShareWithoutKey, btnShareWithKey];
      controls.forEach((control) => {
        control.disabled = true;
      });
      try {
        await copyShareUrlToClipboard({ includeKeys });
        if (includeKeys) {
          const included = [];
          if (hasShareableAiKey()) included.push('AI');
          if (hasShareableGithubKey()) included.push('GitHub');
          const labels = included.length > 0 ? included.join(' + ') : 'available';
          setStatus(`Share URL copied (with ${labels} key${included.length === 1 ? '' : 's'}).`, 'ready');
        } else if (hasAnyShareableKey()) {
          setStatus('Share URL copied (without keys; all other state included).', 'ready');
        } else {
          setStatus('Share URL copied.', 'ready');
        }
      } catch (err) {
        setStatus('Share URL copy failed: ' + (err.message || err), 'error');
      } finally {
        controls.forEach((control) => {
          control.disabled = false;
        });
        closeShareMenu();
      }
    }

    function normalizeEditorKey(value) {
      if (value === 'resume' || value === 'config' || value === 'config-short' || value === 'bib') return value;
      return '';
    }

    function getEditorLabel(editorKey = activeTab) {
      const key = normalizeEditorKey(editorKey);
      if (key === 'resume') return 'Resume (YAML)';
      if (key === 'config') return 'Config (YAML)';
      if (key === 'config-short') return 'Config Short (YAML)';
      if (key === 'bib') return 'Publications (BibTeX)';
      return 'current tab';
    }

    function isLikelyGistId(value) {
      return /^[a-f0-9]{6,}$/i.test(String(value || '').trim());
    }

    function isLikelyGitSha(value) {
      return /^[a-f0-9]{20,}$/i.test(String(value || '').trim());
    }

    function parseGistSource(rawUrl) {
      const value = String(rawUrl || '').trim();
      if (!value) return null;
      let parsed = null;
      try {
        parsed = new URL(value);
      } catch (err) {
        return null;
      }

      const host = parsed.hostname.toLowerCase();
      const segments = parsed.pathname.split('/').filter(Boolean);
      let gistId = '';
      let fileName = '';

      if (host === 'gist.github.com') {
        if (segments.length >= 2 && isLikelyGistId(segments[1])) {
          gistId = segments[1];
        }
        const queryFile = String(parsed.searchParams.get('file') || '').trim();
        if (queryFile) fileName = decodeURIComponent(queryFile);
        if (!fileName) {
          const hash = String(parsed.hash || '').replace(/^#/, '').trim();
          const hashMatch = hash.match(/^file-(.+)$/i);
          if (hashMatch) {
            fileName = decodeURIComponent(hashMatch[1]).replace(/-/g, '.');
          }
        }
      } else if (host === 'gist.githubusercontent.com') {
        if (segments.length >= 2 && isLikelyGistId(segments[1])) {
          gistId = segments[1];
        }
        const rawIndex = segments.indexOf('raw');
        if (rawIndex >= 0) {
          if (segments.length >= rawIndex + 3) {
            fileName = decodeURIComponent(segments.slice(rawIndex + 2).join('/'));
          } else if (segments.length === rawIndex + 2) {
            const maybeFile = decodeURIComponent(String(segments[rawIndex + 1] || ''));
            if (maybeFile && !isLikelyGitSha(maybeFile)) fileName = maybeFile;
          }
        }
      } else if (host === 'api.github.com') {
        if (segments[0] === 'gists' && isLikelyGistId(segments[1])) {
          gistId = segments[1];
        }
      }

      if (!gistId) return null;
      return {
        gistId,
        fileName: String(fileName || '').replace(/^\/+/, ''),
        apiUrl: `https://api.github.com/gists/${gistId}`,
      };
    }

    function encodeGithubPath(pathValue) {
      return String(pathValue || '')
        .split('/')
        .filter((segment) => segment.length > 0)
        .map((segment) => encodeURIComponent(segment))
        .join('/');
    }

    function parseGithubRepoFileSource(rawUrl) {
      const value = String(rawUrl || '').trim();
      if (!value) return null;
      let parsed = null;
      try {
        parsed = new URL(value);
      } catch (err) {
        return null;
      }

      const host = parsed.hostname.toLowerCase();
      const segments = parsed.pathname.split('/').filter(Boolean);
      let owner = '';
      let repo = '';
      let ref = '';
      let filePath = '';

      if (host === 'github.com') {
        if (segments.length >= 5 && segments[2] === 'blob') {
          owner = segments[0];
          repo = segments[1];
          ref = decodeURIComponent(segments[3] || '');
          filePath = decodeURIComponent(segments.slice(4).join('/'));
        } else {
          return null;
        }
      } else if (host === 'raw.githubusercontent.com') {
        if (segments.length >= 4) {
          owner = segments[0];
          repo = segments[1];
          ref = decodeURIComponent(segments[2] || '');
          filePath = decodeURIComponent(segments.slice(3).join('/'));
        } else {
          return null;
        }
      } else if (host === 'api.github.com') {
        if (segments.length >= 5 && segments[0] === 'repos' && segments[3] === 'contents') {
          owner = decodeURIComponent(segments[1] || '');
          repo = decodeURIComponent(segments[2] || '');
          filePath = decodeURIComponent(segments.slice(4).join('/'));
          ref = decodeURIComponent(parsed.searchParams.get('ref') || '');
        } else {
          return null;
        }
      } else {
        return null;
      }

      if (!owner || !repo || !filePath) return null;
      return {
        owner,
        repo,
        ref,
        filePath,
        apiUrl: `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeGithubPath(filePath)}`,
      };
    }

    function resolveGistFileName(filesMap, source, editorKey) {
      const files = filesMap && typeof filesMap === 'object' ? filesMap : {};
      const names = Object.keys(files);
      if (!names.length) {
        throw new Error('This gist has no files.');
      }

      const sourceFile = String(source?.fileName || '').trim();
      if (sourceFile) {
        if (Object.prototype.hasOwnProperty.call(files, sourceFile)) return sourceFile;
        const caseMatch = names.find((name) => name.toLowerCase() === sourceFile.toLowerCase());
        if (caseMatch) return caseMatch;
        throw new Error(`Gist file "${sourceFile}" was not found.`);
      }

      const preferred = GIST_DEFAULT_FILE_BY_TAB[editorKey];
      if (preferred) {
        const preferredMatch = names.find((name) => name.toLowerCase() === preferred.toLowerCase());
        if (preferredMatch) return preferredMatch;
      }

      if (names.length === 1) return names[0];

      if (editorKey === 'bib') {
        const bibMatches = names.filter((name) => /\.bib$/i.test(name));
        if (bibMatches.length === 1) return bibMatches[0];
      } else {
        const yamlMatches = names.filter((name) => /\.(yml|yaml)$/i.test(name));
        if (yamlMatches.length === 1) return yamlMatches[0];
      }

      throw new Error('Gist has multiple files. Use a raw gist file URL or append ?file=<name>.');
    }

    async function extractGithubErrorMessage(response) {
      try {
        const payload = await response.json();
        if (payload && typeof payload.message === 'string' && payload.message.trim()) {
          return payload.message.trim();
        }
      } catch (err) {
        // ignore parse failures; fallback to status text
      }
      return response.statusText || '';
    }

    function getGithubHeaders(token = '', includeJsonContentType = false) {
      const headers = {
        Accept: 'application/vnd.github+json',
      };
      const normalizedToken = String(token || '').trim();
      if (normalizedToken) {
        headers.Authorization = `Bearer ${normalizedToken}`;
      }
      if (includeJsonContentType) {
        headers['Content-Type'] = 'application/json';
      }
      return headers;
    }

    async function fetchGistData(source, token = '') {
      const response = await fetch(source.apiUrl, {
        headers: getGithubHeaders(token, false),
        cache: 'no-store',
      });
      if (!response.ok) {
        const detail = await extractGithubErrorMessage(response);
        const error = new Error(detail ? `GitHub gist read failed: ${detail}` : `GitHub gist read failed (${response.status}).`);
        error.githubStatus = response.status;
        throw error;
      }
      const payload = await response.json();
      if (!payload || typeof payload !== 'object' || !payload.files || typeof payload.files !== 'object') {
        throw new Error('Unexpected GitHub gist response.');
      }
      return payload;
    }

    function decodeBase64ToText(base64Value) {
      const normalized = String(base64Value || '').replace(/\s+/g, '');
      if (!normalized) return '';
      const binary = atob(normalized);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new TextDecoder().decode(bytes);
    }

    async function fetchGithubRepoFileText(source, token = '') {
      const apiUrl = new URL(source.apiUrl);
      if (source.ref) {
        apiUrl.searchParams.set('ref', source.ref);
      }

      const response = await fetch(apiUrl.toString(), {
        headers: getGithubHeaders(token, false),
        cache: 'no-store',
      });
      if (!response.ok) {
        const detail = await extractGithubErrorMessage(response);
        const error = new Error(detail ? `GitHub file read failed: ${detail}` : `GitHub file read failed (${response.status}).`);
        error.githubStatus = response.status;
        throw error;
      }

      const payload = await response.json();
      if (!payload || typeof payload !== 'object') {
        throw new Error('Unexpected GitHub file response.');
      }
      if (payload.type !== 'file') {
        throw new Error('GitHub URL does not point to a file.');
      }
      if (typeof payload.content === 'string' && payload.encoding === 'base64') {
        return decodeBase64ToText(payload.content);
      }
      if (typeof payload.content === 'string') {
        return payload.content;
      }
      if (typeof payload.download_url === 'string' && payload.download_url) {
        const rawResponse = await fetch(payload.download_url, {
          headers: getGithubHeaders(token, false),
          cache: 'no-store',
        });
        if (!rawResponse.ok) {
          throw new Error(`GitHub raw file fetch failed (${rawResponse.status}).`);
        }
        return await rawResponse.text();
      }
      throw new Error('GitHub file response is missing content.');
    }

    async function verifyGithubToken() {
      const token = getGithubTokenValue();
      if (!token) {
        setGithubTokenVerified(false, { persist: false });
        setGithubVerifyStatus('Set a GitHub token first.', 'error');
        setStatus('GitHub token verification failed: missing token.', 'error');
        persistPreferences();
        return false;
      }

      const requestId = ++githubVerifyRequestId;
      githubVerifyInFlight = true;
      if (btnGithubVerify) btnGithubVerify.disabled = true;
      setGithubVerifyStatus('Verifying token...');
      updateUploadGistButtonState();

      try {
        const response = await fetch('https://api.github.com/user', {
          headers: getGithubHeaders(token, false),
          cache: 'no-store',
        });
        if (!response.ok) {
          const detail = await extractGithubErrorMessage(response);
          throw new Error(detail || `HTTP ${response.status}`);
        }
        const payload = await response.json();
        if (requestId !== githubVerifyRequestId) return false;
        const login = payload && typeof payload.login === 'string' ? payload.login : '';
        setGithubTokenVerified(true, { persist: false });
        setGithubVerifyStatus(login ? `Verified for @${login}.` : 'GitHub token verified.', 'success');
        setStatus(login ? `GitHub token verified (@${login}). Private GitHub URLs enabled.` : 'GitHub token verified. Private GitHub URLs enabled.', 'ready');
        persistPreferences();
        return true;
      } catch (err) {
        if (requestId !== githubVerifyRequestId) return false;
        setGithubTokenVerified(false, { persist: false });
        setGithubVerifyStatus('Verification failed.', 'error');
        setStatus(`GitHub token verification failed: ${err.message || err}`, 'error');
        persistPreferences();
        return false;
      } finally {
        if (requestId === githubVerifyRequestId) {
          githubVerifyInFlight = false;
          if (btnGithubVerify) btnGithubVerify.disabled = false;
          updateUploadGistButtonState();
        }
      }
    }

    function normalizeRemoteUploadSources(raw) {
      const result = {};
      if (!raw || typeof raw !== 'object') return result;
      Object.entries(raw).forEach(([key, value]) => {
        const normalizedKey = normalizeEditorKey(key);
        if (!normalizedKey) return;
        const url = String(value || '').trim();
        if (!url) return;
        result[normalizedKey] = url;
      });
      return result;
    }

    function loadRemoteUploadSources() {
      let parsed = {};
      try {
        parsed = JSON.parse(localStorage.getItem(LS_REMOTE_UPLOAD_SOURCES) || '{}') || {};
      } catch (err) {
        parsed = {};
      }
      remoteUploadSources = normalizeRemoteUploadSources(parsed);
    }

    function persistRemoteUploadSources() {
      localStorage.setItem(LS_REMOTE_UPLOAD_SOURCES, JSON.stringify(remoteUploadSources));
    }

    function getRemoteUploadSource(editorKey = activeTab) {
      const key = normalizeEditorKey(editorKey);
      if (!key) return '';
      return String(remoteUploadSources[key] || '').trim();
    }

    function setRemoteUploadSource(editorKey, url) {
      const key = normalizeEditorKey(editorKey);
      if (!key) return;
      const normalizedUrl = String(url || '').trim();
      if (!normalizedUrl) {
        delete remoteUploadSources[key];
      } else {
        remoteUploadSources[key] = normalizedUrl;
      }
      persistRemoteUploadSources();
      updateUploadRefreshButtonState();
    }

    function updateUploadGistButtonState() {
      const savedUrl = getRemoteUploadSource(activeTab);
      const gistSource = parseGistSource(savedUrl);
      const hasToken = !!getGithubTokenValue();
      const verified = isGithubTokenVerified();
      const hasGistSource = !!gistSource;
      btnUploadGist.classList.toggle('hidden', !hasGistSource);

      if (!hasGistSource) {
        btnUploadGist.disabled = true;
        btnUploadGist.title = 'Load this tab from a GitHub gist URL first.';
        return;
      }

      btnUploadGist.disabled = false;
      btnUploadGist.title = !hasToken
        ? 'Set a GitHub token in Settings > Integrations to update this gist.'
        : (verified
          ? `Update gist ${gistSource.gistId} from ${getEditorLabel(activeTab)}`
          : 'Verify your GitHub token in Settings > Integrations to update this gist.');
    }

    function updateUploadRefreshButtonState() {
      const savedUrl = getRemoteUploadSource(activeTab);
      const hasSavedUrl = !!savedUrl;
      btnUploadRefresh.disabled = !hasSavedUrl;
      btnUploadRefresh.title = hasSavedUrl
        ? `Refresh ${getEditorLabel(activeTab)} from saved URL`
        : 'No saved URL for this tab yet';
      updateUploadGistButtonState();
    }

    function setUploadMenuOpen(nextOpen) {
      const shouldOpen = !!nextOpen;
      if (shouldOpen) {
        uploadUrlInput.value = getRemoteUploadSource(activeTab);
      }
      uploadMenu.classList.toggle('open', shouldOpen);
      btnUpload.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    }

    function closeUploadMenu() {
      setUploadMenuOpen(false);
    }

    async function fetchPublicText(url, options = {}) {
      const trimmed = String(url || '').trim();
      if (!trimmed) throw new Error('Enter a public URL first.');
      let parsedUrl = null;
      try {
        parsedUrl = new URL(trimmed);
      } catch (err) {
        throw new Error('Invalid URL.');
      }
      if (!/^https?:$/.test(parsedUrl.protocol)) {
        throw new Error('Only http:// or https:// URLs are supported.');
      }
      const targetTab = normalizeEditorKey(options.tab || activeTab) || activeTab;
      const githubToken = isGithubTokenVerified() ? getGithubTokenValue() : '';

      const gistSource = parseGistSource(parsedUrl.toString());
      if (gistSource) {
        let gistPayload = null;
        try {
          gistPayload = await fetchGistData(gistSource, githubToken);
        } catch (err) {
          const likelyPrivate = (err && (err.githubStatus === 401 || err.githubStatus === 403 || err.githubStatus === 404));
          if (likelyPrivate && !isGithubTokenVerified()) {
            throw new Error('Private GitHub gist URLs require a verified GitHub token (Settings > Integrations).');
          }
          throw err;
        }
        const fileName = resolveGistFileName(gistPayload.files, gistSource, targetTab);
        const gistFile = gistPayload.files[fileName];
        if (!gistFile) {
          throw new Error(`Gist file "${fileName}" is unavailable.`);
        }
        if (typeof gistFile.content === 'string') {
          return gistFile.content;
        }
        if (gistFile.raw_url) {
          const rawResponse = await fetch(gistFile.raw_url, {
            cache: 'no-store',
            headers: getGithubHeaders(githubToken, false),
          });
          if (!rawResponse.ok) {
            throw new Error(`Gist raw file fetch failed (${rawResponse.status}).`);
          }
          return await rawResponse.text();
        }
        throw new Error(`Gist file "${fileName}" has no text content.`);
      }

      const githubRepoSource = parseGithubRepoFileSource(parsedUrl.toString());
      if (githubRepoSource) {
        try {
          return await fetchGithubRepoFileText(githubRepoSource, githubToken);
        } catch (err) {
          const likelyPrivate = (err && (err.githubStatus === 401 || err.githubStatus === 403 || err.githubStatus === 404));
          if (likelyPrivate && !isGithubTokenVerified()) {
            throw new Error('Private GitHub repo URLs require a verified GitHub token (Settings > Integrations).');
          }
          throw err;
        }
      }

      const fetchText = async (target) => {
        const resp = await fetch(target, { cache: 'no-store' });
        if (!resp.ok) {
          throw new Error(`Request failed (${resp.status}).`);
        }
        return await resp.text();
      };

      try {
        return await fetchText(parsedUrl.toString());
      } catch (primaryErr) {
        const proxied = `${GOOGLE_PROXY_PREFIX}${parsedUrl.toString().replace(/^https?:\/\//, '')}`;
        try {
          return await fetchText(proxied);
        } catch (proxyErr) {
          throw new Error(
            `Could not fetch URL directly or via proxy. Check public access/CORS. (${primaryErr.message || primaryErr})`,
          );
        }
      }
    }

    async function loadEditorFromPublicUrl(url, options = {}) {
      const targetTab = normalizeEditorKey(options.tab || activeTab);
      if (!targetTab || !editors[targetTab]) {
        throw new Error('No editable tab selected.');
      }
      const normalizedUrl = String(url || '').trim();
      if (!normalizedUrl) throw new Error('Enter a public URL first.');

      setStatus(`Fetching ${getEditorLabel(targetTab)} from URL...`, 'compiling');
      const text = await fetchPublicText(normalizedUrl, { tab: targetTab });
      setEditorContent(targetTab, text);
      if (targetTab === 'resume') markResumeCustomized(true);
      setRemoteUploadSource(targetTab, normalizedUrl);
      setStatus(`Loaded ${getEditorLabel(targetTab)} from URL.`, 'ready');
    }

    async function updateGistFromEditorSource(editorKey = activeTab) {
      const targetTab = normalizeEditorKey(editorKey);
      if (!targetTab || !editors[targetTab]) {
        throw new Error('No editable tab selected.');
      }

      const sourceUrl = getRemoteUploadSource(targetTab);
      const gistSource = parseGistSource(sourceUrl);
      if (!gistSource) {
        throw new Error(`No GitHub gist source saved for ${getEditorLabel(targetTab)}.`);
      }

      const token = getGithubTokenValue();
      if (!token) {
        throw new Error('Set a GitHub token in Settings > Integrations first.');
      }
      if (!isGithubTokenVerified()) {
        throw new Error('Verify your GitHub token in Settings > Integrations first.');
      }

      const gistPayload = await fetchGistData(gistSource, token);
      const fileName = resolveGistFileName(gistPayload.files, gistSource, targetTab);
      const currentContent = editors[targetTab].getValue();

      const response = await fetch(gistSource.apiUrl, {
        method: 'PATCH',
        headers: getGithubHeaders(token, true),
        body: JSON.stringify({
          files: {
            [fileName]: { content: currentContent },
          },
        }),
      });
      if (!response.ok) {
        const detail = await extractGithubErrorMessage(response);
        throw new Error(detail ? `GitHub gist update failed: ${detail}` : `GitHub gist update failed (${response.status}).`);
      }
      return { fileName, gistId: gistSource.gistId };
    }

    function getDefaultAiModel(provider = getAiProvider()) {
      if (!provider || provider === 'disabled') return '';
      return AI_PROVIDER_CONFIG[provider]?.defaultModel || '';
    }

    function ensureAiModelForProvider(force = false) {
      const provider = getAiProvider();
      if (provider === 'disabled') {
        if (force) aiModel.value = '';
        return;
      }
      if (force || !getAiModelValue()) {
        aiModel.value = getDefaultAiModel(provider);
      }
    }

    function normalizeAiProviderValue(raw) {
      const value = String(raw || '').trim().toLowerCase();
      if (Object.prototype.hasOwnProperty.call(AI_PROVIDER_CONFIG, value)) return value;
      return 'disabled';
    }

    function getActiveConfigEditorKey() {
      return getModeVariant() === 'short' ? 'config-short' : 'config';
    }

    function getActiveConfigEditor() {
      return editors[getActiveConfigEditorKey()];
    }

    function splitYamlLines(source) {
      return String(source || '').split(/\r?\n/);
    }

    function findTopLevelSectionBounds(lines, sectionName) {
      const sectionPattern = new RegExp(`^${sectionName}\\s*:\\s*(?:#.*)?$`);
      const topLevelPattern = /^[A-Za-z0-9_-]+\s*:\s*(?:#.*)?$/;
      let start = -1;
      for (let i = 0; i < lines.length; i += 1) {
        if (sectionPattern.test(lines[i].trim())) {
          start = i;
          break;
        }
      }
      if (start < 0) return { start: -1, end: lines.length };
      let end = lines.length;
      for (let i = start + 1; i < lines.length; i += 1) {
        if (topLevelPattern.test(lines[i].trim())) {
          end = i;
          break;
        }
      }
      return { start, end };
    }

    function stripInlineYamlComment(value) {
      const input = String(value || '');
      let output = '';
      let inSingle = false;
      let inDouble = false;
      for (let i = 0; i < input.length; i += 1) {
        const ch = input[i];
        if (ch === "'" && !inDouble) {
          inSingle = !inSingle;
          output += ch;
          continue;
        }
        if (ch === '"' && !inSingle) {
          inDouble = !inDouble;
          output += ch;
          continue;
        }
        if (ch === '#' && !inSingle && !inDouble) break;
        output += ch;
      }
      return output.trim();
    }

    function unquoteYamlScalar(value) {
      const text = stripInlineYamlComment(value);
      if ((text.startsWith('"') && text.endsWith('"')) || (text.startsWith("'") && text.endsWith("'"))) {
        return text.slice(1, -1);
      }
      return text;
    }

    function escapeForRegex(raw) {
      return String(raw).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function getYamlSectionFieldRaw(yamlText, sectionName, keyName) {
      const lines = splitYamlLines(yamlText);
      const { start, end } = findTopLevelSectionBounds(lines, sectionName);
      if (start < 0) return null;
      const fieldPattern = new RegExp(`^\\s{2}${escapeForRegex(keyName)}\\s*:\\s*(.*)$`);
      for (let i = start + 1; i < end; i += 1) {
        const match = lines[i].match(fieldPattern);
        if (match) return stripInlineYamlComment(match[1]);
      }
      return null;
    }

    function setYamlSectionFieldValue(yamlText, sectionName, keyName, valueLiteral) {
      const lines = splitYamlLines(yamlText);
      const sectionHeader = `${sectionName}:`;
      const { start, end } = findTopLevelSectionBounds(lines, sectionName);
      const nextLine = `  ${keyName}: ${valueLiteral}`;

      if (start < 0) {
        if (lines.length > 0 && lines[lines.length - 1].trim() !== '') lines.push('');
        lines.push(sectionHeader);
        lines.push(nextLine);
        return lines.join('\n');
      }

      const fieldPattern = new RegExp(`^\\s{2}${escapeForRegex(keyName)}\\s*:\\s*(.*)$`);
      for (let i = start + 1; i < end; i += 1) {
        if (fieldPattern.test(lines[i])) {
          lines[i] = nextLine;
          return lines.join('\n');
        }
      }

      lines.splice(end, 0, nextLine);
      return lines.join('\n');
    }

    function yamlQuotedString(value) {
      return `"${String(value || '').replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
    }

    function parseYamlBoolean(rawValue) {
      if (rawValue == null) return null;
      const normalized = stripInlineYamlComment(rawValue).toLowerCase();
      if (normalized === 'true') return true;
      if (normalized === 'false') return false;
      return null;
    }

    function syncConfigControlsFromActiveConfig() {
      const configEditor = getActiveConfigEditor();
      if (!configEditor) return;
      const configText = configEditor.getValue();

      const linkBehavior = unquoteYamlScalar(getYamlSectionFieldRaw(configText, 'visibility', 'links_disabled_behavior'));
      if (linkBehavior === 'label' || linkBehavior === 'label_with_url') {
        setSelectValue(overrideLinksDisabledBehavior, linkBehavior, 'label');
      }

      const showPubNumbers = parseYamlBoolean(getYamlSectionFieldRaw(configText, 'visibility', 'show_publication_numbers'));
      if (showPubNumbers === true || showPubNumbers === false) {
        setSelectValue(overridePubnums, showPubNumbers ? 'on' : 'off', 'off');
      }

      const contactMode = unquoteYamlScalar(getYamlSectionFieldRaw(configText, 'styling', 'contact_display_mode'));
      if (contactMode === 'label' || contactMode === 'icon_label') {
        setSelectValue(overrideContact, contactMode, 'icon_label');
      }

      const fontValue = unquoteYamlScalar(getYamlSectionFieldRaw(configText, 'fonts', 'font'));
      if (fontValue && Array.from(overrideFont.options).some((option) => option.value === fontValue)) {
        setSelectValue(overrideFont, fontValue, overrideFont.options[0]?.value || '');
      }

      const monoFontValue = unquoteYamlScalar(getYamlSectionFieldRaw(configText, 'fonts', 'mono_font'));
      if (monoFontValue && Array.from(overrideMonoFont.options).some((option) => option.value === monoFontValue)) {
        setSelectValue(overrideMonoFont, monoFontValue, overrideMonoFont.options[0]?.value || '');
      }

      refreshCustomSelects();
    }

    function updateActiveConfigFromControls(controlName) {
      const editorKey = getActiveConfigEditorKey();
      const configEditor = editors[editorKey];
      if (!configEditor) return;

      let section = '';
      let key = '';
      let valueLiteral = '';

      if (controlName === 'links_disabled_behavior') {
        section = 'visibility';
        key = 'links_disabled_behavior';
        valueLiteral = yamlQuotedString(overrideLinksDisabledBehavior.value);
      } else if (controlName === 'show_publication_numbers') {
        section = 'visibility';
        key = 'show_publication_numbers';
        valueLiteral = overridePubnums.value === 'on' ? 'true' : 'false';
      } else if (controlName === 'contact_display_mode') {
        section = 'styling';
        key = 'contact_display_mode';
        valueLiteral = yamlQuotedString(overrideContact.value);
      } else if (controlName === 'font') {
        section = 'fonts';
        key = 'font';
        valueLiteral = yamlQuotedString(overrideFont.value);
      } else if (controlName === 'mono_font') {
        section = 'fonts';
        key = 'mono_font';
        valueLiteral = yamlQuotedString(overrideMonoFont.value);
      } else {
        return;
      }

      const current = configEditor.getValue();
      const next = setYamlSectionFieldValue(current, section, key, valueLiteral);
      if (next === current) return;
      setEditorContent(editorKey, next);
      syncConfigControlsFromActiveConfig();
    }

    function isDefaultResumeContent(text) {
      const normalized = String(text || '').trim();
      return normalized === String(defaultResumeBySource.resume || '').trim()
        || normalized === String(defaultResumeBySource.bibtex || '').trim();
    }

    function markResumeCustomized(nextValue = true) {
      resumeCustomized = !!nextValue;
      localStorage.setItem(LS_RESUME_CUSTOMIZED, resumeCustomized ? '1' : '0');
    }

    function maybeApplyDefaultResumeForSource(nextSource) {
      if (resumeCustomized) return false;
      const modeSource = nextSource === 'bibtex' ? 'bibtex' : 'resume';
      const nextDefault = defaultResumeBySource[modeSource] || '';
      if (!nextDefault) return false;
      if (String(cmResume.getValue() || '').trim() === String(nextDefault).trim()) return false;
      setEditorContent('resume', nextDefault);
      markResumeCustomized(false);
      return true;
    }

    function resumeHasBibtexLinkedEntries(resumeYamlText) {
      return /^\s*bib_key\s*:/m.test(String(resumeYamlText || ''));
    }

    function isAiConfigured() {
      return getAiProvider() !== 'disabled' && !!getAiModelValue() && !!getAiApiKeyValue();
    }

    function updateAiActionButtons() {
      const hasOutput = hasGeneratedAiOutput();
      const verified = isAiSettingsVerified();
      const selectionContext = getAiSelectionContext();
      const hasSelection = !!selectionContext;
      updateAiOutputPanelVisibility();
      updateAiOutputViewAvailability();
      ensureValidResumeCompileSource({ triggerCompile: true });
      btnAiCopy.disabled = aiInFlight || aiVerifyInFlight || !hasOutput || !verified;
      if (resumeUseGeneratedRow) {
        resumeUseGeneratedRow.classList.toggle('hidden', !hasOutput || !verified);
      }
      if (btnAiVerify) {
        btnAiVerify.disabled = aiInFlight || aiVerifyInFlight;
      }
      if (resumeUseGenerated) {
        resumeUseGenerated.disabled = aiInFlight || aiVerifyInFlight || !hasOutput || !verified;
      }
      if (btnAiSelectionGenerate) {
        btnAiSelectionGenerate.disabled = aiInFlight || aiVerifyInFlight || !hasSelection || !verified;
      }
      syncAiSelectionPopover({ context: selectionContext });
      updateResumeEditorSurface();
    }

    function bytesToBase64Url(bytes) {
      let binary = '';
      const chunkSize = 0x8000;
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.subarray(i, i + chunkSize);
        binary += String.fromCharCode(...chunk);
      }
      return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
    }

    function base64UrlToBytes(base64Url) {
      const normalized = String(base64Url || '').replace(/-/g, '+').replace(/_/g, '/');
      const padded = normalized + '==='.slice((normalized.length + 3) % 4);
      const binary = atob(padded);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }

    async function encodeSharePayload(statePayload) {
      const rawJson = JSON.stringify({ version: 1, state: statePayload });
      const rawBytes = new TextEncoder().encode(rawJson);
      if (typeof CompressionStream === 'function') {
        const compressedStream = new Blob([rawBytes]).stream().pipeThrough(new CompressionStream('gzip'));
        const compressedArrayBuffer = await new Response(compressedStream).arrayBuffer();
        return `gz.${bytesToBase64Url(new Uint8Array(compressedArrayBuffer))}`;
      }
      return `raw.${bytesToBase64Url(rawBytes)}`;
    }

    async function decodeSharePayload(token) {
      const rawToken = String(token || '').trim();
      if (!rawToken) throw new Error('Missing share state token.');
      const [encoding, encoded] = rawToken.split('.', 2);
      if (!encoding || !encoded) throw new Error('Malformed share token.');
      const bytes = base64UrlToBytes(encoded);
      let jsonText = '';
      if (encoding === 'gz') {
        if (typeof DecompressionStream !== 'function') {
          throw new Error('This browser cannot read compressed share links.');
        }
        const decompressed = new Blob([bytes]).stream().pipeThrough(new DecompressionStream('gzip'));
        const arrayBuffer = await new Response(decompressed).arrayBuffer();
        jsonText = new TextDecoder().decode(arrayBuffer);
      } else if (encoding === 'raw') {
        jsonText = new TextDecoder().decode(bytes);
      } else {
        throw new Error('Unsupported share token format.');
      }
      const parsed = JSON.parse(jsonText);
      if (!parsed || typeof parsed !== 'object' || !parsed.state) {
        throw new Error('Invalid share state payload.');
      }
      return parsed.state;
    }

    function extractShareTokenFromUrl(urlObject, depth = 0) {
      if (!(urlObject instanceof URL)) return '';
      if (depth > 3) return '';

      const resolveCandidate = (rawValue) => {
        const candidate = String(rawValue || '').trim();
        if (!candidate) return '';
        if (/^(gz|raw)\.[A-Za-z0-9_-]+$/.test(candidate)) {
          return candidate;
        }
        if (depth >= 3) return '';
        try {
          const nestedUrl = new URL(candidate, window.location.href);
          return extractShareTokenFromUrl(nestedUrl, depth + 1);
        } catch (err) {
          return '';
        }
      };

      const queryKeys = [URL_STATE_PARAM, 'content', 'query', 'q'];
      for (const key of queryKeys) {
        const token = resolveCandidate(urlObject.searchParams.get(key));
        if (token) return token;
      }

      const hash = String(urlObject.hash || '').replace(/^#/, '').trim();
      if (!hash) return '';

      const hashParams = new URLSearchParams(hash);
      for (const key of queryKeys) {
        const token = resolveCandidate(hashParams.get(key));
        if (token) return token;
      }
      if (hash.startsWith('s=')) return resolveCandidate(hash.slice(2));
      if (hash.startsWith(`${URL_STATE_PARAM}=`)) return resolveCandidate(hash.slice(URL_STATE_PARAM.length + 1));
      return resolveCandidate(hash);
    }

    function buildShareStateObject(options = {}) {
      const includeKeys = options.includeKeys === true;
      return {
        editors: {
          resume: cmResume.getValue(),
          config: cmConfig.getValue(),
          configShort: cmConfigShort.getValue(),
          bib: cmBib.getValue(),
        },
        preferences: {
          paper: paperSize.value,
          variant: getModeVariant(),
          source: getModeSource(),
          linkMode: getModeLinkMode(),
          compileMode: getCompileMode(),
          resumeCompileSource: getResumeCompileSource(),
          resumeView: getResumeEditorView(),
          aiOutputView: getAiOutputViewMode(),
          activeTab,
          mobileView: getMobileView(),
          linksDisabledBehavior: overrideLinksDisabledBehavior.value,
          pubnums: overridePubnums.value,
          contact: overrideContact.value,
          font: overrideFont.value,
          monoFont: overrideMonoFont.value,
          paneWidth: getComputedStyle(mainContainer).getPropertyValue('--editor-pane-width').trim(),
          panelOverridesOpen: !!panelOverrides.open,
          panelAiSettingsOpen: !!panelAiSettings.open,
          panelIntegrationsOpen: !!panelIntegrations.open,
          panelAiJdOpen: !!aiJdPanel.open,
        },
        ai: {
          provider: getAiProvider(),
          model: getAiModelValue(),
          apiKey: includeKeys ? getAiApiKeyValue() : '',
          verified: isAiSettingsVerified(),
          webSearch: !!aiWebSearch.checked,
          prompt: String(aiUserPrompt.value || ''),
          jobDescription: String(aiJobDescription.value || ''),
          selectionPrompt: String(aiSelectionPrompt && aiSelectionPrompt.value || ''),
          output: String(getAiOutputValue() || ''),
        },
        integrations: {
          githubToken: includeKeys ? getGithubTokenValue() : '',
          githubVerified: isGithubTokenVerified(),
        },
        uploadSources: {
          remote: remoteUploadSources,
        },
      };
    }

    function setEditorsFromState(editorsState) {
      const normalized = editorsState && typeof editorsState === 'object' ? editorsState : {};
      suppressHistoryTracking = true;
      cmResume.setValue(typeof normalized.resume === 'string' ? normalized.resume : cmResume.getValue());
      cmConfig.setValue(typeof normalized.config === 'string' ? normalized.config : cmConfig.getValue());
      cmConfigShort.setValue(
        typeof normalized.configShort === 'string' ? normalized.configShort : cmConfigShort.getValue(),
      );
      cmBib.setValue(typeof normalized.bib === 'string' ? normalized.bib : cmBib.getValue());
      suppressHistoryTracking = false;

      editorHistories.resume = createDefaultHistory(cmResume.getValue());
      editorHistories.config = createDefaultHistory(cmConfig.getValue());
      editorHistories['config-short'] = createDefaultHistory(cmConfigShort.getValue());
      editorHistories.bib = createDefaultHistory(cmBib.getValue());

      localStorage.setItem(LS_RESUME, cmResume.getValue());
      localStorage.setItem(LS_CONFIG, cmConfig.getValue());
      localStorage.setItem(LS_CONFIG_SHORT, cmConfigShort.getValue());
      localStorage.setItem(LS_BIB, cmBib.getValue());
      queuePersistHistories();
    }

    function applyPreferencesFromState(preferencesState) {
      const prefs = preferencesState && typeof preferencesState === 'object' ? preferencesState : {};
      setModeVariant(prefs.variant || getModeVariant());
      setModeSource(prefs.source || getModeSource());
      setModeLinkMode(prefs.linkMode || getModeLinkMode());
      setCompileMode(prefs.compileMode || getCompileMode());
      setResumeCompileSource(prefs.resumeCompileSource || getResumeCompileSource(), { persist: false });
      setResumeEditorView(prefs.resumeView || getResumeEditorView(), { persist: false });
      setAiOutputViewMode(prefs.aiOutputView || getAiOutputViewMode(), { persist: false });
      const requestedMobileView = prefs.mobileView || getMobileView();
      setMobileView(window.innerWidth <= DESKTOP_SPLIT_BREAKPOINT ? 'editor' : requestedMobileView);
      if (prefs.paper === 'a4' || prefs.paper === 'letter') {
        paperSize.value = prefs.paper;
      }
      const paneWidthRaw = typeof prefs.paneWidth === 'string' ? prefs.paneWidth.trim() : '';
      if (paneWidthRaw.endsWith('%')) {
        applyEditorPaneWidth(paneWidthRaw.slice(0, -1), false);
      } else if (paneWidthRaw) {
        applyEditorPaneWidth(paneWidthRaw, false);
      }
      if (typeof prefs.panelOverridesOpen === 'boolean' || prefs.panelOverridesOpen === '1' || prefs.panelOverridesOpen === '0') {
        setDetailsOpen(panelOverrides, prefs.panelOverridesOpen === true || prefs.panelOverridesOpen === '1');
      }
      if (typeof prefs.panelAiSettingsOpen === 'boolean' || prefs.panelAiSettingsOpen === '1' || prefs.panelAiSettingsOpen === '0') {
        setDetailsOpen(panelAiSettings, prefs.panelAiSettingsOpen === true || prefs.panelAiSettingsOpen === '1');
      }
      if (typeof prefs.panelIntegrationsOpen === 'boolean' || prefs.panelIntegrationsOpen === '1' || prefs.panelIntegrationsOpen === '0') {
        setDetailsOpen(panelIntegrations, prefs.panelIntegrationsOpen === true || prefs.panelIntegrationsOpen === '1');
      }
      if (typeof prefs.panelAiJdOpen === 'boolean' || prefs.panelAiJdOpen === '1' || prefs.panelAiJdOpen === '0') {
        setDetailsOpen(aiJdPanel, prefs.panelAiJdOpen === true || prefs.panelAiJdOpen === '1');
      }
      if (typeof prefs.activeTab === 'string' && Object.prototype.hasOwnProperty.call(containers, prefs.activeTab)) {
        activeTab = prefs.activeTab;
      }
    }

    function applyAiState(aiState) {
      const ai = aiState && typeof aiState === 'object' ? aiState : {};
      const provider = normalizeAiProviderValue(ai.provider);
      setSelectValue(aiProvider, provider, 'disabled');
      const defaultModel = getDefaultAiModel(getAiProvider());
      aiModel.value = typeof ai.model === 'string' ? ai.model : defaultModel;
      aiApiKey.value = typeof ai.apiKey === 'string' ? ai.apiKey : '';
      aiWebSearch.checked = ai.webSearch !== false;
      aiUserPrompt.value = typeof ai.prompt === 'string' ? ai.prompt : AI_DEFAULT_PROMPT;
      aiJobDescription.value = typeof ai.jobDescription === 'string' ? ai.jobDescription : '';
      if (aiSelectionPrompt) {
        aiSelectionPrompt.value = typeof ai.selectionPrompt === 'string' ? ai.selectionPrompt : '';
      }
      setAiOutputValue(typeof ai.output === 'string' ? ai.output : '', { silentChange: true });
      const isVerified = ai.verified === true || ai.verified === '1';
      setAiSettingsVerified(isVerified && isAiConfigured(), { persist: false });
      setAiVerifyStatus(isAiSettingsVerified() ? 'AI settings verified.' : 'Not verified.', isAiSettingsVerified() ? 'success' : '');
      updateShareMenuVisibility();
      updateAiActionButtons();
    }

    function applyIntegrationState(integrationsState) {
      const integrations = integrationsState && typeof integrationsState === 'object' ? integrationsState : {};
      githubToken.value = typeof integrations.githubToken === 'string' ? integrations.githubToken : '';
      const isVerified = integrations.githubVerified === true || integrations.githubVerified === '1';
      setGithubTokenVerified(isVerified && !!githubToken.value, { persist: false });
      if (!githubToken.value && !githubVerifyInFlight) {
        setGithubVerifyStatus('Not verified.');
      } else if (githubToken.value && !isGithubTokenVerified() && !githubVerifyInFlight) {
        setGithubVerifyStatus('Token set. Click Verify GitHub Token.');
      }
      updateShareMenuVisibility();
    }

    function applyUploadSourcesState(uploadSourcesState) {
      if (!uploadSourcesState || typeof uploadSourcesState !== 'object' || !Object.prototype.hasOwnProperty.call(uploadSourcesState, 'remote')) {
        return;
      }
      const uploadSources = uploadSourcesState;
      const normalizedRemote = normalizeRemoteUploadSources(uploadSources.remote);
      remoteUploadSources = normalizedRemote;
      persistRemoteUploadSources();
      updateUploadRefreshButtonState();
    }

    function applyShareState(statePayload, options = {}) {
      const state = statePayload && typeof statePayload === 'object' ? statePayload : {};
      const shouldScheduleCompile = options.scheduleCompile !== false;
      setEditorsFromState(state.editors);
      applyPreferencesFromState(state.preferences);
      applyAiState(state.ai);
      const prefs = state.preferences && typeof state.preferences === 'object' ? state.preferences : {};
      setAiOutputViewMode(prefs.aiOutputView || getAiOutputViewMode(), { persist: false });
      applyIntegrationState(state.integrations);
      applyUploadSourcesState(state.uploadSources);
      refreshCustomSelects();
      updateTabVisibility();
      syncConfigControlsFromActiveConfig();
      markResumeCustomized(!isDefaultResumeContent(cmResume.getValue()));
      lastSourceSelection = getModeSource();
      updateBibHealthStatus(true);
      updateCompileControlsUI();
      persistPreferences();
      updateAiActionButtons();
      if (shouldScheduleCompile) scheduleCompile();
    }

    async function buildShareUrl(options = {}) {
      const payload = buildShareStateObject(options);
      const token = await encodeSharePayload(payload);
      const url = new URL(window.location.href);
      url.searchParams.set(URL_STATE_PARAM, token);
      url.hash = '';
      return url.toString();
    }

    async function copyShareUrlToClipboard(options = {}) {
      const shareUrl = await buildShareUrl(options);
      if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
        await navigator.clipboard.writeText(shareUrl);
      } else {
        window.prompt('Copy share URL', shareUrl);
      }
      history.replaceState(null, '', shareUrl);
      return shareUrl;
    }

    async function loadShareStateFromToken(token, options = {}) {
      const state = await decodeSharePayload(token);
      applyShareState(state, options);
      return state;
    }

    async function tryLoadShareStateFromLocation(options = {}) {
      const url = new URL(window.location.href);
      const token = extractShareTokenFromUrl(url);
      if (!token) return false;
      await loadShareStateFromToken(token, options);
      return true;
    }

    function updateSupportedKeysContent() {
      supportedKeysContent.innerHTML = TAB_SUPPORTED_KEYS_HTML[activeTab] || TAB_SUPPORTED_KEYS_HTML.resume;
    }

    function isDesktopSplitEnabled() {
      return window.innerWidth > DESKTOP_SPLIT_BREAKPOINT;
    }

    function clampEditorPaneWidth(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return DEFAULT_EDITOR_WIDTH;
      return Math.max(MIN_EDITOR_WIDTH, Math.min(MAX_EDITOR_WIDTH, numeric));
    }

    function normalizeResumeEditorView(value) {
      return value === 'ai' ? 'ai' : 'original';
    }

    function getResumeEditorView() {
      return normalizeResumeEditorView(resumeEditorView);
    }

    function setResumeEditorView(value, options = {}) {
      resumeEditorView = normalizeResumeEditorView(value);
      updateResumeEditorSurface();
      if (options.persist !== false) {
        persistPreferences();
      }
    }

    function updateResumeViewToggleUI() {
      const isOriginal = getResumeEditorView() === 'original';
      btnResumeViewOriginal.classList.toggle('active', isOriginal);
      btnResumeViewOriginal.setAttribute('aria-pressed', isOriginal ? 'true' : 'false');
      btnResumeViewAi.classList.toggle('active', !isOriginal);
      btnResumeViewAi.setAttribute('aria-pressed', isOriginal ? 'false' : 'true');
      btnResumeViewAi.setAttribute('aria-disabled', 'false');
    }

    function updateResumeEditorSurface() {
      const onResumeTab = activeTab === 'resume';
      const aiViewActive = onResumeTab && getResumeEditorView() === 'ai';
      const hasOutput = hasGeneratedAiOutput();
      const verified = isAiSettingsVerified();
      const aiMode = getAiOutputViewMode();
      const showAiEditor = aiViewActive && verified && hasOutput && aiMode === 'variant';
      const showAiDiff = aiViewActive && verified && hasOutput && aiMode === 'diff';
      const showAiPlaceholder = aiViewActive && verified && !hasOutput;

      resumeViewToggle.classList.toggle('hidden', !onResumeTab);
      resumeAiWorkspace.classList.toggle('hidden', !aiViewActive);
      updateResumeViewToggleUI();

      containers.resume.classList.toggle('hidden', !onResumeTab || aiViewActive);
      aiOutputContainer.classList.toggle('hidden', !showAiEditor);
      aiOutputDiff.classList.toggle('hidden', !showAiDiff);
      if (aiDiffOverview) aiDiffOverview.classList.toggle('hidden', !showAiDiff);
      aiOutputPlaceholder.classList.toggle('hidden', !showAiPlaceholder);

      if (showAiEditor) {
        cmAiOutput.refresh();
      }
    }

    function refreshAllEditors() {
      Object.values(editors).forEach((editor) => editor.refresh());
      cmAiOutput.refresh();
      updateAiActionButtons();
    }

    function applyEditorPaneWidth(value, persist = true, refresh = true) {
      const clamped = clampEditorPaneWidth(value);
      if (!isDesktopSplitEnabled()) {
        mainContainer.style.removeProperty('--editor-pane-width');
        if (persist) {
          localStorage.setItem(LS_EDITOR_PANE_WIDTH, String(clamped));
        }
        if (refresh) refreshAllEditors();
        return;
      }
      mainContainer.style.setProperty('--editor-pane-width', `${clamped}%`);
      if (persist) {
        localStorage.setItem(LS_EDITOR_PANE_WIDTH, String(clamped));
      }
      if (refresh) refreshAllEditors();
    }

    function setupPaneResizer() {
      let dragging = false;
      let raf = null;

      const onPointerMove = (event) => {
        if (!dragging || !isDesktopSplitEnabled()) return;
        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          const rect = mainContainer.getBoundingClientRect();
          const width = rect.width || 1;
          const percentage = ((event.clientX - rect.left) / width) * 100;
          applyEditorPaneWidth(percentage, false, false);
        });
      };

      const stopDragging = () => {
        if (!dragging) return;
        dragging = false;
        if (raf) {
          cancelAnimationFrame(raf);
          raf = null;
        }
        mainContainer.classList.remove('is-resizing');
        const computed = getComputedStyle(mainContainer).getPropertyValue('--editor-pane-width').trim();
        if (computed.endsWith('%')) {
          localStorage.setItem(LS_EDITOR_PANE_WIDTH, String(clampEditorPaneWidth(computed.slice(0, -1))));
        }
        refreshAllEditors();
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', stopDragging);
      };

      paneResizer.addEventListener('pointerdown', (event) => {
        if (!isDesktopSplitEnabled()) return;
        event.preventDefault();
        dragging = true;
        mainContainer.classList.add('is-resizing');
        if (typeof paneResizer.setPointerCapture === 'function') {
          paneResizer.setPointerCapture(event.pointerId);
        }
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', stopDragging);
      });

      window.addEventListener('resize', () => {
        const storedWidth = localStorage.getItem(LS_EDITOR_PANE_WIDTH);
        applyEditorPaneWidth(storedWidth || DEFAULT_EDITOR_WIDTH, false);
      });
    }

    function updateTabScopedUI() {
      const onBibTab = activeTab === 'bib';
      const onResumeTab = activeTab === 'resume';
      document.querySelectorAll('.tab-bib-only').forEach((el) => {
        el.classList.toggle('visible', onBibTab);
      });
      bibImportPanel.classList.toggle('hidden', !onBibTab);
      btnUpload.disabled = false;
      btnUpload.title = 'Upload options';
      updateUploadRefreshButtonState();
      updateSupportedKeysContent();
      if (onBibTab) updateBibHealthStatus();
      updateAiActionButtons();
      updateResumeEditorSurface();
      if (onResumeTab) {
        cmAiOutput.refresh();
        renderAiDiffView();
      }
    }

    function updateBibImportPlaceholder() {
      const provider = bibImportProvider.value;
      bibImportId.placeholder = BIB_IMPORT_PLACEHOLDERS[provider] || BIB_IMPORT_PLACEHOLDERS.dblp;
    }

    function showPreviewFeedback(text, isError = false) {
      previewFeedbackText.textContent = text;
      preview.classList.add('compiling');
      preview.classList.toggle('has-error', !!isError);
    }

    function hidePreviewFeedback() {
      preview.classList.remove('compiling');
      preview.classList.remove('has-error');
    }

    function closeActiveCustomSelect() {
      if (!activeCustomSelect) return;
      activeCustomSelect.classList.remove('open');
      const trigger = activeCustomSelect.querySelector('.custom-select-trigger');
      if (trigger) trigger.setAttribute('aria-expanded', 'false');
      activeCustomSelect = null;
    }

    function refreshCustomSelects() {
      document.querySelectorAll('select').forEach((select) => {
        if (typeof select._refreshCustomSelect === 'function') {
          select._refreshCustomSelect();
        }
      });
    }

    function enhanceSelect(select) {
      if (!select || select.dataset.customized === '1') return;
      select.dataset.customized = '1';
      select.classList.add('native-select-hidden');

      const custom = document.createElement('div');
      custom.className = 'custom-select';

      const trigger = document.createElement('button');
      trigger.type = 'button';
      trigger.className = 'custom-select-trigger';
      trigger.setAttribute('aria-haspopup', 'listbox');
      trigger.setAttribute('aria-expanded', 'false');

      const value = document.createElement('span');
      value.className = 'custom-select-value';
      trigger.appendChild(value);

      const chevron = document.createElement('span');
      chevron.className = 'custom-select-chevron';
      trigger.appendChild(chevron);

      const menu = document.createElement('div');
      menu.className = 'custom-select-menu';
      menu.setAttribute('role', 'listbox');

      const selectOption = (nextValue) => {
        if (select.value !== nextValue) {
          select.value = nextValue;
          select.dispatchEvent(new Event('change', { bubbles: true }));
        }
        syncFromNative();
        closeActiveCustomSelect();
      };

      const syncFromNative = () => {
        const selectedOption = select.options[select.selectedIndex];
        value.textContent = selectedOption ? selectedOption.textContent : '';
        Array.from(menu.querySelectorAll('.custom-select-option')).forEach((optionButton) => {
          const isSelected = optionButton.dataset.value === select.value;
          optionButton.classList.toggle('selected', isSelected);
          optionButton.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        });
      };

      const renderOptionsFromNative = () => {
        menu.innerHTML = '';
        Array.from(select.options).forEach((option) => {
          const optionButton = document.createElement('button');
          optionButton.type = 'button';
          optionButton.className = 'custom-select-option';
          optionButton.dataset.value = option.value;
          optionButton.textContent = option.textContent;
          optionButton.setAttribute('role', 'option');
          optionButton.addEventListener('click', () => selectOption(option.value));
          menu.appendChild(optionButton);
        });
      };

      renderOptionsFromNative();

      trigger.addEventListener('click', (event) => {
        event.preventDefault();
        if (activeCustomSelect === custom) {
          closeActiveCustomSelect();
          return;
        }
        closeActiveCustomSelect();
        custom.classList.add('open');
        trigger.setAttribute('aria-expanded', 'true');
        activeCustomSelect = custom;
      });

      trigger.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeActiveCustomSelect();
          return;
        }
        if (event.key !== 'ArrowDown' && event.key !== 'ArrowUp' && event.key !== 'Enter' && event.key !== ' ') return;
        event.preventDefault();
        if (activeCustomSelect !== custom) {
          closeActiveCustomSelect();
          custom.classList.add('open');
          trigger.setAttribute('aria-expanded', 'true');
          activeCustomSelect = custom;
        }
        const options = Array.from(select.options);
        const currentIndex = Math.max(select.selectedIndex, 0);
        if (event.key === 'ArrowDown') {
          const nextIndex = (currentIndex + 1) % options.length;
          selectOption(options[nextIndex].value);
        } else if (event.key === 'ArrowUp') {
          const nextIndex = (currentIndex - 1 + options.length) % options.length;
          selectOption(options[nextIndex].value);
        }
      });

      select.parentNode.insertBefore(custom, select.nextSibling);
      custom.appendChild(trigger);
      custom.appendChild(menu);
      select._refreshCustomSelect = () => {
        renderOptionsFromNative();
        syncFromNative();
      };
      syncFromNative();

      if (select.id) {
        const boundLabel = document.querySelector(`label[for="${select.id}"]`);
        if (boundLabel) {
          boundLabel.addEventListener('click', (event) => {
            if (event.target.closest('.custom-select')) return;
            event.preventDefault();
            trigger.click();
          });
        }
      }
    }

    function enhanceAllSelects() {
      document.querySelectorAll('select').forEach(enhanceSelect);
      document.addEventListener('click', (event) => {
        if (event.target.closest('.custom-select')) return;
        closeActiveCustomSelect();
      });
      window.addEventListener('resize', closeActiveCustomSelect);
    }

    function openConfirmDialog({
      title = 'Confirm action',
      message = 'Proceed?',
      confirmText = 'Confirm',
      cancelText = 'Cancel',
      destructive = false,
    } = {}) {
      if (pendingConfirmResolve) {
        pendingConfirmResolve(false);
        pendingConfirmResolve = null;
      }

      confirmTitle.textContent = title;
      confirmMessage.textContent = message;
      confirmCancel.textContent = cancelText;
      confirmAccept.textContent = confirmText;
      confirmAccept.classList.toggle('danger', !!destructive);
      confirmModal.classList.add('open');
      confirmModal.setAttribute('aria-hidden', 'false');
      pendingConfirmFocus = document.activeElement;

      return new Promise((resolve) => {
        pendingConfirmResolve = resolve;
        confirmCancel.focus();
      });
    }

    function closeConfirmDialog(accepted) {
      if (!pendingConfirmResolve) return;
      const resolve = pendingConfirmResolve;
      pendingConfirmResolve = null;
      confirmModal.classList.remove('open');
      confirmModal.setAttribute('aria-hidden', 'true');
      resolve(accepted);
      if (pendingConfirmFocus && typeof pendingConfirmFocus.focus === 'function') {
        pendingConfirmFocus.focus();
      }
      pendingConfirmFocus = null;
    }

    confirmCancel.addEventListener('click', () => closeConfirmDialog(false));
    confirmAccept.addEventListener('click', () => closeConfirmDialog(true));
    confirmModal.addEventListener('click', (event) => {
      if (event.target === confirmModal) closeConfirmDialog(false);
    });
    document.addEventListener('keydown', (event) => {
      handleGlobalUndoRedoShortcut(event);
      if (event.key === 'Escape' && pendingConfirmResolve) closeConfirmDialog(false);
      if (event.key === 'Escape' && shareMenu.classList.contains('open')) closeShareMenu();
      if (event.key === 'Escape' && uploadMenu.classList.contains('open')) closeUploadMenu();
      if (event.key === 'Escape' && settingsFlyout.classList.contains('open')) setSettingsFlyoutOpen(false);
      if (event.key === 'Escape' && isAiSelectionPopoverOpen()) {
        hideAiSelectionPopover();
      }
    });

    document.addEventListener('click', (event) => {
      if (!shareMenu.contains(event.target)) {
        closeShareMenu();
      }
      if (!uploadMenu.contains(event.target)) {
        closeUploadMenu();
      }
      if (
        settingsFlyout.classList.contains('open')
        && !settingsFlyout.contains(event.target)
        && event.target !== btnSettings
        && !btnSettings.contains(event.target)
      ) {
        setSettingsFlyoutOpen(false);
      }
      const aiVariantSurface = cmAiOutput && typeof cmAiOutput.getWrapperElement === 'function'
        ? cmAiOutput.getWrapperElement()
        : null;
      const clickedInAiSurface = aiVariantSurface && aiVariantSurface.contains(event.target);
      if (
        isAiSelectionPopoverOpen()
        && !aiSelectionPopover.contains(event.target)
        && !clickedInAiSurface
      ) {
        hideAiSelectionPopover();
      }
    });

    enhanceAllSelects();
    setupPaneResizer();

    const tabs = Array.from(document.querySelectorAll('.tab[data-tab]'));

    function getCompileMode() {
      const selected = compileModeInputs.find((input) => input.checked);
      return selected && selected.value === 'manual' ? 'manual' : 'auto';
    }

    function setCompileMode(value) {
      const normalized = value === 'manual' ? 'manual' : 'auto';
      compileModeInputs.forEach((input) => {
        input.checked = input.value === normalized;
      });
    }

    function updateCompileControlsUI() {
      const manual = getCompileMode() === 'manual';
      btnCompileNow.disabled = !manual || !ready;
      compileModeHint.classList.toggle('pending', manual && hasPendingManualChanges);
      if (!manual) {
        compileModeHint.textContent = 'Auto compile on every change';
      } else if (hasPendingManualChanges) {
        compileModeHint.textContent = 'Changes pending. Click compile';
      } else {
        compileModeHint.textContent = 'Manual mode. No pending changes';
      }
    }

    function getModeVariant() {
      return overrideVariant.value === 'short' ? 'short' : 'default';
    }

    function setModeVariant(value) {
      setSelectValue(overrideVariant, value, 'default');
    }

    function getModeSource() {
      return overrideSource.value === 'bibtex' ? 'bibtex' : 'resume';
    }

    function setModeSource(value) {
      setSelectValue(overrideSource, value, 'resume');
    }

    function getModeLinkMode() {
      return overrideLinkMode.value === 'no-js' ? 'no-js' : 'links';
    }

    function setModeLinkMode(value) {
      setSelectValue(overrideLinkMode, value, 'links');
    }

    function getMobileView() {
      if (mainContainer.classList.contains('mobile-preview')) return 'preview';
      return 'editor';
    }

    function setMobileView(view) {
      const normalized = view === 'preview' ? 'preview' : 'editor';
      mainContainer.classList.toggle('mobile-preview', normalized === 'preview');
      mainContainer.classList.toggle('mobile-editor', normalized === 'editor');
      mobileViewButtons.forEach((button) => {
        button.classList.toggle('active', button.dataset.mobileView === normalized);
      });
    }

    function persistPreferences() {
      localStorage.setItem(LS_PAPER, paperSize.value);
      localStorage.setItem(LS_OVERRIDE_VARIANT, getModeVariant());
      localStorage.setItem(LS_OVERRIDE_SOURCE, getModeSource());
      localStorage.setItem(LS_OVERRIDE_LINK_MODE, getModeLinkMode());
      localStorage.setItem(LS_COMPILE_MODE, getCompileMode());
      localStorage.setItem(LS_RESUME_COMPILE_SOURCE, getResumeCompileSource());
      localStorage.setItem(LS_OVERRIDE_MODE_LEGACY, getSelectedMode());
      localStorage.setItem(LS_OVERRIDE_LINKS_DISABLED_BEHAVIOR, overrideLinksDisabledBehavior.value);
      localStorage.setItem(LS_OVERRIDE_PUBNUMS, overridePubnums.value);
      localStorage.setItem(LS_OVERRIDE_CONTACT, overrideContact.value);
      localStorage.setItem(LS_OVERRIDE_FONT, overrideFont.value);
      localStorage.setItem(LS_OVERRIDE_MONO_FONT, overrideMonoFont.value);
      localStorage.setItem(LS_ACTIVE_TAB, activeTab);
      localStorage.setItem(LS_MOBILE_VIEW, getMobileView());
      localStorage.setItem(LS_AI_PROVIDER, getAiProvider());
      localStorage.setItem(LS_AI_MODEL, aiModel.value);
      localStorage.setItem(LS_AI_API_KEY, aiApiKey.value);
      localStorage.setItem(LS_GITHUB_TOKEN, getGithubTokenValue());
      localStorage.setItem(LS_GITHUB_VERIFIED, isGithubTokenVerified() ? '1' : '0');
      localStorage.setItem(LS_AI_WEB_SEARCH, aiWebSearch.checked ? '1' : '0');
      localStorage.setItem(LS_AI_USER_PROMPT, aiUserPrompt.value);
      localStorage.setItem(LS_AI_JOB_DESCRIPTION, aiJobDescription.value);
      localStorage.setItem(LS_AI_SELECTION_PROMPT, aiSelectionPrompt ? aiSelectionPrompt.value : '');
      localStorage.setItem(LS_AI_OUTPUT, getAiOutputValue());
      localStorage.setItem(LS_AI_OUTPUT_VIEW, getAiOutputViewMode());
      localStorage.setItem(LS_AI_VERIFIED, isAiSettingsVerified() ? '1' : '0');
      localStorage.setItem(LS_RESUME_VIEW, getResumeEditorView());
      localStorage.setItem(LS_PANEL_OVERRIDES_OPEN, panelOverrides.open ? '1' : '0');
      localStorage.setItem(LS_PANEL_AI_SETTINGS_OPEN, panelAiSettings.open ? '1' : '0');
      localStorage.setItem(LS_PANEL_INTEGRATIONS_OPEN, panelIntegrations.open ? '1' : '0');
      localStorage.setItem(LS_PANEL_AI_JD_OPEN, aiJdPanel.open ? '1' : '0');
      const computedWidth = getComputedStyle(mainContainer).getPropertyValue('--editor-pane-width').trim();
      if (computedWidth.endsWith('%')) {
        localStorage.setItem(LS_EDITOR_PANE_WIDTH, String(clampEditorPaneWidth(computedWidth.slice(0, -1))));
      }
    }

    function createDefaultHistory(value) {
      return { undo: [], redo: [], current: String(value || '') };
    }

    function trimHistoryStack(stack) {
      if (stack.length > EDITOR_HISTORY_LIMIT) {
        stack.splice(0, stack.length - EDITOR_HISTORY_LIMIT);
      }
    }

    function queuePersistHistories() {
      if (historyPersistTimer) clearTimeout(historyPersistTimer);
      historyPersistTimer = setTimeout(() => {
        localStorage.setItem(LS_EDITOR_HISTORY, JSON.stringify(editorHistories));
      }, 120);
    }

    function normalizeLoadedHistory(key, loaded, currentValue) {
      if (!loaded || typeof loaded !== 'object') return createDefaultHistory(currentValue);
      const normalized = {
        undo: Array.isArray(loaded.undo) ? loaded.undo.filter((v) => typeof v === 'string') : [],
        redo: Array.isArray(loaded.redo) ? loaded.redo.filter((v) => typeof v === 'string') : [],
        current: typeof loaded.current === 'string' ? loaded.current : String(currentValue || ''),
      };
      trimHistoryStack(normalized.undo);
      trimHistoryStack(normalized.redo);
      if (normalized.current !== currentValue) {
        return createDefaultHistory(currentValue);
      }
      return normalized;
    }

    function loadEditorHistoriesFromStorage() {
      let loaded = {};
      try {
        loaded = JSON.parse(localStorage.getItem(LS_EDITOR_HISTORY) || '{}') || {};
      } catch (err) {
        loaded = {};
      }

      Object.keys(editors).forEach((key) => {
        const currentValue = editors[key].getValue();
        editorHistories[key] = normalizeLoadedHistory(key, loaded[key], currentValue);
      });
      queuePersistHistories();
      updateUndoRedoButtons();
    }

    function flushEditorHistoryTimer(editorKey) {
      if (!editorHistoryTimers[editorKey]) return;
      clearTimeout(editorHistoryTimers[editorKey]);
      editorHistoryTimers[editorKey] = null;
      const editor = editors[editorKey];
      if (!editor) return;
      recordEditorSnapshot(editorKey, editor.getValue());
    }

    function recordEditorSnapshot(editorKey, nextValue) {
      if (suppressHistoryTracking) return;
      const history = editorHistories[editorKey] || createDefaultHistory('');
      const value = String(nextValue || '');
      if (history.current === value) return;
      history.undo.push(history.current);
      trimHistoryStack(history.undo);
      history.current = value;
      history.redo = [];
      editorHistories[editorKey] = history;
      const contentKey = EDITOR_CONTENT_KEYS[editorKey];
      if (contentKey) localStorage.setItem(contentKey, value);
      queuePersistHistories();
      updateUndoRedoButtons();
    }

    function scheduleEditorHistorySnapshot(editorKey) {
      if (suppressHistoryTracking) return;
      if (editorHistoryTimers[editorKey]) clearTimeout(editorHistoryTimers[editorKey]);
      editorHistoryTimers[editorKey] = setTimeout(() => {
        editorHistoryTimers[editorKey] = null;
        const editor = editors[editorKey];
        if (!editor) return;
        recordEditorSnapshot(editorKey, editor.getValue());
      }, 240);
    }

    function editorHasUndo(editorKey) {
      const history = editorHistories[editorKey];
      return !!(history && history.undo.length > 0);
    }

    function editorHasRedo(editorKey) {
      const history = editorHistories[editorKey];
      return !!(history && history.redo.length > 0);
    }

    function updateUndoRedoButtons() {
      if (!editors[activeTab]) {
        btnUndo.disabled = true;
        btnRedo.disabled = true;
        return;
      }
      btnUndo.disabled = !editorHasUndo(activeTab);
      btnRedo.disabled = !editorHasRedo(activeTab);
    }

    function applyHistoryValue(editorKey, nextValue) {
      const editor = editors[editorKey];
      if (!editor) return;
      suppressHistoryTracking = true;
      editor.setValue(nextValue);
      suppressHistoryTracking = false;
      const contentKey = EDITOR_CONTENT_KEYS[editorKey];
      if (contentKey) localStorage.setItem(contentKey, nextValue);
      queuePersistHistories();
      updateUndoRedoButtons();
      scheduleCompile();
      if (editorKey === 'bib') updateBibHealthStatus(true);
    }

    function performEditorUndo(editorKey = activeTab) {
      flushEditorHistoryTimer(editorKey);
      const history = editorHistories[editorKey];
      if (!history || history.undo.length === 0) return;
      const previous = history.undo.pop();
      history.redo.push(history.current);
      trimHistoryStack(history.redo);
      history.current = previous;
      applyHistoryValue(editorKey, previous);
    }

    function performEditorRedo(editorKey = activeTab) {
      flushEditorHistoryTimer(editorKey);
      const history = editorHistories[editorKey];
      if (!history || history.redo.length === 0) return;
      const next = history.redo.pop();
      history.undo.push(history.current);
      trimHistoryStack(history.undo);
      history.current = next;
      applyHistoryValue(editorKey, next);
    }

    function handleGlobalUndoRedoShortcut(event) {
      if (event.defaultPrevented) return;
      if (!(event.metaKey || event.ctrlKey) || event.altKey) return;
      if (pendingConfirmResolve) return;
      const target = event.target;
      const tag = target && target.tagName ? target.tagName.toUpperCase() : '';
      if ((tag === 'INPUT' || tag === 'TEXTAREA') && !target.closest('.CodeMirror')) return;
      if (target && target.isContentEditable) return;

      const key = String(event.key || '').toLowerCase();
      const wantsUndo = key === 'z' && !event.shiftKey;
      const wantsRedo = (key === 'z' && event.shiftKey) || (key === 'y' && event.ctrlKey && !event.metaKey);
      if (!wantsUndo && !wantsRedo) return;

      event.preventDefault();
      if (wantsUndo) {
        performEditorUndo();
      } else {
        performEditorRedo();
      }
    }

    function isTabRelevant(tabId) {
      if (tabId === 'bib') return getModeSource() === 'bibtex';
      if (tabId === 'config') return getModeVariant() === 'default';
      if (tabId === 'config-short') return getModeVariant() === 'short';
      return true;
    }

    function syncActiveTabView() {
      tabs.forEach((tab) => {
        tab.classList.toggle('active', tab.dataset.tab === activeTab && !tab.classList.contains('hidden'));
      });
      Object.entries(containers).forEach(([key, el]) => {
        el.classList.toggle('hidden', key !== activeTab);
      });
      if (editors[activeTab]) editors[activeTab].refresh();
      updateUndoRedoButtons();
      updateTabScopedUI();
    }

    function updateTabVisibility() {
      const visibleTabs = [];
      tabs.forEach((tab) => {
        const visible = isTabRelevant(tab.dataset.tab);
        tab.classList.toggle('hidden', !visible);
        if (visible) visibleTabs.push(tab.dataset.tab);
      });
      if (!visibleTabs.includes(activeTab)) {
        if (activeTab === 'config' && visibleTabs.includes('config-short')) {
          activeTab = 'config-short';
        } else if (activeTab === 'config-short' && visibleTabs.includes('config')) {
          activeTab = 'config';
        } else {
          activeTab = visibleTabs.includes('resume') ? 'resume' : (visibleTabs[0] || 'resume');
        }
      }
      syncActiveTabView();
    }

    tabs.forEach((tab) => {
      tab.addEventListener('click', () => {
        if (tab.classList.contains('hidden')) return;
        closeUploadMenu();
        activeTab = tab.dataset.tab;
        syncActiveTabView();
        persistPreferences();
      });
    });

    mobileViewButtons.forEach((button) => {
      button.addEventListener('click', () => {
        setMobileView(button.dataset.mobileView);
        persistPreferences();
      });
    });

    btnUpload.addEventListener('click', (event) => {
      event.preventDefault();
      setUploadMenuOpen(!uploadMenu.classList.contains('open'));
    });
    btnUpload.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowDown' || event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        setUploadMenuOpen(true);
        btnUploadFile.focus();
      }
    });
    btnUploadFile.addEventListener('click', () => {
      pendingFileUploadTab = activeTab;
      closeUploadMenu();
      fileInput.click();
    });
    const onUploadFromUrl = async () => {
      const sourceUrl = String(uploadUrlInput.value || '').trim();
      if (!sourceUrl) {
        setStatus('Paste a gist URL to load from.', 'error');
        uploadUrlInput.focus();
        return;
      }
      const controls = [btnUpload, btnUploadFile, btnUploadUrl, btnUploadRefresh, btnUploadGist];
      controls.forEach((control) => {
        control.disabled = true;
      });
      try {
        await loadEditorFromPublicUrl(sourceUrl, { tab: activeTab });
        closeUploadMenu();
      } catch (err) {
        setStatus(`URL upload failed: ${err.message || err}`, 'error');
      } finally {
        controls.forEach((control) => {
          control.disabled = false;
        });
      }
    };
    btnUploadUrl.addEventListener('click', onUploadFromUrl);
    uploadUrlInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        onUploadFromUrl();
      }
    });
    btnUploadRefresh.addEventListener('click', async () => {
      const sourceUrl = getRemoteUploadSource(activeTab);
      if (!sourceUrl) {
        setStatus(`No saved URL source for ${getEditorLabel(activeTab)}.`, 'error');
        return;
      }
      const accepted = await openConfirmDialog({
        title: 'Refresh from saved URL?',
        message: `This will overwrite ${getEditorLabel(activeTab)} with the latest content from the saved URL.`,
        confirmText: 'Refresh',
        cancelText: 'Cancel',
        destructive: true,
      });
      if (!accepted) return;
      const controls = [btnUpload, btnUploadFile, btnUploadUrl, btnUploadRefresh, btnUploadGist];
      controls.forEach((control) => {
        control.disabled = true;
      });
      try {
        await loadEditorFromPublicUrl(sourceUrl, { tab: activeTab });
      } catch (err) {
        setStatus(`Refresh failed: ${err.message || err}`, 'error');
      } finally {
        controls.forEach((control) => {
          control.disabled = false;
        });
        updateUploadRefreshButtonState();
      }
    });
    btnUploadGist.addEventListener('click', async () => {
      const gistSource = parseGistSource(getRemoteUploadSource(activeTab));
      if (!gistSource) {
        setStatus(`No GitHub gist source saved for ${getEditorLabel(activeTab)}.`, 'error');
        return;
      }
      if (!getGithubTokenValue()) {
        setStatus('Set a GitHub token in Settings > Integrations to update this gist.', 'error');
        if (!panelIntegrations.open) setDetailsOpen(panelIntegrations, true);
        setSettingsFlyoutOpen(true);
        persistPreferences();
        return;
      }
      if (!isGithubTokenVerified()) {
        setStatus('Verify GitHub token in Settings > Integrations before updating this gist.', 'error');
        if (!panelIntegrations.open) setDetailsOpen(panelIntegrations, true);
        setSettingsFlyoutOpen(true);
        persistPreferences();
        return;
      }
      const accepted = await openConfirmDialog({
        title: 'Update gist from editor?',
        message: `This will overwrite the matching gist file for ${getEditorLabel(activeTab)} with your current editor content.`,
        confirmText: 'Update Gist',
        cancelText: 'Cancel',
        destructive: true,
      });
      if (!accepted) return;
      const controls = [btnUpload, btnUploadFile, btnUploadUrl, btnUploadRefresh, btnUploadGist];
      controls.forEach((control) => {
        control.disabled = true;
      });
      try {
        setStatus(`Updating gist for ${getEditorLabel(activeTab)}...`, 'compiling');
        const result = await updateGistFromEditorSource(activeTab);
        setStatus(`Updated gist ${result.gistId} (${result.fileName}).`, 'ready');
      } catch (err) {
        setStatus(`Gist update failed: ${err.message || err}`, 'error');
      } finally {
        controls.forEach((control) => {
          control.disabled = false;
        });
        updateUploadRefreshButtonState();
      }
    });
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) {
        pendingFileUploadTab = null;
        return;
      }
      const targetTab = normalizeEditorKey(pendingFileUploadTab) || activeTab;
      pendingFileUploadTab = null;
      if (!editors[targetTab]) {
        fileInput.value = '';
        return;
      }
      const reader = new FileReader();
      reader.onload = (ev) => {
        suppressHistoryTracking = true;
        editors[targetTab].setValue(ev.target.result);
        suppressHistoryTracking = false;
        if (targetTab === 'resume') {
          markResumeCustomized(true);
        }
        editorHistories[targetTab] = createDefaultHistory(ev.target.result);
        const contentKey = EDITOR_CONTENT_KEYS[targetTab];
        if (contentKey) localStorage.setItem(contentKey, ev.target.result);
        setRemoteUploadSource(targetTab, '');
        queuePersistHistories();
        updateUndoRedoButtons();
        scheduleCompile();
        setStatus(`Loaded ${getEditorLabel(targetTab)} from local file.`, 'ready');
      };
      reader.readAsText(file);
      fileInput.value = '';
    });

    function setEditorContent(editorKey, value) {
      const editor = editors[editorKey];
      if (!editor) return;
      const nextValue = String(value ?? '');
      suppressHistoryTracking = true;
      editor.setValue(nextValue);
      suppressHistoryTracking = false;
      editorHistories[editorKey] = createDefaultHistory(nextValue);
      const contentKey = EDITOR_CONTENT_KEYS[editorKey];
      if (contentKey) localStorage.setItem(contentKey, nextValue);
      queuePersistHistories();
      updateUndoRedoButtons();
      scheduleCompile();
    }

    function sanitizeAiOutput(rawText) {
      const value = String(rawText || '').trim();
      if (!value) return '';
      const fenced = value.match(/^```(?:yaml|yml)?\s*([\s\S]*?)\s*```$/i);
      if (fenced) return fenced[1].trim();
      return value;
    }

    function normalizeAiMessageContent(content) {
      if (typeof content === 'string') return content;
      if (!Array.isArray(content)) return '';
      return content
        .map((part) => {
          if (typeof part === 'string') return part;
          if (!part || typeof part !== 'object') return '';
          if (typeof part.text === 'string') return part.text;
          if (typeof part.output_text === 'string') return part.output_text;
          return '';
        })
        .filter(Boolean)
        .join('\n')
        .trim();
    }

    function extractOpenAiResponsesText(payload) {
      if (typeof payload?.output_text === 'string' && payload.output_text.trim()) {
        return payload.output_text.trim();
      }
      const output = Array.isArray(payload?.output) ? payload.output : [];
      const chunks = [];
      output.forEach((item) => {
        if (!item || typeof item !== 'object') return;
        const text = normalizeAiMessageContent(item.content);
        if (text) chunks.push(text);
      });
      return chunks.join('\n').trim();
    }

    function extractChatCompletionsText(payload) {
      const firstChoice = Array.isArray(payload?.choices) ? payload.choices[0] : null;
      if (!firstChoice || !firstChoice.message) return '';
      return normalizeAiMessageContent(firstChoice.message.content);
    }

    function extractGeminiText(payload) {
      const firstCandidate = Array.isArray(payload?.candidates) ? payload.candidates[0] : null;
      const parts = firstCandidate?.content?.parts;
      if (!Array.isArray(parts)) return '';
      return parts
        .map((part) => (typeof part?.text === 'string' ? part.text : ''))
        .filter(Boolean)
        .join('\n')
        .trim();
    }

    function extractClaudeText(payload) {
      const content = Array.isArray(payload?.content) ? payload.content : [];
      return content
        .map((part) => (part && part.type === 'text' && typeof part.text === 'string' ? part.text : ''))
        .filter(Boolean)
        .join('\n')
        .trim();
    }

    async function fetchProviderJson(url, init) {
      const response = await fetch(url, init);
      const text = await response.text();
      let payload = null;
      try {
        payload = text ? JSON.parse(text) : {};
      } catch (err) {
        payload = null;
      }
      if (!response.ok) {
        const message = payload?.error?.message || payload?.message || `Request failed (${response.status})`;
        throw new Error(message);
      }
      if (!payload || typeof payload !== 'object') {
        throw new Error('Provider returned a non-JSON response.');
      }
      return payload;
    }

    function buildAiSelectionPromptRequest(selectionContext, options = {}) {
      const context = selectionContext && typeof selectionContext === 'object' ? selectionContext : null;
      if (!context || !Number.isFinite(context.start) || !Number.isFinite(context.end) || context.end <= context.start) {
        throw new Error('Select a valid YAML segment in Variant view first.');
      }
      const workingYaml = String(context.workingYaml || getAiWorkingYaml());
      const selectedText = String(context.selectedText || '');
      if (!selectedText.trim()) {
        throw new Error('Selection is empty.');
      }
      const explicit = String(options.promptOverride || '').trim();
      const inline = String(aiSelectionPrompt && aiSelectionPrompt.value || '').trim();
      const global = String(aiUserPrompt.value || '').trim();
      const focus = explicit || inline || global;
      const jobDescription = String(aiJobDescription.value || '').trim();
      return {
        mode: 'selection',
        selection: context,
        systemPrompt: AI_DEFAULT_PROMPT,
        userPrompt: `Prompt focus (user):
${focus || '(none provided)'}

Target job description:
${jobDescription || '(none provided)'}

Rewrite scope:
- Rewrite ONLY the selected YAML fragment.
- Keep intent and structure compatible with surrounding YAML.
- Return ONLY the replacement YAML fragment text (no markdown fences, no explanations).

Current working AI output YAML:
${workingYaml}

Selected YAML fragment:
${selectedText}

Return only the rewritten replacement fragment.`,
      };
    }

    function applyAiSelectionRewrite(selectionContext, rewrittenFragment) {
      const context = selectionContext && typeof selectionContext === 'object' ? selectionContext : null;
      if (!context || !Number.isFinite(context.start) || !Number.isFinite(context.end) || context.end <= context.start) {
        throw new Error('Invalid selection range for rewrite.');
      }
      const workingYaml = String(context.workingYaml || getAiWorkingYaml());
      const replacement = sanitizeAiOutput(rewrittenFragment);
      if (!replacement) {
        throw new Error('Model returned an empty selection rewrite.');
      }
      if (context.start < 0 || context.end > workingYaml.length) {
        throw new Error('Selection range is out of bounds.');
      }
      return workingYaml.slice(0, context.start) + replacement + workingYaml.slice(context.end);
    }

    async function callProviderForAiVariant(promptRequest) {
      const provider = getAiProvider();
      const model = getAiModelValue();
      const apiKey = getAiApiKeyValue();
      const wantsWebSearch = !!aiWebSearch.checked;
      const systemPrompt = String(promptRequest?.systemPrompt || AI_DEFAULT_PROMPT);
      const userPrompt = String(promptRequest?.userPrompt || '');

      if (provider === 'openai') {
        const body = {
          model,
          input: [
            {
              role: 'system',
              content: [{ type: 'input_text', text: systemPrompt }],
            },
            {
              role: 'user',
              content: [{ type: 'input_text', text: userPrompt }],
            },
          ],
          temperature: 0.3,
        };
        if (wantsWebSearch) {
          body.tools = [{ type: 'web_search_preview' }];
        }
        const payload = await fetchProviderJson('https://api.openai.com/v1/responses', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(body),
        });
        return extractOpenAiResponsesText(payload);
      }

      if (provider === 'gemini') {
        const body = {
          contents: [{ role: 'user', parts: [{ text: `${systemPrompt}\n\n${userPrompt}` }] }],
          generationConfig: { temperature: 0.3 },
        };
        if (wantsWebSearch) {
          body.tools = [{ google_search: {} }];
        }
        const payload = await fetchProviderJson(
          `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
          },
        );
        return extractGeminiText(payload);
      }

      if (provider === 'openrouter') {
        const payload = await fetchProviderJson('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
            'HTTP-Referer': window.location.origin,
            'X-Title': 'Resume Compiler',
          },
          body: JSON.stringify({
            model,
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: userPrompt },
            ],
            temperature: 0.3,
          }),
        });
        return extractChatCompletionsText(payload);
      }

      if (provider === 'groq') {
        const payload = await fetchProviderJson('https://api.groq.com/openai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify({
            model,
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: userPrompt },
            ],
            temperature: 0.3,
          }),
        });
        return extractChatCompletionsText(payload);
      }

      if (provider === 'claude') {
        const payload = await fetchProviderJson('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true',
          },
          body: JSON.stringify({
            model,
            max_tokens: 4000,
            temperature: 0.3,
            system: systemPrompt,
            messages: [{ role: 'user', content: userPrompt }],
          }),
        });
        return extractClaudeText(payload);
      }

      throw new Error('Unsupported AI provider.');
    }

    function hasAiVerificationPayloadSignal(provider, payload) {
      if (!payload || typeof payload !== 'object') return false;
      if (provider === 'openai') {
        return typeof payload.id === 'string'
          || typeof payload.output_text === 'string'
          || Array.isArray(payload.output);
      }
      if (provider === 'gemini') {
        return Array.isArray(payload.candidates)
          || !!payload.promptFeedback;
      }
      if (provider === 'openrouter' || provider === 'groq') {
        return Array.isArray(payload.choices)
          || typeof payload.id === 'string';
      }
      if (provider === 'claude') {
        return Array.isArray(payload.content)
          || typeof payload.id === 'string';
      }
      return false;
    }

    async function callProviderForAiSettingsVerify() {
      const provider = getAiProvider();
      const model = getAiModelValue();
      const apiKey = getAiApiKeyValue();
      const systemPrompt = 'You are a connectivity check. Reply with OK.';
      const userPrompt = 'Reply with exactly OK.';

      if (provider === 'openai') {
        const payload = await fetchProviderJson('https://api.openai.com/v1/responses', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify({
            model,
            input: [
              {
                role: 'system',
                content: [{ type: 'input_text', text: systemPrompt }],
              },
              {
                role: 'user',
                content: [{ type: 'input_text', text: userPrompt }],
              },
            ],
            temperature: 0,
            max_output_tokens: 12,
          }),
        });
        return {
          provider,
          text: extractOpenAiResponsesText(payload),
          payload,
        };
      }

      if (provider === 'gemini') {
        const payload = await fetchProviderJson(
          `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              contents: [{ role: 'user', parts: [{ text: `${systemPrompt}\n\n${userPrompt}` }] }],
              generationConfig: { temperature: 0, maxOutputTokens: 12 },
            }),
          },
        );
        return {
          provider,
          text: extractGeminiText(payload),
          payload,
        };
      }

      if (provider === 'openrouter') {
        const payload = await fetchProviderJson('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
            'HTTP-Referer': window.location.origin,
            'X-Title': 'Resume Compiler',
          },
          body: JSON.stringify({
            model,
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: userPrompt },
            ],
            temperature: 0,
            max_tokens: 12,
          }),
        });
        return {
          provider,
          text: extractChatCompletionsText(payload),
          payload,
        };
      }

      if (provider === 'groq') {
        const payload = await fetchProviderJson('https://api.groq.com/openai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify({
            model,
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: userPrompt },
            ],
            temperature: 0,
            max_tokens: 12,
          }),
        });
        return {
          provider,
          text: extractChatCompletionsText(payload),
          payload,
        };
      }

      if (provider === 'claude') {
        const payload = await fetchProviderJson('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true',
          },
          body: JSON.stringify({
            model,
            max_tokens: 12,
            temperature: 0,
            system: systemPrompt,
            messages: [{ role: 'user', content: userPrompt }],
          }),
        });
        return {
          provider,
          text: extractClaudeText(payload),
          payload,
        };
      }

      throw new Error('Unsupported AI provider.');
    }

    async function verifyAiSettings() {
      if (!isAiConfigured()) {
        setAiSettingsVerified(false);
        setAiVerifyStatus('Set AI provider, model, and API key before verification.', 'error');
        setStatus('AI settings verification failed: missing provider/model/key.', 'error');
        return;
      }
      const requestId = ++aiVerifyRequestId;
      aiVerifyInFlight = true;
      updateAiActionButtons();
      setAiVerifyStatus('Verifying provider/model/key...');
      setStatus('Verifying AI settings...', 'compiling');
      try {
        const verificationResult = await callProviderForAiSettingsVerify();
        if (requestId !== aiVerifyRequestId) return;
        const normalized = sanitizeAiOutput(verificationResult && verificationResult.text);
        const verificationProvider = verificationResult && verificationResult.provider
          ? verificationResult.provider
          : getAiProvider();
        const providerHasSignal = hasAiVerificationPayloadSignal(
          verificationProvider,
          verificationResult && verificationResult.payload,
        );
        if (!normalized && !providerHasSignal) {
          throw new Error('Verification request succeeded but returned empty output.');
        }
        setAiSettingsVerified(true);
        const providerLabel = AI_PROVIDER_CONFIG[verificationProvider]?.label || verificationProvider;
        if (!normalized && providerHasSignal) {
          setAiVerifyStatus(`Verified ${providerLabel} settings (empty text response).`, 'success');
          setStatus('AI settings verified from successful provider response.', 'ready');
        } else {
          setAiVerifyStatus(`Verified ${providerLabel} settings.`, 'success');
          setStatus('AI settings verified. Resume AI controls unlocked.', 'ready');
        }
      } catch (err) {
        if (requestId !== aiVerifyRequestId) return;
        setAiSettingsVerified(false);
        setAiVerifyStatus(`Verification failed: ${err.message || err}`, 'error');
        setStatus(`AI verification failed: ${err.message || err}`, 'error');
      } finally {
        if (requestId === aiVerifyRequestId) {
          aiVerifyInFlight = false;
          updateAiActionButtons();
        }
      }
    }

    async function generateAiVariant(options = {}) {
      if (!isAiSettingsVerified()) {
        setAiStatus('Verify AI settings first, then generate a resume variant.', 'error');
        return;
      }
      if (!isAiConfigured()) {
        setAiStatus('Set AI provider, model, and key first (Resume YAML only).', 'error');
        return;
      }
      ensureAiOutputSeededFromOriginal({ persist: false });
      const selectedContext = options.selectionContext || getAiSelectionContext();
      if (!selectedContext) {
        setAiStatus('Select text in Variant view first.', 'error');
        hideAiSelectionPopover();
        return;
      }

      let promptRequest = null;
      try {
        promptRequest = buildAiSelectionPromptRequest(selectedContext, {
          promptOverride: options.selectionPromptOverride,
        });
      } catch (err) {
        setAiStatus(`AI generation setup failed: ${err.message || err}`, 'error');
        return;
      }
      const requestId = ++aiRequestId;
      aiInFlight = true;
      updateAiActionButtons();
      setAiStatus('Generating rewrite for selected block...');
      persistPreferences();

      try {
        const raw = await callProviderForAiVariant(promptRequest);
        if (requestId !== aiRequestId) return;
        const normalizedRaw = sanitizeAiOutput(raw);
        if (!normalizedRaw) {
          throw new Error('Model returned an empty response.');
        }
        const finalYaml = applyAiSelectionRewrite(selectedContext, normalizedRaw);
        setAiStatus('Selected block rewritten and applied to current AI output version.', 'success');
        hideAiSelectionPopover();
        setAiOutputValue(finalYaml);
      } catch (err) {
        if (requestId !== aiRequestId) return;
        setAiStatus(`AI generation failed: ${err.message || err}`, 'error');
      } finally {
        if (requestId === aiRequestId) {
          aiInFlight = false;
          updateAiActionButtons();
          persistPreferences();
        }
      }
    }

    function normalizeBibKey(raw) {
      const text = String(raw || '').trim();
      if (!text) return '';
      return text.replace(/[^A-Za-z0-9:_-]+/g, '');
    }

    function normalizeTitle(raw) {
      return String(raw || '')
        .toLowerCase()
        .replace(/[{}]/g, '')
        .replace(/[^a-z0-9]+/g, ' ')
        .trim();
    }

    function splitBibEntryTexts(text) {
      const input = String(text || '');
      const entries = [];
      let index = 0;

      while (index < input.length) {
        const at = input.indexOf('@', index);
        if (at < 0) break;
        const openBrace = input.indexOf('{', at);
        if (openBrace < 0) break;

        let depth = 0;
        let end = -1;
        for (let i = openBrace; i < input.length; i += 1) {
          const ch = input[i];
          if (ch === '{') depth += 1;
          if (ch === '}') {
            depth -= 1;
            if (depth === 0) {
              end = i + 1;
              break;
            }
          }
        }

        if (end < 0) break;
        const candidate = input.slice(at, end).trim();
        if (candidate) entries.push(candidate);
        index = end;
      }

      return entries;
    }

    function parseBibEntries(text) {
      return splitBibEntryTexts(text).map((entryText) => {
        const header = entryText.match(/^@([A-Za-z]+)\s*\{\s*([^,\s]+)\s*,/);
        const type = header ? String(header[1]).toLowerCase() : '';
        const key = normalizeBibKey(header ? header[2] : '');
        const titleMatch = entryText.match(/\btitle\s*=\s*(\{[\s\S]*?\}|\"[\s\S]*?\")\s*,?/i);
        const titleRaw = titleMatch ? titleMatch[1] : '';
        const title = normalizeTitle(titleRaw.replace(/^[{"]|[}"]$/g, ''));
        return { key, type, title, text: entryText };
      });
    }

    function getBibDuplicateStats(text) {
      const entries = parseBibEntries(text);
      const seenKeys = new Set();
      const seenTitles = new Set();
      let duplicateKeys = 0;
      let duplicateTitles = 0;

      entries.forEach((entry) => {
        if (entry.key) {
          if (seenKeys.has(entry.key)) duplicateKeys += 1;
          seenKeys.add(entry.key);
        }
        if (entry.title) {
          if (seenTitles.has(entry.title)) duplicateTitles += 1;
          seenTitles.add(entry.title);
        }
      });

      return { totalEntries: entries.length, duplicateKeys, duplicateTitles };
    }

    function updateBibHealthStatus(force = false) {
      const stats = getBibDuplicateStats(cmBib.getValue());
      const hasDupes = stats.duplicateKeys > 0 || stats.duplicateTitles > 0;
      btnBibClean.textContent = hasDupes ? 'Clean .bib*' : 'Clean .bib';
      if (activeTab !== 'bib' && !force) return;
      if (stats.totalEntries === 0) {
        setBibImportStatus('BibTeX tab is empty. Import by ID or paste entries manually.');
      } else if (hasDupes) {
        setBibImportStatus(
          `Detected overlap: ${stats.duplicateKeys} duplicate keys and ${stats.duplicateTitles} duplicate titles. Cleaning is recommended.`,
          'warning',
        );
      } else {
        setBibImportStatus(`Loaded ${stats.totalEntries} BibTeX entries. No obvious duplicates detected.`);
      }
    }

    function bibtexEsc(value) {
      return String(value || '')
        .replace(/[{}]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function slugifyBibToken(value) {
      return String(value || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '')
        .trim();
    }

    function inferBibType(paper = {}) {
      const venue = String(paper.venue || '').toLowerCase();
      const publicationTypes = Array.isArray(paper.publicationTypes) ? paper.publicationTypes.map((x) => String(x).toLowerCase()) : [];
      if (publicationTypes.some((x) => x.includes('journal'))) return 'article';
      if (publicationTypes.some((x) => x.includes('conference'))) return 'inproceedings';
      if (venue.includes('journal')) return 'article';
      if (venue.includes('conference') || venue.includes('symposium') || venue.includes('workshop')) return 'inproceedings';
      return 'misc';
    }

    function buildBibEntryFromPaper(paper, fallbackAuthorToken = 'author') {
      const title = bibtexEsc(paper.title || 'Untitled');
      const year = String(paper.year || '').match(/^\d{4}$/) ? String(paper.year) : 'n.d.';
      const authorNames = (Array.isArray(paper.authors) ? paper.authors : [])
        .map((author) => bibtexEsc(author?.name || ''))
        .filter(Boolean);
      const authors = authorNames.length > 0 ? authorNames.join(' and ') : fallbackAuthorToken;
      const firstAuthorToken = slugifyBibToken(authorNames[0] || fallbackAuthorToken) || 'author';
      const titleToken = slugifyBibToken(title).slice(0, 24) || 'paper';
      const key = normalizeBibKey(`${firstAuthorToken}${year}${titleToken}`);
      const venue = bibtexEsc(paper.venue || '');
      const urlCandidate = paper.url || (paper.externalIds?.DOI ? `https://doi.org/${paper.externalIds.DOI}` : '');
      const url = bibtexEsc(urlCandidate);
      const type = inferBibType(paper);
      const venueField = type === 'article' ? 'journal' : 'booktitle';
      const lines = [
        `@${type}{${key},`,
        `  title={${title}},`,
        `  author={${authors}},`,
      ];
      if (/^\d{4}$/.test(year)) {
        lines.push(`  year={${year}},`);
      }
      if (venue) {
        lines.push(`  ${venueField}={${venue}},`);
      }
      if (url) {
        lines.push(`  url={${url}},`);
      }
      lines.push('}');
      return lines.join('\n');
    }

    function extractIdFromUrl(value, pathToken) {
      const raw = String(value || '').trim();
      if (!raw) return '';
      if (!/^https?:\/\//i.test(raw)) return raw;
      try {
        const parsed = new URL(raw);
        if (pathToken === 'dblp') {
          const parts = parsed.pathname.split('/').filter(Boolean);
          const pidIndex = parts.findIndex((part) => part === 'pid');
          if (pidIndex >= 0 && parts[pidIndex + 1]) {
            return decodeURIComponent(parts.slice(pidIndex + 1).join('/').replace(/\.html$|\.bib$/i, ''));
          }
          return decodeURIComponent(parts.join('/').replace(/\.html$|\.bib$/i, ''));
        }
        if (pathToken === 'semantic') {
          const parts = parsed.pathname.split('/').filter(Boolean);
          const authorIdx = parts.findIndex((part) => part === 'author');
          if (authorIdx >= 0 && parts[authorIdx + 1]) {
            return decodeURIComponent(parts.at(-1));
          }
          return decodeURIComponent(parts.at(-1) || '');
        }
        if (pathToken === 'google') {
          return parsed.searchParams.get('user') || decodeURIComponent(parsed.pathname.split('/').filter(Boolean).at(-1) || '');
        }
      } catch (err) {
        return raw;
      }
      return raw;
    }

    async function fetchJson(url) {
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`Request failed (${resp.status}) for ${url}`);
      }
      return resp.json();
    }

    async function fetchTextContent(url) {
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`Request failed (${resp.status}) for ${url}`);
      }
      return resp.text();
    }

    async function importDblpBib(rawId) {
      const dblpId = extractIdFromUrl(rawId, 'dblp').replace(/^pid\//i, '').trim();
      if (!dblpId) throw new Error('Enter a valid DBLP author ID.');
      const encodedId = dblpId.split('/').filter(Boolean).map((part) => encodeURIComponent(part)).join('/');
      const bibUrl = `https://dblp.org/pid/${encodedId}.bib`;
      const bibText = await fetchTextContent(bibUrl);
      if (!/@[A-Za-z]+\s*\{/.test(bibText)) {
        throw new Error('DBLP did not return valid BibTeX entries for this ID.');
      }
      return bibText.trim();
    }

    async function fetchSemanticScholarPapers(authorId) {
      const out = [];
      let offset = 0;
      const limit = 100;
      const maxPapers = 1000;
      while (out.length < maxPapers) {
        const fields = 'title,year,venue,url,authors,publicationTypes,externalIds';
        const url = `https://api.semanticscholar.org/graph/v1/author/${encodeURIComponent(authorId)}/papers?offset=${offset}&limit=${limit}&fields=${fields}`;
        const payload = await fetchJson(url);
        const papers = Array.isArray(payload?.data) ? payload.data : [];
        if (papers.length === 0) break;
        out.push(...papers);
        if (papers.length < limit) break;
        offset += papers.length;
      }
      return out;
    }

    async function importSemanticScholarBib(rawId, fallbackAuthorName = 'Author') {
      const semanticId = extractIdFromUrl(rawId, 'semantic').trim();
      if (!semanticId) throw new Error('Enter a valid Semantic Scholar author ID.');
      const papers = await fetchSemanticScholarPapers(semanticId);
      if (!papers.length) throw new Error('No Semantic Scholar papers found for this author ID.');
      const entries = papers
        .filter((paper) => paper && paper.title)
        .map((paper) => buildBibEntryFromPaper(paper, fallbackAuthorName));
      return entries.join('\n\n');
    }

    async function importGoogleScholarBib(rawId) {
      const scholarId = extractIdFromUrl(rawId, 'google').trim();
      if (!scholarId) throw new Error('Enter a valid Google Scholar profile ID (user=...).');
      const scholarUrl = `${GOOGLE_PROXY_PREFIX}http://scholar.google.com/citations?hl=en&user=${encodeURIComponent(scholarId)}`;
      const profileText = await fetchTextContent(scholarUrl);
      const nameMatch = profileText.match(/Title:\s*([^\n]+?)\s*-\s*Google Scholar/i)
        || profileText.match(/<title>\s*([^<]+?)\s*-\s*Google Scholar/i);
      const scholarName = nameMatch ? nameMatch[1].trim() : '';
      if (!scholarName) {
        throw new Error('Could not resolve a Scholar profile name from this ID.');
      }
      const searchUrl = `https://api.semanticscholar.org/graph/v1/author/search?query=${encodeURIComponent(scholarName)}&limit=5&fields=authorId,name,paperCount`;
      const payload = await fetchJson(searchUrl);
      const candidates = Array.isArray(payload?.data) ? payload.data : [];
      if (candidates.length === 0) {
        throw new Error('Scholar profile found, but no matching Semantic Scholar author was found.');
      }
      const normalizedTarget = scholarName.toLowerCase().replace(/\s+/g, ' ').trim();
      const best = candidates.find((candidate) => String(candidate?.name || '').toLowerCase().trim() === normalizedTarget)
        || candidates.sort((a, b) => (b?.paperCount || 0) - (a?.paperCount || 0))[0];
      if (!best?.authorId) {
        throw new Error('Scholar profile found, but no usable author ID match was found.');
      }
      return importSemanticScholarBib(best.authorId, scholarName);
    }

    function mergeBibContent(existingBib, incomingBib, replaceAll = false) {
      const incomingEntries = parseBibEntries(incomingBib);
      if (replaceAll) {
        return {
          mergedBib: incomingEntries.map((entry) => entry.text).join('\n\n').trim(),
          imported: incomingEntries.length,
          skippedByKey: 0,
          skippedByTitle: 0,
        };
      }

      const existingEntries = parseBibEntries(existingBib);
      const seenKeys = new Set(existingEntries.map((entry) => entry.key).filter(Boolean));
      const seenTitles = new Set(existingEntries.map((entry) => entry.title).filter(Boolean));
      let skippedByKey = 0;
      let skippedByTitle = 0;
      const accepted = [];

      incomingEntries.forEach((entry) => {
        const keyDup = entry.key && seenKeys.has(entry.key);
        const titleDup = entry.title && seenTitles.has(entry.title);
        if (keyDup || titleDup) {
          if (keyDup) skippedByKey += 1;
          if (titleDup) skippedByTitle += 1;
          return;
        }
        accepted.push(entry.text);
        if (entry.key) seenKeys.add(entry.key);
        if (entry.title) seenTitles.add(entry.title);
      });

      const existingTrimmed = String(existingBib || '').trim();
      const mergedBib = [existingTrimmed, ...accepted].filter(Boolean).join('\n\n').trim();
      return {
        mergedBib,
        imported: accepted.length,
        skippedByKey,
        skippedByTitle,
      };
    }

    function downloadTextFile(content, filename, mimeType = 'text/plain;charset=utf-8') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);
    }

    function simpleBibCleanup(bibText) {
      const entries = parseBibEntries(bibText).map((entry) => entry.text);
      if (entries.length === 0) return String(bibText || '').trim();
      return entries.join('\n\n').trim() + '\n';
    }

    async function loadBibtexTidyApi() {
      if (!bibtexTidyModulePromise) {
        bibtexTidyModulePromise = import('https://cdn.skypack.dev/bibtex-tidy').catch(() => null);
      }
      const mod = await bibtexTidyModulePromise;
      if (!mod) return null;
      if (typeof mod.tidy === 'function') return mod.tidy;
      if (mod.default && typeof mod.default.tidy === 'function') return mod.default.tidy;
      if (typeof mod.default === 'function') return mod.default;
      return null;
    }

    async function cleanBibEditorContent() {
      const source = cmBib.getValue();
      if (!source.trim()) {
        setBibImportStatus('BibTeX is empty. Add entries before cleaning.');
        return;
      }
      btnBibClean.disabled = true;
      setBibImportStatus('Cleaning BibTeX...');
      try {
        const tidyFn = await loadBibtexTidyApi();
        let cleaned = source;
        if (tidyFn) {
          try {
            const maybeClean = tidyFn(source);
            cleaned = typeof maybeClean === 'string' ? maybeClean : source;
          } catch (err) {
            cleaned = source;
          }
        }
        if (!cleaned || typeof cleaned !== 'string') {
          cleaned = source;
        }
        cleaned = simpleBibCleanup(cleaned);
        setEditorContent('bib', cleaned);
        setBibImportStatus('BibTeX cleaned and normalized. You can now download the file.');
      } catch (err) {
        setEditorContent('bib', simpleBibCleanup(source));
        setBibImportStatus('Cleaned with fallback formatter (external tidy API unavailable).', 'warning');
      } finally {
        btnBibClean.disabled = false;
        updateBibHealthStatus(true);
      }
    }

    async function runBibImport(replaceAll = false) {
      const provider = bibImportProvider.value;
      const rawId = bibImportId.value.trim();
      if (!rawId) {
        setBibImportStatus('Enter an ID before importing.', 'warning');
        bibImportId.focus();
        return;
      }
      btnBibImport.disabled = true;
      btnBibImportReplace.disabled = true;
      setBibImportStatus(`Fetching entries from ${provider}...`);
      try {
        let importedBib = '';
        if (provider === 'dblp') {
          importedBib = await importDblpBib(rawId);
        } else if (provider === 'semantic') {
          importedBib = await importSemanticScholarBib(rawId);
        } else if (provider === 'google') {
          importedBib = await importGoogleScholarBib(rawId);
        } else {
          throw new Error('Unsupported provider.');
        }

        const existing = cmBib.getValue();
        const merged = mergeBibContent(existing, importedBib, replaceAll);
        if (!merged.mergedBib) {
          throw new Error('No valid BibTeX entries were parsed from the import result.');
        }
        setEditorContent('bib', `${merged.mergedBib}\n`);
        if (replaceAll) {
          setBibImportStatus(`Imported and replaced with ${merged.imported} entries from ${provider}.`);
        } else {
          const overlap = merged.skippedByKey + merged.skippedByTitle;
          if (overlap > 0) {
            setBibImportStatus(
              `Imported ${merged.imported} new entries (${overlap} overlapping entries skipped). Cleaning is recommended.`,
              'warning',
            );
          } else {
            setBibImportStatus(`Imported ${merged.imported} new entries from ${provider}.`);
          }
        }
      } catch (err) {
        const message = err && err.message ? err.message : String(err);
        setBibImportStatus(`Import failed: ${message}`, 'warning');
      } finally {
        btnBibImport.disabled = false;
        btnBibImportReplace.disabled = false;
        updateBibHealthStatus(true);
      }
    }

    btnBibClean.addEventListener('click', cleanBibEditorContent);
    btnBibDownload.addEventListener('click', () => {
      downloadTextFile(cmBib.getValue(), 'publications.bib', 'application/x-bibtex;charset=utf-8');
      setBibImportStatus('Downloaded current BibTeX as publications.bib.');
    });
    btnBibImport.addEventListener('click', () => runBibImport(false));
    btnBibImportReplace.addEventListener('click', async () => {
      const accepted = await openConfirmDialog({
        title: 'Replace current BibTeX?',
        message: 'This will replace the current BibTeX tab with imported entries.',
        confirmText: 'Replace',
        cancelText: 'Cancel',
        destructive: true,
      });
      if (!accepted) return;
      runBibImport(true);
    });
    bibImportId.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        runBibImport(false);
      }
    });
    bibImportProvider.addEventListener('change', () => {
      updateBibImportPlaceholder();
      setBibImportStatus('Provider changed. Enter an author ID and import.');
    });

    function scheduleCompile() {
      if (compileTimeout) clearTimeout(compileTimeout);
      if (getCompileMode() === 'manual') {
        hasPendingManualChanges = true;
        updateCompileControlsUI();
        if (ready) {
          setStatus('Manual mode: changes pending. Click compile.', 'pending');
        }
        return;
      }
      hasPendingManualChanges = false;
      updateCompileControlsUI();
      compileTimeout = setTimeout(compile, 600);
    }

    function compileAfterResumeSourceToggle() {
      if (getCompileMode() === 'auto') {
        if (compileTimeout) {
          clearTimeout(compileTimeout);
          compileTimeout = null;
        }
        hasPendingManualChanges = false;
        updateCompileControlsUI();
        if (ready) {
          compile();
          return;
        }
      }
      scheduleCompile();
    }

    cmResume.on('change', () => {
      if (!suppressHistoryTracking) {
        markResumeCustomized(true);
      }
      renderAiDiffView();
      scheduleEditorHistorySnapshot('resume');
      scheduleCompile();
    });
    cmConfig.on('change', () => {
      scheduleEditorHistorySnapshot('config');
      if (getActiveConfigEditorKey() === 'config') {
        syncConfigControlsFromActiveConfig();
      }
      scheduleCompile();
    });
    cmConfigShort.on('change', () => {
      scheduleEditorHistorySnapshot('config-short');
      if (getActiveConfigEditorKey() === 'config-short') {
        syncConfigControlsFromActiveConfig();
      }
      scheduleCompile();
    });
    cmBib.on('change', () => {
      scheduleEditorHistorySnapshot('bib');
      scheduleCompile();
      updateBibHealthStatus();
    });
    cmAiOutput.on('change', () => {
      if (suppressAiOutputChangeHandler) return;
      renderAiDiffView();
      updateAiActionButtons();
      persistPreferences();
      if (getResumeCompileSource() === 'generated') {
        scheduleCompile();
      }
    });
    cmAiOutput.on('cursorActivity', () => {
      updateAiActionButtons();
    });
    cmAiOutput.on('scroll', () => {
      if (isAiSelectionPopoverOpen()) {
        syncAiSelectionPopover();
      }
    });
    const aiOutputWrapper = cmAiOutput.getWrapperElement();
    if (aiOutputWrapper) {
      ['mouseup', 'keyup'].forEach((eventName) => {
        aiOutputWrapper.addEventListener(eventName, () => {
          window.setTimeout(() => updateAiActionButtons(), 0);
        });
      });
    }
    document.addEventListener('selectionchange', () => {
      const aiVariantActive = activeTab === 'resume'
        && getResumeEditorView() === 'ai'
        && getAiOutputViewMode() === 'variant';
      if (!aiVariantActive) return;
      window.setTimeout(() => updateAiActionButtons(), 0);
    });
    if (aiDiffOverview) {
      aiDiffOverview.addEventListener('click', (event) => {
        const target = event.target instanceof Element
          ? event.target.closest('.ai-diff-overview-marker')
          : null;
        if (!target) return;
        const startLine = Number(target.getAttribute('data-start-line'));
        if (!Number.isFinite(startLine)) return;
        scrollAiDiffToLine(startLine, { behavior: 'smooth' });
      });
      aiDiffOverview.addEventListener('keydown', (event) => {
        if (event.key !== 'Enter' && event.key !== ' ') return;
        const target = event.target instanceof Element
          ? event.target.closest('.ai-diff-overview-marker')
          : null;
        if (!target) return;
        event.preventDefault();
        const startLine = Number(target.getAttribute('data-start-line'));
        if (!Number.isFinite(startLine)) return;
        scrollAiDiffToLine(startLine, { behavior: 'smooth' });
      });
    }

    function formatLastUpdatedDate(dateObj = new Date()) {
      return dateObj.toLocaleDateString('en-US', {
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });
    }

    function detectPaperSize(configText) {
      const m = configText.match(/^\s*paper_size\s*:\s*["']?([A-Za-z-]+)["']?\s*$/m);
      if (!m) return 'letter';
      return m[1].toLowerCase() === 'a4' ? 'a4' : 'letter';
    }

    function normalizeMode(mode) {
      return String(mode || 'default')
        .toLowerCase()
        .trim()
        .replace(/_/g, '-')
        .replace(/\s+/g, '');
    }

    function modeHas(mode, token) {
      const parts = normalizeMode(mode).split('+').filter(Boolean);
      return parts.includes(token);
    }

    function modeUsesShort(mode) {
      return modeHas(mode, 'short');
    }

    function modeUsesBib(mode) {
      return modeHas(mode, 'bibtex');
    }

    function modeDisablesLinks(mode) {
      return modeHas(mode, 'no-js');
    }

    function modeToControlValues(mode) {
      const normalized = normalizeMode(mode);
      return {
        variant: modeUsesShort(normalized) ? 'short' : 'default',
        source: modeUsesBib(normalized) ? 'bibtex' : 'resume',
        linkMode: modeDisablesLinks(normalized) ? 'no-js' : 'links',
      };
    }

    function setSelectValue(select, nextValue, fallbackValue) {
      const values = Array.from(select.options).map((option) => option.value);
      if (values.includes(nextValue)) {
        select.value = nextValue;
      } else {
        select.value = fallbackValue;
      }
    }

    function escapeTypstString(value) {
      return String(value).replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    }

    function clearSavedState() {
      LS_KEYS.forEach(key => localStorage.removeItem(key));
    }

    function getSelectedMode() {
      const parts = [];
      if (getModeLinkMode() === 'no-js') parts.push('no-js');
      if (getModeSource() === 'bibtex') parts.push('bibtex');
      if (getModeVariant() === 'short') parts.push('short');
      if (parts.length === 0) return 'default';
      return parts.join('+');
    }

    function getRuntimeOverridesObject() {
      const overrides = {
        last_updated: formatLastUpdatedDate(),
        paper_size: paperSize.value,
      };

      overrides.variant = getModeVariant() === 'short' ? 'short' : 'long';
      if (getModeLinkMode() === 'no-js') {
        overrides.enable_links = false;
      }

      return overrides;
    }

    function overridesToTypstDict(overrides) {
      const parts = [];
      Object.entries(overrides).forEach(([key, value]) => {
        if (typeof value === 'boolean') {
          parts.push(`${key}: ${value ? 'true' : 'false'}`);
        } else {
          parts.push(`${key}: "${escapeTypstString(value)}"`);
        }
      });
      return `(${parts.join(', ')})`;
    }

    function getResumeTypSource(options = {}) {
      const forDownload = !!options.forDownload;
      const paths = forDownload
        ? {
          template: 'template.typ',
          resume: 'resume.yml',
          bibResume: 'resume.yml',
          configLong: 'config.yml',
          configShort: 'config-short.yml',
          bib: 'publications.bib',
        }
        : {
          template: '/template.typ',
          resume: '/resume.yml',
          bibResume: '/resume.yml',
          configLong: '/config.yml',
          configShort: '/config-short.yml',
          bib: '/publications.bib',
        };
      const runtimeOverrides = overridesToTypstDict(getRuntimeOverridesObject());
      const selectedMode = escapeTypstString(getSelectedMode());
      return `#import "${paths.template}": build_resume

#let normalize_mode(mode) = {
  lower(str(mode).trim())
    .replace(" ", "")
    .replace("_", "")
    .replace("-", "")
    .replace("+", "")
}

#let build_resume_by_mode(
  mode: "default",
  runtime_overrides: (:),
  resume_file: "${paths.resume}",
  bib_resume_file: "${paths.bibResume}",
  config_long_file: "${paths.configLong}",
  config_short_file: "${paths.configShort}",
  bib_file: "${paths.bib}",
) = {
  let m = normalize_mode(mode)
  let use_short = m.contains("short")
  let use_bib = m.contains("bibtex")
  let use_no_js = m.contains("nojs")

  let config_file = if use_short { config_short_file } else { config_long_file }
  let active_resume_file = if use_bib { bib_resume_file } else { resume_file }
  let resume_data = yaml(active_resume_file)
  let overrides = runtime_overrides

  if use_no_js {
    overrides.insert("enable_links", false)
  }

  if use_bib {
    build_resume(resume_data, overrides, config_file: config_file, bib_file: bib_file)
  } else {
    build_resume(resume_data, overrides, config_file: config_file)
  }
}

#let runtime_overrides = ${runtimeOverrides}
#let selected_mode = "${selectedMode}"
#build_resume_by_mode(mode: selected_mode, runtime_overrides: runtime_overrides)`;
    }

    function getMainContent() {
      return `#include "/resume.typ"`;
    }

    async function registerTypstSources() {
      const bibContent = cmBib.getValue();
      const resumeForCompile = getResumeContentForCompile();
      await $typst.addSource('/template.typ', templateContent);
      await $typst.addSource('/resume.yml', resumeForCompile);
      await $typst.addSource('/resume.typ', getResumeTypSource({ forDownload: false }));
      await $typst.addSource('/config.yml', cmConfig.getValue());
      await $typst.addSource('/config-short.yml', cmConfigShort.getValue());
      for (const bibPath of BIB_SOURCE_ALIASES) {
        await $typst.addSource(bibPath, bibContent);
      }
    }

    function modeOutputSuffix(mode) {
      const m = normalizeMode(mode);
      const noJs = modeDisablesLinks(m);
      const bib = modeUsesBib(m);
      const short = modeUsesShort(m);
      if (noJs && bib && short) return '_NBS';
      if (noJs && bib) return '_NB';
      if (noJs && short) return '_NS';
      if (noJs) return '_N';
      if (bib && short) return '_BS';
      if (bib) return '_B';
      if (short) return '_S';
      return '';
    }

    function deriveResumeFilename(resumeYamlText, mode) {
      const lines = resumeYamlText.split(/\r?\n/);
      let inPersonal = false;
      let fullName = '';
      for (const line of lines) {
        if (!inPersonal && /^\s*personal:\s*$/.test(line)) {
          inPersonal = true;
          continue;
        }
        if (inPersonal && /^[^\s#]/.test(line)) break;
        if (inPersonal) {
          const m = line.match(/^\s{2}name:\s*["']?([^"'\n]+)["']?\s*$/);
          if (m) {
            fullName = m[1].trim();
            break;
          }
        }
      }

      const variantSuffix = modeOutputSuffix(mode);
      if (!fullName) return `Resume${variantSuffix}.pdf`;
      const tokens = fullName.split(/\s+/).filter(Boolean);
      if (tokens.length === 0) return `Resume${variantSuffix}.pdf`;
      const first = tokens[0];
      const last = tokens.length > 1 ? tokens[tokens.length - 1] : '';
      const compact = `${first}${last}`.replace(/[^A-Za-z0-9]/g, '');
      if (!compact) return `Resume${variantSuffix}.pdf`;
      return `${compact}_Resume${variantSuffix}.pdf`;
    }

    async function compile() {
      if (!ready) return;
      Object.keys(editors).forEach((key) => flushEditorHistoryTimer(key));
      if (compileTimeout) {
        clearTimeout(compileTimeout);
        compileTimeout = null;
      }
      const requestId = ++compileRequestId;
      const hadPendingManualChanges = hasPendingManualChanges;
      hasPendingManualChanges = false;
      updateCompileControlsUI();

      setStatus('Compiling...', 'compiling');
      showPreviewFeedback('Compiling changes...');

      try {
        await registerTypstSources();

        const mainContent = getMainContent();
        const result = await $typst.svg({ mainContent });

        if (requestId !== compileRequestId) return;

        previewPages.innerHTML = '';

        if (typeof result === 'string') {
          const page = document.createElement('div');
          page.className = 'page';
          page.innerHTML = result;
          previewPages.appendChild(page);
        } else if (Array.isArray(result)) {
          result.forEach(pageSvg => {
            const page = document.createElement('div');
            page.className = 'page';
            page.innerHTML = pageSvg;
            previewPages.appendChild(page);
          });
        }

        localStorage.setItem(LS_RESUME, cmResume.getValue());
        localStorage.setItem(LS_CONFIG, cmConfig.getValue());
        localStorage.setItem(LS_CONFIG_SHORT, cmConfigShort.getValue());
        localStorage.setItem(LS_BIB, cmBib.getValue());
        persistPreferences();

        hidePreviewFeedback();
        hasPendingManualChanges = false;
        updateCompileControlsUI();
        setStatus('Ready', 'ready');
      } catch (err) {
        if (requestId !== compileRequestId) return;
        if (getCompileMode() === 'manual' || hadPendingManualChanges) {
          hasPendingManualChanges = true;
          updateCompileControlsUI();
        }
        showPreviewFeedback('Compilation failed. Fix the error and keep typing.', true);
        setStatus('Error: ' + err.message, 'error');
      }
    }

    btnDownload.addEventListener('click', async () => {
      if (!ready) return;
      btnDownload.disabled = true;
      setStatus('Generating PDF...', 'compiling');

      try {
        await registerTypstSources();

        const mainContent = getMainContent();
        const pdfData = await $typst.pdf({ mainContent });
        const blob = new Blob([pdfData], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = deriveResumeFilename(getResumeContentForCompile(), getSelectedMode());
        a.click();
        URL.revokeObjectURL(url);
        setStatus('Ready', 'ready');
      } catch (err) {
        setStatus('PDF error: ' + err.message, 'error');
      } finally {
        btnDownload.disabled = false;
      }
    });

    btnDownloadTyp.addEventListener('click', () => {
      const typSource = getResumeTypSource({ forDownload: true });
      const blob = new Blob([typSource], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'resume.typ';
      a.click();
      URL.revokeObjectURL(url);
    });

    btnReset.addEventListener('click', async () => {
      const accepted = await openConfirmDialog({
        title: 'Reset all editors?',
        message: 'This will clear local edits in this browser and reload defaults.',
        confirmText: 'Reset',
        cancelText: 'Cancel',
        destructive: true,
      });
      if (!accepted) return;
      clearSavedState();
      location.reload();
    });

    paperSize.addEventListener('change', () => {
      persistPreferences();
      scheduleCompile();
    });
    const onCompileModeChange = () => {
      persistPreferences();
      if (getCompileMode() === 'manual') {
        if (compileTimeout) {
          clearTimeout(compileTimeout);
          compileTimeout = null;
        }
        updateCompileControlsUI();
        if (ready) {
          setStatus(
            hasPendingManualChanges
              ? 'Manual mode: changes pending. Click compile.'
              : 'Manual mode enabled.',
            hasPendingManualChanges ? 'pending' : '',
          );
        }
        return;
      }

      if (hasPendingManualChanges) {
        hasPendingManualChanges = false;
        updateCompileControlsUI();
        scheduleCompile();
      } else {
        updateCompileControlsUI();
        if (ready) setStatus('Auto compile enabled.', '');
      }
    };
    compileModeInputs.forEach((input) => input.addEventListener('change', onCompileModeChange));

    const onModeControlChange = () => {
      updateTabVisibility();
      syncConfigControlsFromActiveConfig();
      lastSourceSelection = getModeSource();
      persistPreferences();
      scheduleCompile();
    };
    let lastSourceSelection = getModeSource();
    overrideVariant.addEventListener('change', () => {
      onModeControlChange();
    });
    overrideSource.addEventListener('change', async () => {
      const previousSource = lastSourceSelection;
      const nextSource = getModeSource();
      if (previousSource === nextSource) return;

      if (
        previousSource === 'bibtex'
        && nextSource === 'resume'
        && resumeHasBibtexLinkedEntries(cmResume.getValue())
      ) {
        const accepted = await openConfirmDialog({
          title: 'Switch to YAML Publications Source?',
          message: 'Your resume has BibTeX-linked entries (`bib_key`). In non-BibTeX mode those entries will be ignored. Continue?',
          confirmText: 'Switch Source',
          cancelText: 'Stay in BibTeX',
          destructive: false,
        });
        if (!accepted) {
          setModeSource(previousSource);
          refreshCustomSelects();
          return;
        }
      }

      maybeApplyDefaultResumeForSource(nextSource);
      onModeControlChange();
    });
    overrideLinkMode.addEventListener('change', onModeControlChange);
    btnCompileNow.addEventListener('click', () => compile());
    btnUndo.addEventListener('click', () => performEditorUndo());
    btnRedo.addEventListener('click', () => performEditorRedo());
    const onConfigBackedOverrideChange = (controlName) => {
      updateActiveConfigFromControls(controlName);
      persistPreferences();
    };
    overrideLinksDisabledBehavior.addEventListener('change', () => onConfigBackedOverrideChange('links_disabled_behavior'));
    overridePubnums.addEventListener('change', () => onConfigBackedOverrideChange('show_publication_numbers'));
    overrideContact.addEventListener('change', () => onConfigBackedOverrideChange('contact_display_mode'));
    overrideFont.addEventListener('change', () => onConfigBackedOverrideChange('font'));
    overrideMonoFont.addEventListener('change', () => onConfigBackedOverrideChange('mono_font'));

    btnShare.addEventListener('click', (event) => {
      event.preventDefault();
      if (!hasAnyShareableKey()) {
        copyShareFromMenu(false);
        return;
      }
      setShareMenuOpen(!shareMenu.classList.contains('open'));
    });
    btnShare.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowDown' || event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        if (!hasAnyShareableKey()) {
          copyShareFromMenu(false);
          return;
        }
        setShareMenuOpen(true);
        btnShareWithoutKey.focus();
      }
    });
    btnShareWithoutKey.addEventListener('click', () => copyShareFromMenu(false));
    btnShareWithKey.addEventListener('click', () => copyShareFromMenu(true));
    btnSettings.addEventListener('click', () => {
      if (window.innerWidth <= DESKTOP_SPLIT_BREAKPOINT && getMobileView() === 'preview') {
        setMobileView('editor');
      }
      setSettingsFlyoutOpen(!settingsFlyout.classList.contains('open'));
    });
    btnSettingsClose.addEventListener('click', () => setSettingsFlyoutOpen(false));
    settingsScrim.addEventListener('click', () => setSettingsFlyoutOpen(false));
    btnOpenAiSettings.addEventListener('click', (event) => {
      event.preventDefault();
      event.stopPropagation();
      setDetailsOpen(panelAiSettings, true);
      if (window.innerWidth <= DESKTOP_SPLIT_BREAKPOINT && getMobileView() === 'preview') {
        setMobileView('editor');
      }
      window.setTimeout(() => {
        setSettingsFlyoutOpen(true);
        persistPreferences();
      }, 0);
    });

    panelOverrides.addEventListener('toggle', () => {
      persistPreferences();
      refreshAllEditors();
    });
    panelAiSettings.addEventListener('toggle', () => {
      persistPreferences();
      refreshAllEditors();
    });
    panelIntegrations.addEventListener('toggle', () => {
      persistPreferences();
      refreshAllEditors();
    });
    aiJdPanel.addEventListener('toggle', () => {
      persistPreferences();
      refreshAllEditors();
    });
    aiOutputViewInputs.forEach((input) => {
      input.addEventListener('change', () => {
        setAiOutputViewMode(input.value);
        renderAiDiffView();
        updateAiActionButtons();
      });
    });
    btnResumeViewOriginal.addEventListener('click', () => {
      setResumeEditorView('original');
      refreshAllEditors();
    });
    btnResumeViewAi.addEventListener('click', () => {
      setResumeEditorView('ai');
      if (!isAiSettingsVerified()) {
        setAiStatus(AI_UNVERIFIED_TAB_MESSAGE, 'error');
        refreshAllEditors();
        return;
      }
      if (!hasGeneratedAiOutput()) {
        setAiStatus('Set up and verify AI settings to generate resume variants.', 'error');
      }
      refreshAllEditors();
    });

    resumeUseGenerated.addEventListener('change', () => {
      if (resumeUseGenerated.checked && !isAiSettingsVerified()) {
        setResumeCompileSource('original', { persist: true, triggerCompile: true });
        setAiStatus('Verify AI settings before enabling AI variant compile.', 'error');
        return;
      }
      if (resumeUseGenerated.checked && !String(getAiOutputValue() || '').trim()) {
        setResumeCompileSource('original', { persist: true, triggerCompile: true });
        setAiStatus('Generate a variant first before enabling AI variant compile.', 'error');
        return;
      }
      setResumeCompileSource(resumeUseGenerated.checked ? 'generated' : 'original', { persist: true, triggerCompile: true });
      if (resumeUseGenerated.checked) {
        setAiStatus('AI variant resume enabled for compile/PDF. Original resume.yml remains unchanged.', 'success');
      } else if (!aiInFlight) {
        setAiStatus('Using original resume.yml for compile/PDF.', '');
      }
    });

    const onAiSettingsChanged = (options = {}) => {
      const invalidateVerification = options.invalidateVerification === true;
      if (invalidateVerification && isAiSettingsVerified()) {
        setAiSettingsVerified(false, { persist: false });
      }
      ensureAiModelForProvider(false);
      updateShareMenuVisibility();
      updateAiActionButtons();
      if (!aiVerifyInFlight) {
        setAiVerifyStatus('Settings changed. Click Verify AI Settings.');
      }
      if (!isAiConfigured() && !aiInFlight) {
        setAiStatus('Set AI provider + key to generate resume variants from Resume YAML.');
      }
      persistPreferences();
    };
    aiProvider.addEventListener('change', () => {
      ensureAiModelForProvider(true);
      onAiSettingsChanged({ invalidateVerification: true });
      const provider = getAiProvider();
      if (provider !== 'disabled' && aiWebSearch.checked && provider !== 'openai' && provider !== 'gemini') {
        setAiStatus('Use a web-enabled model for this provider; native web-search wiring is direct for OpenAI/Gemini.');
      }
    });
    aiModel.addEventListener('input', () => onAiSettingsChanged({ invalidateVerification: true }));
    aiApiKey.addEventListener('input', () => onAiSettingsChanged({ invalidateVerification: true }));
    githubToken.addEventListener('input', () => {
      setGithubTokenVerified(false, { persist: false });
      if (getGithubTokenValue()) {
        setGithubVerifyStatus('Token changed. Click Verify GitHub Token.');
      }
      persistPreferences();
      updateUploadGistButtonState();
    });
    btnGithubVerify.addEventListener('click', () => {
      verifyGithubToken();
    });
    aiWebSearch.addEventListener('change', () => {
      onAiSettingsChanged();
      const provider = getAiProvider();
      if (provider !== 'disabled' && aiWebSearch.checked && provider !== 'openai' && provider !== 'gemini') {
        setAiStatus('Use a web-enabled model for this provider; native web-search wiring is direct for OpenAI/Gemini.');
      }
    });
    aiUserPrompt.addEventListener('input', () => {
      persistPreferences();
    });
    aiJobDescription.addEventListener('input', () => {
      persistPreferences();
    });
    if (aiSelectionPrompt) {
      aiSelectionPrompt.addEventListener('input', () => {
        persistPreferences();
      });
    }
    if (aiSelectionPopover && USE_NATIVE_POPOVER) {
      aiSelectionPopover.addEventListener('toggle', (event) => {
        const newState = typeof event.newState === 'string'
          ? event.newState
          : (isAiSelectionPopoverOpen() ? 'open' : 'closed');
        if (newState !== 'closed') return;
        aiSelectionPopover.classList.add('hidden');
        if (aiSelectionAnchor) aiSelectionAnchor.classList.add('hidden');
        aiSelectionContext = null;
      });
    }

    if (btnAiSelectionGenerate) {
      btnAiSelectionGenerate.addEventListener('click', () => {
        const context = aiSelectionContext || getAiSelectionContext();
        if (!context) {
          setAiStatus('Select text in Variant view first.', 'error');
          hideAiSelectionPopover();
          return;
        }
        generateAiVariant({
          selectionContext: context,
          selectionPromptOverride: aiSelectionPrompt ? aiSelectionPrompt.value : '',
        });
      });
    }
    if (btnAiSelectionDismiss) {
      btnAiSelectionDismiss.addEventListener('click', () => {
        hideAiSelectionPopover();
      });
    }
    btnAiVerify.addEventListener('click', () => {
      verifyAiSettings();
    });
    btnAiCopy.addEventListener('click', async () => {
      const value = String(getAiOutputValue() || '').trim();
      if (!value) return;
      try {
        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
          await navigator.clipboard.writeText(value);
        } else {
          window.prompt('Copy YAML variant', value);
        }
        setAiStatus('Variant copied to clipboard.', 'success');
      } catch (err) {
        setAiStatus('Copy failed. You can still copy manually from the output box.', 'error');
      }
    });

    window.addEventListener('resize', () => {
      if (isAiSelectionPopoverOpen()) {
        syncAiSelectionPopover();
      }
    });

    async function fetchText(url) {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);
      return resp.text();
    }

    function computeRepoBasePrefix() {
      const path = window.location.pathname || '';
      const webWithSlashIdx = path.indexOf('/web/');
      if (webWithSlashIdx >= 0) return path.slice(0, webWithSlashIdx);
      if (path.endsWith('/web')) return path.slice(0, -4);
      return '';
    }

    function resolveRepoPathCandidates(filename) {
      const cleanFilename = String(filename || '').replace(/^\/+/, '');
      const path = window.location.pathname || '';
      const currentDir = path.endsWith('/') ? path.replace(/\/+$/, '') : path.slice(0, path.lastIndexOf('/'));
      const repoBase = computeRepoBasePrefix().replace(/\/+$/, '');
      const candidates = [];
      if (repoBase) candidates.push(`${repoBase}/${cleanFilename}`);
      candidates.push(`/${cleanFilename}`);
      if (currentDir && currentDir !== repoBase) candidates.push(`${currentDir}/${cleanFilename}`);
      return Array.from(new Set(candidates.map((url) => url.replace(/\/{2,}/g, '/'))));
    }

    async function fetchTextWithFallback(urls) {
      let lastError = null;
      for (const url of urls) {
        try {
          return await fetchText(url);
        } catch (err) {
          lastError = err;
        }
      }
      throw lastError || new Error('No URL candidates provided.');
    }

    async function loadDefaults() {
      let resumeYaml = DEFAULT_RESUME_YAML;
      let bibResumeYaml = DEFAULT_RESUME_YAML;
      let configYaml = DEFAULT_CONFIG_YAML;
      let configShortYaml = DEFAULT_SHORT_CONFIG_YAML;
      let bibContent = DEFAULT_BIB;
      templateContent = await fetchTextWithFallback(resolveRepoPathCandidates('template.typ'));

      try {
        resumeYaml = await fetchTextWithFallback(resolveRepoPathCandidates('resume.yml'));
      } catch (e) { }
      try {
        bibResumeYaml = await fetchTextWithFallback(resolveRepoPathCandidates('resume-bibtex.yml'));
      } catch (e) {
        bibResumeYaml = resumeYaml;
      }
      try {
        configYaml = await fetchTextWithFallback(resolveRepoPathCandidates('config.yml'));
      } catch (e) { }
      try {
        configShortYaml = await fetchTextWithFallback(resolveRepoPathCandidates('config-short.yml'));
      } catch (e) { }
      try {
        bibContent = await fetchTextWithFallback(resolveRepoPathCandidates('publications.bib'));
      } catch (e) { }

      return { resumeYaml, bibResumeYaml, configYaml, configShortYaml, bibContent };
    }

    async function init() {
      setStatus('Loading defaults...', '');
      if (localStorage.getItem(LS_CACHE_VERSION) !== CACHE_VERSION) {
        clearSavedState();
        localStorage.setItem(LS_CACHE_VERSION, CACHE_VERSION);
      }
      loadRemoteUploadSources();
      let defaults = null;
      try {
        defaults = await loadDefaults();
      } catch (err) {
        overlay.querySelector('p').textContent = 'Failed: ' + err.message;
        setStatus('Init failed: ' + err.message, 'error');
        return;
      }

      defaultResumeBySource = {
        resume: defaults.resumeYaml,
        bibtex: defaults.bibResumeYaml || defaults.resumeYaml,
      };

      const legacyMode = localStorage.getItem(LS_OVERRIDE_MODE_LEGACY) || 'default';
      const legacyControls = modeToControlValues(legacyMode);
      const initialModeVariant = localStorage.getItem(LS_OVERRIDE_VARIANT) || legacyControls.variant;
      const initialModeSource = localStorage.getItem(LS_OVERRIDE_SOURCE) || legacyControls.source;
      const initialModeLink = localStorage.getItem(LS_OVERRIDE_LINK_MODE) || legacyControls.linkMode;
      const initialResumeDefault = initialModeSource === 'bibtex'
        ? (defaults.bibResumeYaml || defaults.resumeYaml)
        : defaults.resumeYaml;

      suppressHistoryTracking = true;
      cmResume.setValue(localStorage.getItem(LS_RESUME) || initialResumeDefault);
      cmConfig.setValue(localStorage.getItem(LS_CONFIG) || defaults.configYaml);
      cmConfigShort.setValue(localStorage.getItem(LS_CONFIG_SHORT) || defaults.configShortYaml);
      cmBib.setValue(localStorage.getItem(LS_BIB) || defaults.bibContent);
      suppressHistoryTracking = false;

      setModeVariant(initialModeVariant);
      setModeSource(initialModeSource);
      setModeLinkMode(initialModeLink);
      setCompileMode(localStorage.getItem(LS_COMPILE_MODE) || 'auto');
      setResumeCompileSource(localStorage.getItem(LS_RESUME_COMPILE_SOURCE) || 'original', { persist: false });
      setResumeEditorView(localStorage.getItem(LS_RESUME_VIEW) || 'original', { persist: false });
      const storedAiOutputView = localStorage.getItem(LS_AI_OUTPUT_VIEW) || 'variant';
      const storedMobileView = localStorage.getItem(LS_MOBILE_VIEW) || 'editor';
      setMobileView(window.innerWidth <= DESKTOP_SPLIT_BREAKPOINT ? 'editor' : storedMobileView);
      setAiOutputViewMode(storedAiOutputView, { persist: false });
      const storedActiveTab = localStorage.getItem(LS_ACTIVE_TAB);
      if (storedActiveTab && storedActiveTab in containers) {
        activeTab = storedActiveTab;
      }
      setDetailsOpen(panelOverrides, readStoredOpenState(LS_PANEL_OVERRIDES_OPEN, true));
      setDetailsOpen(panelAiSettings, readStoredOpenState(LS_PANEL_AI_SETTINGS_OPEN, false));
      setDetailsOpen(panelIntegrations, readStoredOpenState(LS_PANEL_INTEGRATIONS_OPEN, false));
      setDetailsOpen(aiJdPanel, readStoredOpenState(LS_PANEL_AI_JD_OPEN, true));
      setSelectValue(aiProvider, normalizeAiProviderValue(localStorage.getItem(LS_AI_PROVIDER) || 'disabled'), 'disabled');
      ensureAiModelForProvider(false);
      aiModel.value = localStorage.getItem(LS_AI_MODEL) || aiModel.value || getDefaultAiModel(getAiProvider());
      aiApiKey.value = localStorage.getItem(LS_AI_API_KEY) || '';
      githubToken.value = localStorage.getItem(LS_GITHUB_TOKEN) || '';
      const storedGithubVerified = localStorage.getItem(LS_GITHUB_VERIFIED);
      setGithubTokenVerified(storedGithubVerified === '1' && !!githubToken.value, { persist: false });
      if (!githubToken.value && !githubVerifyInFlight) {
        setGithubVerifyStatus('Not verified.');
      } else if (githubToken.value && !isGithubTokenVerified() && !githubVerifyInFlight) {
        setGithubVerifyStatus('Token set. Click Verify GitHub Token.');
      }
      const storedAiVerified = localStorage.getItem(LS_AI_VERIFIED);
      setAiSettingsVerified(storedAiVerified === '1' && isAiConfigured(), { persist: false });
      setAiVerifyStatus(isAiSettingsVerified() ? 'AI settings verified.' : 'Not verified.', isAiSettingsVerified() ? 'success' : '');
      aiWebSearch.checked = localStorage.getItem(LS_AI_WEB_SEARCH) !== '0';
      aiUserPrompt.value = localStorage.getItem(LS_AI_USER_PROMPT) || AI_DEFAULT_PROMPT;
      aiJobDescription.value = localStorage.getItem(LS_AI_JOB_DESCRIPTION) || '';
      if (aiSelectionPrompt) {
        aiSelectionPrompt.value = localStorage.getItem(LS_AI_SELECTION_PROMPT) || '';
      }
      setAiOutputValue(localStorage.getItem(LS_AI_OUTPUT) || '', { silentChange: true });
      if (isAiSettingsVerified()) {
        ensureAiOutputSeededFromOriginal({ persist: false });
      }
      setAiOutputViewMode(storedAiOutputView, { persist: false });
      updateShareMenuVisibility();
      setSettingsFlyoutOpen(false);
      const persistedResumeCustomized = localStorage.getItem(LS_RESUME_CUSTOMIZED);
      if (persistedResumeCustomized === '1' || persistedResumeCustomized === '0') {
        markResumeCustomized(persistedResumeCustomized === '1');
      } else {
        markResumeCustomized(!isDefaultResumeContent(cmResume.getValue()));
      }
      lastSourceSelection = getModeSource();
      hasPendingManualChanges = false;
      if (getCompileMode() === 'manual' && compileTimeout) {
        clearTimeout(compileTimeout);
        compileTimeout = null;
      }

      const storedPaper = localStorage.getItem(LS_PAPER);
      if (storedPaper === 'a4' || storedPaper === 'letter') {
        paperSize.value = storedPaper;
      } else {
        const activeConfigForPaper = getModeVariant() === 'short' ? cmConfigShort.getValue() : cmConfig.getValue();
        paperSize.value = detectPaperSize(activeConfigForPaper);
      }
      const storedPaneWidth = localStorage.getItem(LS_EDITOR_PANE_WIDTH);
      applyEditorPaneWidth(storedPaneWidth || DEFAULT_EDITOR_WIDTH, false);
      updateBibImportPlaceholder();
      refreshCustomSelects();
      syncConfigControlsFromActiveConfig();
      loadEditorHistoriesFromStorage();
      let loadedFromShareUrl = false;
      try {
        loadedFromShareUrl = await tryLoadShareStateFromLocation({ scheduleCompile: false });
      } catch (err) {
        setStatus('Share URL load failed: ' + err.message, 'error');
      }
      updateTabVisibility();
      syncConfigControlsFromActiveConfig();
      updateBibHealthStatus(true);
      updateCompileControlsUI();
      updateAiActionButtons();
      persistPreferences();
      if (loadedFromShareUrl) {
        setStatus('Loaded state from share URL.', 'ready');
      }

      const typstScript = document.getElementById('typst');

      function tryInit() {
        if (typeof globalThis.$typst !== 'undefined') {
          initTypst();
        } else {
          setTimeout(tryInit, 200);
        }
      }

      if (typstScript.complete || typeof globalThis.$typst !== 'undefined') {
        setTimeout(tryInit, 100);
      } else {
        typstScript.addEventListener('load', () => setTimeout(tryInit, 100));
      }
    }

    async function initTypst() {
      try {
        const compilerWasmUrl =
          'https://cdn.jsdelivr.net/npm/@myriaddreamin/typst-ts-web-compiler/pkg/typst_ts_web_compiler_bg.wasm';
        const rendererWasmUrl =
          'https://cdn.jsdelivr.net/npm/@myriaddreamin/typst-ts-renderer/pkg/typst_ts_renderer_bg.wasm';
        $typst.setCompilerInitOptions({
          // wasm-bindgen init now prefers an object containing module_or_path.
          getModule: () => ({ module_or_path: compilerWasmUrl }),
        });
        $typst.setRendererInitOptions({
          // Keep compiler/renderer init signatures aligned to avoid deprecation warnings.
          getModule: () => ({ module_or_path: rendererWasmUrl }),
        });
        ready = true;
        overlay.style.display = 'none';
        btnDownload.disabled = false;
        updateCompileControlsUI();
        setStatus('Ready', 'ready');
        compile();
      } catch (err) {
        overlay.querySelector('p').textContent = 'Failed: ' + err.message;
        setStatus('Init failed: ' + err.message, 'error');
      }
    }

    init();

  </script>
</body>

</html>
