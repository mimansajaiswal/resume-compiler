<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Resume Compiler</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.css">
  <style>
    :root {
      --oatmeal: #d5cec0;
      --earth: #b8ad9a;
      --charcoal: #2c2c2c;
      --linen: #f4f1ec;
      --linen-dark: #e8e4dc;
      --purple: #7d6b8a;
      --pink: #c4909a;
      --mono: "SF Mono", "Fira Code", "Cascadia Code", "JetBrains Mono", "Consolas", "Courier New", monospace;
      --editor-pane-width: 45%;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--mono);
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: var(--oatmeal);
      color: var(--charcoal);
    }

    header {
      background: var(--charcoal);
      color: var(--linen);
      padding: 0.55rem 1.2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      z-index: 10;
    }

    header h1 {
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    header .subtitle {
      font-size: 0.65rem;
      letter-spacing: 0.08em;
      color: var(--earth);
      text-transform: uppercase;
      margin-top: 0.1rem;
    }

    .header-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .paper-size-wrap {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      color: var(--earth);
      font-size: 0.62rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-weight: 700;
    }

    .native-select-hidden {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      margin: -1px !important;
      padding: 0 !important;
      border: 0 !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    .custom-select {
      position: relative;
      min-width: 7.25rem;
    }

    .custom-select-trigger {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.3rem 0.45rem;
      border: 1px solid var(--earth);
      background: var(--linen);
      color: var(--charcoal);
      font-family: var(--mono);
      font-size: 0.67rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease;
    }

    .custom-select-trigger:hover {
      border-color: #9b8f7c;
      background: #f9f6f0;
    }

    .custom-select.open .custom-select-trigger {
      border-color: var(--pink);
      background: #fff9fa;
    }

    .custom-select-value {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: left;
    }

    .custom-select-chevron {
      flex: 0 0 auto;
      width: 0.45rem;
      height: 0.45rem;
      border-right: 1px solid currentColor;
      border-bottom: 1px solid currentColor;
      transform: rotate(45deg) translateY(-1px);
      transition: transform 0.14s ease;
      opacity: 0.8;
      margin-right: 0.1rem;
    }

    .custom-select.open .custom-select-chevron {
      transform: rotate(-135deg) translateY(-1px);
    }

    .custom-select-menu {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 0.28rem);
      background: #fffdf8;
      border: 1px solid var(--earth);
      box-shadow: 0 10px 22px rgba(43, 39, 30, 0.12);
      max-height: 14rem;
      overflow-y: auto;
      z-index: 40;
      display: none;
      padding: 0.25rem;
    }

    .custom-select.open .custom-select-menu {
      display: block;
    }

    .custom-select-option {
      width: 100%;
      border: 0;
      background: transparent;
      color: #3f3a31;
      text-align: left;
      padding: 0.36rem 0.44rem;
      font-family: var(--mono);
      font-size: 0.67rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      cursor: pointer;
    }

    .custom-select-option:hover {
      background: #f1ebe2;
    }

    .custom-select-option.selected {
      background: #e8dfd2;
      color: #2f2a22;
      font-weight: 700;
    }

    .paper-size-wrap .custom-select {
      min-width: 5.6rem;
    }

    .paper-size-wrap .custom-select-trigger {
      background: transparent;
      color: var(--linen);
      border-color: var(--earth);
      font-size: 0.65rem;
      padding: 0.22rem 0.36rem;
    }

    .paper-size-wrap .custom-select-trigger:hover {
      background: rgba(255, 255, 255, 0.07);
      border-color: var(--linen-dark);
    }

    .paper-size-wrap .custom-select.open .custom-select-trigger {
      background: rgba(255, 255, 255, 0.12);
      border-color: var(--linen);
    }

    .paper-size-wrap .custom-select-menu {
      background: #353535;
      border-color: #696252;
    }

    .paper-size-wrap .custom-select-option {
      color: var(--linen);
    }

    .paper-size-wrap .custom-select-option:hover {
      background: #45413a;
    }

    .paper-size-wrap .custom-select-option.selected {
      background: #5b5448;
      color: #fff;
    }

    .header-actions button {
      padding: 0.3rem 0.85rem;
      border: 1px solid var(--earth);
      border-radius: 0;
      font-family: var(--mono);
      font-size: 0.7rem;
      font-weight: 600;
      cursor: pointer;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      transition: all 0.15s;
    }

    #btn-download {
      background: var(--pink);
      color: var(--charcoal);
      border-color: var(--pink);
    }

    #btn-download:hover {
      background: #b37e87;
    }

    #btn-download:disabled {
      background: #666;
      color: #999;
      border-color: #666;
      cursor: not-allowed;
    }

    #btn-download-typ {
      background: transparent;
      color: var(--earth);
    }

    #btn-download-typ:hover {
      background: rgba(255, 255, 255, 0.06);
      color: var(--linen);
    }

    #btn-reset {
      background: transparent;
      color: var(--earth);
    }

    #btn-reset:hover {
      background: rgba(255, 255, 255, 0.06);
      color: var(--linen);
    }

    .main-container {
      display: flex;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .mobile-view-toggle {
      display: none;
      border-bottom: 1px solid var(--earth);
      background: #eae3d7;
      padding: 0.35rem 0.7rem;
      gap: 0.35rem;
    }

    .mobile-view-toggle button {
      border: 1px solid #9f927f;
      background: #f5f0e7;
      color: #4a4338;
      font-family: var(--mono);
      font-size: 0.64rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0.28rem 0.55rem;
      cursor: pointer;
      flex: 1;
    }

    .mobile-view-toggle button.active {
      background: #2f2d2a;
      border-color: #2f2d2a;
      color: #f7f2ea;
    }

    .editor-panel {
      width: var(--editor-pane-width);
      min-width: 300px;
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--earth);
      background: var(--linen);
      overflow: hidden;
    }

    .pane-resizer {
      width: 10px;
      flex: 0 0 10px;
      border-left: 1px solid #b8ad9a;
      border-right: 1px solid #c8beaf;
      background: linear-gradient(180deg, #ddd5c8, #d2c8b9);
      cursor: col-resize;
      position: relative;
    }

    .pane-resizer::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 3px;
      height: 2.2rem;
      transform: translate(-50%, -50%);
      border-radius: 3px;
      background: rgba(63, 58, 49, 0.38);
      box-shadow: -3px 0 0 rgba(63, 58, 49, 0.2), 3px 0 0 rgba(63, 58, 49, 0.2);
    }

    .main-container.is-resizing,
    .main-container.is-resizing * {
      cursor: col-resize !important;
      user-select: none !important;
    }

    .tabs {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.34rem;
      flex-shrink: 0;
      padding: 0.42rem 0.6rem;
      background: var(--linen-dark);
      border-bottom: 1px solid var(--earth);
    }

    .tab-list {
      display: flex;
      align-items: center;
      gap: 0.36rem;
      min-width: 0;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 0.04rem;
    }

    .tab {
      padding: 0.32rem 0.66rem;
      cursor: pointer;
      font-family: var(--mono);
      font-size: 0.65rem;
      font-weight: 700;
      letter-spacing: 0.055em;
      text-transform: uppercase;
      color: #776d5e;
      background: #ece6dd;
      border: 1px solid transparent;
      transition: all 0.15s;
      user-select: none;
      white-space: nowrap;
    }

    .tab:hover {
      color: var(--charcoal);
      border-color: #c7bca8;
    }

    .tab.active {
      color: var(--linen);
      background: var(--charcoal);
      border-color: var(--charcoal);
    }

    .tab.hidden {
      display: none;
    }

    .tab-actions {
      display: flex;
      gap: 0.28rem;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
    }

    .tab-actions button {
      height: 2.05rem;
      padding: 0 0.54rem;
      border: 1px solid var(--earth);
      border-radius: 2px;
      background: var(--linen);
      font-family: var(--mono);
      font-size: 0.62rem;
      font-weight: 600;
      cursor: pointer;
      color: var(--charcoal);
      letter-spacing: 0.045em;
      text-transform: uppercase;
      line-height: 1;
      white-space: nowrap;
    }

    .tab-actions button:hover {
      background: var(--oatmeal);
    }

    .tab-actions button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .tab-actions .tab-bib-only {
      display: none;
    }

    .tab-actions .tab-bib-only.visible {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .schema-help {
      border-bottom: 1px solid var(--earth);
      background: var(--linen-dark);
      padding: 0.35rem 0.7rem;
      font-size: 0.66rem;
      line-height: 1.45;
      color: var(--charcoal);
    }

    .schema-help summary {
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--charcoal);
    }

    .schema-help code {
      font-family: var(--mono);
      font-size: 0.64rem;
      background: #ece7dd;
      padding: 0.02rem 0.2rem;
    }

    .bib-import-panel {
      border-bottom: 1px solid var(--earth);
      background: #ece6dc;
      padding: 0.44rem 0.68rem 0.48rem;
      display: grid;
      grid-template-columns: minmax(10.2rem, 0.95fr) minmax(11rem, 2fr) auto auto;
      gap: 0.34rem;
      align-items: center;
    }

    .bib-import-panel.hidden {
      display: none;
    }

    .bib-import-panel .bib-import-status {
      grid-column: 1 / -1;
      font-size: 0.6rem;
      color: #665d4f;
      letter-spacing: 0.03em;
      line-height: 1.35;
    }

    .bib-import-panel .bib-import-status.warning {
      color: #7b5614;
      font-weight: 700;
    }

    .bib-import-panel input {
      border: 1px solid var(--earth);
      background: #f6f1e8;
      color: var(--charcoal);
      font-family: var(--mono);
      font-size: 0.63rem;
      padding: 0.36rem 0.42rem;
      min-width: 0;
      height: 2.05rem;
    }

    .bib-import-panel button {
      border: 1px solid #8e826f;
      background: #332f2a;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.6rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      font-weight: 700;
      height: 2.05rem;
      padding: 0 0.58rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .bib-import-panel button.secondary {
      border-color: var(--earth);
      background: #f8f3eb;
      color: #433d34;
      font-weight: 600;
    }

    .bib-import-panel button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .bib-import-panel .custom-select {
      min-width: 0;
      width: 100%;
    }

    .bib-import-panel .custom-select-trigger {
      height: 2.05rem;
      padding: 0.25rem 0.42rem;
      font-size: 0.62rem;
    }

    .override-panel {
      border-bottom: 1px solid var(--earth);
      background: #efebe3;
      padding: 0.45rem 0.7rem 0.55rem;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.45rem 0.55rem;
    }

    .override-item {
      display: flex;
      flex-direction: column;
      gap: 0.16rem;
    }

    .override-item label {
      font-size: 0.62rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #5a5449;
    }

    .override-item.span-2 {
      grid-column: span 2;
    }

    .override-panel .custom-select {
      min-width: 0;
    }

    .mode-segmented {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      border: 1px solid var(--earth);
      background: #e4ddcf;
      padding: 0.14rem;
      gap: 0.14rem;
    }

    .mode-segmented label {
      position: relative;
      margin: 0;
      padding: 0;
      cursor: pointer;
    }

    .mode-segmented input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .mode-segmented span {
      display: block;
      text-align: center;
      font-family: var(--mono);
      font-size: 0.66rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 0.28rem 0.35rem;
      color: #5d5549;
      border: 1px solid transparent;
      background: #f5f0e7;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }

    .mode-segmented input:checked+span {
      background: #2f2d2a;
      color: #f7f2ea;
      border-color: #2f2d2a;
      font-weight: 700;
    }

    .compile-controls {
      border: 1px solid var(--earth);
      background: #f4efe7;
      padding: 0.2rem 0.24rem;
      display: grid;
      grid-template-columns: minmax(10.8rem, 1fr) auto minmax(9.2rem, auto);
      gap: 0.3rem;
      align-items: center;
    }

    .compile-controls .mode-segmented {
      border: 0;
      background: transparent;
      padding: 0;
      gap: 0.16rem;
    }

    .compile-now-btn {
      border: 1px solid #8b816f;
      background: #322f2b;
      color: #f4efe6;
      font-family: var(--mono);
      font-size: 0.61rem;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      font-weight: 700;
      padding: 0.28rem 0.56rem;
      cursor: pointer;
      min-width: 4.9rem;
      height: 1.95rem;
    }

    .compile-now-btn:hover {
      background: #433f3a;
    }

    .compile-now-btn:disabled {
      cursor: not-allowed;
      opacity: 0.45;
      background: #756f66;
      border-color: #756f66;
      color: #dfd8ce;
    }

    .compile-mode-hint {
      grid-column: auto;
      font-size: 0.57rem;
      color: #655d50;
      letter-spacing: 0.02em;
      text-transform: none;
      font-weight: 600;
      padding: 0 0.05rem 0 0.18rem;
      text-align: right;
      white-space: nowrap;
    }

    .compile-mode-hint.pending {
      color: #9b6b1a;
    }

    .editor-wrapper {
      flex: 1;
      position: relative;
      min-height: 0;
      overflow: hidden;
    }

    .editor-wrapper .cm-container {
      position: absolute;
      inset: 0;
    }

    .editor-wrapper .cm-container.hidden {
      display: none;
    }

    .CodeMirror {
      height: 100% !important;
      font-family: var(--mono);
      font-size: 0.78rem;
      line-height: 1.55;
      background: var(--linen) !important;
      color: var(--charcoal) !important;
    }

    .CodeMirror-gutters {
      background: var(--linen-dark) !important;
      border-right: 1px solid var(--earth) !important;
    }

    .CodeMirror-linenumber {
      color: var(--earth) !important;
    }

    .CodeMirror-cursor {
      border-left-color: var(--purple) !important;
      border-left-width: 2px !important;
    }

    .CodeMirror-selected,
    .CodeMirror-focused .CodeMirror-selected {
      background: rgba(125, 107, 138, 0.15) !important;
    }

    .CodeMirror-activeline-background {
      background: rgba(125, 107, 138, 0.06) !important;
    }

    .cm-s-default .cm-atom {
      color: var(--purple);
    }

    .cm-s-default .cm-number {
      color: var(--pink);
    }

    .cm-s-default .cm-string {
      color: #6a7d5a;
    }

    .cm-s-default .cm-keyword {
      color: var(--purple);
    }

    .cm-s-default .cm-meta {
      color: var(--pink);
    }

    .cm-s-default .cm-comment {
      color: var(--earth);
    }

    .preview-panel {
      flex: 1;
      overflow: hidden;
      background: var(--oatmeal);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      padding: 0 1rem 1rem;
      gap: 0;
      position: relative;
    }

    .preview-toolbar {
      width: min(760px, 100%);
      margin: 0 auto 0.55rem;
      background: #efe7db;
      border: 1px solid var(--earth);
      padding: 0.26rem 0.4rem 0.3rem;
      display: flex;
      flex-direction: column;
      gap: 0.16rem;
      position: relative;
      z-index: 2;
      box-shadow: 0 2px 8px rgba(49, 42, 32, 0.1);
    }

    .preview-toolbar label {
      font-size: 0.56rem;
      font-weight: 700;
      letter-spacing: 0.045em;
      text-transform: uppercase;
      color: #5a5449;
    }

    .preview-pages {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      width: 100%;
      padding: 0.1rem 0 0.4rem;
    }

    .preview-scroll {
      flex: 1;
      min-height: 0;
      overflow: auto;
      width: 100%;
      position: relative;
    }

    .preview-panel .page {
      background: #fff;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
      border: 1px solid var(--earth);
      max-width: 100%;
    }

    .preview-panel .page svg {
      display: block;
      max-width: 100%;
      height: auto;
    }

    .preview-feedback {
      position: absolute;
      inset: 0.4rem;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 15;
    }

    .preview-panel.compiling .preview-feedback {
      display: flex;
    }

    .preview-panel.compiling .preview-pages {
      opacity: 0.58;
      filter: saturate(0.82);
    }

    .preview-feedback-card {
      padding: 0.8rem 0.92rem;
      background: rgba(248, 243, 234, 0.97);
      border: 1px dashed #a89b87;
      display: flex;
      align-items: center;
      gap: 0.55rem;
      box-shadow: 0 2px 10px rgba(37, 33, 27, 0.08);
      max-width: 100%;
    }

    .preview-feedback-spinner {
      width: 0.85rem;
      height: 0.85rem;
      border: 2px solid rgba(125, 107, 138, 0.2);
      border-top-color: var(--purple);
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      flex: 0 0 auto;
    }

    .preview-feedback-text {
      font-size: 0.67rem;
      color: #534d41;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 700;
    }

    .preview-panel.has-error .preview-feedback-card {
      background: rgba(244, 222, 226, 0.96);
      border-color: var(--pink);
    }

    .preview-panel.has-error .preview-feedback-text {
      color: #6f2d38;
    }

    .status-bar {
      background: var(--charcoal);
      color: var(--earth);
      padding: 0.25rem 1.2rem;
      font-family: var(--mono);
      font-size: 0.65rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .status-bar.error {
      color: var(--pink);
    }

    .status-bar.compiling {
      color: var(--earth);
    }

    .status-bar.ready {
      color: #8a9a7d;
    }

    .status-bar.pending {
      color: #d8be7b;
    }

    .credit-bar {
      background: #2d2a26;
      color: #a79a88;
      padding: 0.2rem 1.2rem 0.24rem;
      font-family: var(--mono);
      font-size: 0.58rem;
      letter-spacing: 0.03em;
      border-top: 1px solid #3d3831;
      line-height: 1.45;
    }

    .credit-bar a {
      color: #d7c1a9;
      text-decoration: underline;
      text-underline-offset: 0.1em;
    }

    .credit-bar a:hover {
      color: #f0d8bd;
    }

    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(44, 44, 44, 0.94);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--linen);
      z-index: 100;
      gap: 1rem;
    }

    .loading-overlay .spinner {
      width: 32px;
      height: 32px;
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-top-color: var(--pink);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .loading-overlay p {
      font-family: var(--mono);
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--earth);
    }

    .confirm-modal {
      position: fixed;
      inset: 0;
      background: rgba(23, 21, 18, 0.62);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 120;
      padding: 1rem;
    }

    .confirm-modal.open {
      display: flex;
    }

    .confirm-dialog {
      width: min(420px, 100%);
      background: #f6f1e7;
      border: 1px solid #9d927f;
      box-shadow: 0 12px 30px rgba(28, 26, 22, 0.24);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }

    .confirm-dialog h2 {
      font-size: 0.82rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #312d25;
    }

    .confirm-dialog p {
      font-size: 0.69rem;
      line-height: 1.5;
      color: #4a4439;
      letter-spacing: 0.02em;
    }

    .confirm-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.45rem;
    }

    .confirm-actions button {
      border: 1px solid #9d927f;
      background: transparent;
      color: #3a352c;
      font-family: var(--mono);
      font-size: 0.68rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 0.33rem 0.7rem;
      cursor: pointer;
    }

    .confirm-actions button:hover {
      background: #ece4d7;
    }

    .confirm-actions .danger {
      background: #c4909a;
      border-color: #c4909a;
      color: #2d1f22;
      font-weight: 700;
    }

    .confirm-actions .danger:hover {
      background: #b47f89;
    }

    @media (max-width: 1024px) {
      .mobile-view-toggle {
        display: flex;
      }

      .main-container {
        flex-direction: column;
      }

      .editor-panel,
      .pane-resizer,
      .preview-panel {
        width: 100%;
        min-width: 0;
      }

      .editor-panel {
        border-right: none;
        border-bottom: 1px solid var(--earth);
      }

      .pane-resizer {
        display: none;
      }

      .preview-panel {
        border-top: 1px solid var(--earth);
      }

      .main-container.mobile-editor .preview-panel {
        display: none;
      }

      .main-container.mobile-preview .editor-panel {
        display: none;
      }
    }

    @media (max-width: 768px) {
      .main-container {
        flex-direction: column;
      }

      .editor-panel {
        width: 100%;
        min-width: 0;
        border-right: none;
      }

      .pane-resizer {
        display: none;
      }

      .preview-panel {
        padding: 0 0.7rem 0.7rem;
      }

      .preview-feedback {
        inset: 0.3rem;
      }

      .tabs {
        gap: 0.42rem;
      }

      .tab {
        padding: 0.28rem 0.5rem;
        font-size: 0.6rem;
      }

      .tab-actions {
        justify-content: flex-start;
      }

      .tab-actions button {
        flex: 0 0 auto;
      }

      .override-item.span-2 {
        grid-column: span 1;
      }

      .override-panel {
        grid-template-columns: 1fr;
      }

      .compile-controls {
        grid-template-columns: 1fr;
      }

      .compile-mode-hint {
        grid-column: 1 / -1;
        text-align: left;
        padding-left: 0;
      }

      .bib-import-panel {
        grid-template-columns: 1fr;
      }

      .compile-now-btn {
        width: 100%;
      }

      .preview-toolbar {
        width: 100%;
        padding: 0.26rem 0.3rem 0.32rem;
      }

      .paper-size-wrap span {
        display: none;
      }
    }
  </style>
</head>

<body>

  <div class="loading-overlay" id="loading-overlay">
    <div class="spinner"></div>
    <p>initializing typst compiler...</p>
  </div>

  <header>
    <div>
      <h1>Resume Compiler</h1>
      <div class="subtitle">yaml + typst // pdf generator</div>
    </div>
    <div class="header-actions">
      <label class="paper-size-wrap">
        <span>Paper</span>
        <select id="paper-size">
          <option value="letter">Letter</option>
          <option value="a4">A4</option>
        </select>
      </label>
      <button id="btn-download" disabled>Download PDF</button>
      <button id="btn-download-typ">Download resume.typ</button>
      <button id="btn-reset">Reset to Defaults</button>
    </div>
  </header>

  <div class="mobile-view-toggle" id="mobile-view-toggle">
    <button type="button" data-mobile-view="editor" class="active">Editor + Overrides</button>
    <button type="button" data-mobile-view="preview">Preview PDF</button>
  </div>

  <div class="main-container mobile-editor">
    <div class="editor-panel">
      <div class="override-panel">
        <div class="override-item">
          <label>Length</label>
          <select id="override-variant">
            <option value="default">default</option>
            <option value="short">short</option>
          </select>
        </div>
        <div class="override-item">
          <label for="override-source">Source</label>
          <select id="override-source">
            <option value="resume">resume yaml</option>
            <option value="bibtex">bibtex</option>
          </select>
        </div>
        <div class="override-item">
          <label for="override-link-mode">Link Mode</label>
          <select id="override-link-mode">
            <option value="links">links on</option>
            <option value="no-js">no-js</option>
          </select>
        </div>
        <div class="override-item">
          <label for="override-links-disabled-behavior">Link-Off Rendering</label>
          <select id="override-links-disabled-behavior">
            <option value="config">Use config.yml</option>
            <option value="label">Keep Label Only</option>
            <option value="label_with_url">Label + [url]</option>
          </select>
        </div>
        <div class="override-item">
          <label for="override-pubnums">Pub Numbers Override</label>
          <select id="override-pubnums">
            <option value="config">Use config.yml</option>
            <option value="on">Show [n]</option>
            <option value="off">Hide [n]</option>
          </select>
        </div>
        <div class="override-item">
          <label for="override-contact">Contact Style Override</label>
          <select id="override-contact">
            <option value="config">Use config.yml</option>
            <option value="label">Label</option>
            <option value="icon_label">Icon + Label</option>
          </select>
        </div>
        <div class="override-item">
          <label for="override-font">General Font Override</label>
          <select id="override-font">
            <option value="config">Use config.yml</option>
            <option value="New Computer Modern">New Computer Modern</option>
            <option value="Libertinus Serif">Libertinus Serif</option>
            <option value="TeX Gyre Termes">TeX Gyre Termes</option>
            <option value="TeX Gyre Pagella">TeX Gyre Pagella</option>
            <option value="DejaVu Serif">DejaVu Serif</option>
          </select>
        </div>
        <div class="override-item">
          <label for="override-mono-font">Monospace Font Override</label>
          <select id="override-mono-font">
            <option value="config">Use config.yml</option>
            <option value="DejaVu Sans Mono">DejaVu Sans Mono</option>
            <option value="Libertinus Mono">Libertinus Mono</option>
            <option value="New Computer Modern Mono">New Computer Modern Mono</option>
            <option value="Fira Code">Fira Code</option>
            <option value="JetBrains Mono">JetBrains Mono</option>
            <option value="Cascadia Mono">Cascadia Mono</option>
          </select>
        </div>
      </div>
      <div class="tabs">
        <div class="tab-list">
          <div class="tab active" data-tab="resume">Resume (YAML)</div>
          <div class="tab" data-tab="config">Config (YAML)</div>
          <div class="tab" data-tab="config-short">Config Short (YAML)</div>
          <div class="tab" data-tab="bib">Publications (BibTeX)</div>
        </div>
        <div class="tab-actions">
          <button id="btn-undo" aria-label="Undo (Cmd/Ctrl+Z)">Undo</button>
          <button id="btn-redo" aria-label="Redo (Cmd/Ctrl+Shift+Z or Ctrl+Y)">Redo</button>
          <button id="btn-bib-clean" class="tab-bib-only" aria-label="Clean BibTeX (when BibTeX tab is active)">Clean
            .bib</button>
          <button id="btn-bib-download" class="tab-bib-only"
            aria-label="Download BibTeX (when BibTeX tab is active)">Download .bib</button>
          <button id="btn-upload" aria-label="Upload file">Upload</button>
          <input type="file" id="file-input" accept=".yml,.yaml,.bib,.txt" style="display:none">
        </div>
      </div>
      <div class="bib-import-panel hidden" id="bib-import-panel">
        <select id="bib-import-provider">
          <option value="dblp">DBLP Author ID</option>
          <option value="semantic">Semantic Scholar Author ID</option>
          <option value="google">Google Scholar ID</option>
        </select>
        <input id="bib-import-id" type="text"
          placeholder="Enter ID (or full profile URL). Example: j/Geffner:Blai or 1234567">
        <button id="btn-bib-import" type="button">Import + Merge</button>
        <button id="btn-bib-import-replace" class="secondary" type="button">Import + Replace</button>
        <div id="bib-import-status" class="bib-import-status">
          Imports merge generated BibTeX entries from a provider ID into the current `.bib`. Duplicate titles are
          flagged.
        </div>
      </div>
      <details class="schema-help">
        <summary>Supported Keys</summary>
        <div id="supported-keys-content">
          <div>Loading tab-specific key hints...</div>
        </div>
      </details>
      <div class="editor-wrapper">
        <div class="cm-container" id="cm-resume"></div>
        <div class="cm-container hidden" id="cm-config"></div>
        <div class="cm-container hidden" id="cm-config-short"></div>
        <div class="cm-container hidden" id="cm-bib"></div>
      </div>
    </div>
    <div class="pane-resizer" id="pane-resizer" role="separator" aria-orientation="vertical"
      aria-label="Resize editor and preview columns"></div>
    <div class="preview-panel" id="preview">
      <div class="preview-toolbar">
        <label>Compile</label>
        <div class="compile-controls">
          <div class="mode-segmented" role="radiogroup" aria-label="Compile mode">
            <label>
              <input type="radio" name="compile-mode" value="auto" checked>
              <span>auto</span>
            </label>
            <label>
              <input type="radio" name="compile-mode" value="manual">
              <span>manual</span>
            </label>
          </div>
          <button id="btn-compile-now" class="compile-now-btn" type="button">Compile</button>
          <div id="compile-mode-hint" class="compile-mode-hint">Auto compile on every change</div>
        </div>
      </div>
      <div class="preview-scroll" id="preview-scroll">
        <div class="preview-pages" id="preview-pages"></div>
        <div class="preview-feedback" id="preview-feedback" aria-live="polite">
          <div class="preview-feedback-card">
            <div class="preview-feedback-spinner"></div>
            <div class="preview-feedback-text" id="preview-feedback-text">Compiling changes...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="confirm-modal" id="confirm-modal" aria-hidden="true">
    <div class="confirm-dialog" role="dialog" aria-modal="true" aria-labelledby="confirm-title"
      aria-describedby="confirm-message">
      <h2 id="confirm-title">Confirm action</h2>
      <p id="confirm-message">Proceed?</p>
      <div class="confirm-actions">
        <button type="button" id="confirm-cancel">Cancel</button>
        <button type="button" id="confirm-accept" class="danger">Confirm</button>
      </div>
    </div>
  </div>

  <div class="status-bar" id="status-bar">Loading...</div>
  <div class="credit-bar">
    Built by <a href="https://mimansajaiswal.github.io" target="_blank" rel="noopener noreferrer">Mimansa Jaiswal</a>
    · See more <a href="https://mimansajaiswal.github.io/tools/" target="_blank" rel="noopener noreferrer">Tools Made
      with LLMs</a>
    · Code: <a href="https://github.com/mimansajaiswal/resume-compiler" target="_blank"
      rel="noopener noreferrer">resume-compiler</a>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/mode/yaml/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/mode/stex/stex.min.js"></script>
  <script type="module"
    src="https://cdn.jsdelivr.net/npm/@myriaddreamin/typst.ts@0.7.0-rc2/dist/esm/contrib/all-in-one-lite.bundle.js"
    id="typst">
    </script>

  <script type="module">

    const DEFAULT_RESUME_YAML = `personal:
  name: Your Name
  email: your.email@example.com
  url: https://yourwebsite.com
  titles:
    - Your Title

work:
  - name: Company Name
    url: https://company.com
    positions:
      - name: Senior Research Engineer
        startDate: 2024-01-01
        endDate: present
        content:
          - "Describe your current-role accomplishments here"
      - name: Research Engineer
        startDate: 2022-01-01
        endDate: 2023-12-01
        content:
          - "Describe your previous role at the same company here"

education:
  - name: University Name
    location: City, State
    studyType: B.S.
    area: Your Major
    startDate: 2020-09-01
    endDate: 2024-05-01
    content:
      - "*Advisor*: Prof. Example Person"

# Generic section example (auto-rendered even if omitted from section_order):
community_service:
  - name: Theorem Proving Reading Group
    startDate: 2023-01-01
    endDate: present
    content:
      - "Organize monthly paper discussions and proof clinics."

skills:
  - category: Technical Skills
    skills:
      - Skill 1
      - Skill 2
      - Skill 3
`;

    const DEFAULT_CONFIG_YAML = `variant: long
paper_size: "letter"
fonts:
  font: "Libertinus Serif"
  mono_font: "DejaVu Sans Mono"
  font_size: 10pt
  name_font_size: 1.4em
  section_font_size: 1em
  publications_font_size: 9.6pt
  awards_font_size: 10pt
  page_number_font_size: 0.85em
  header_title_font_size: 0.9em
  location_font_size: 0.8em
  work_role_font_size: 0.98em
layout:
  margin: 0.5in
  line_spacing: 0.38em
  list_spacing: 0.7em
  section_spacing: 1.38em
  post_section_spacing: 0.9em
  entry_spacing: 0.71em
  entry_inner_spacing: 0.55em
  pub_spacing: 0.7em
  publications_line_spacing: 0.38em
  publications_heading_tighten: 0pt
  skill_spacing: 0.7em
  header_rule_top_spacing: 0.6em
  header_bottom_spacing: 0.35em
  contact_separator_spacing: 0.35em
  last_updated_bottom_spacing: 0.23em
styling:
  section_smallcaps: false
  secondary_color: "#111111"
  link_color: "#1C398D"
  section_rule_color: "#9F9FA8"
  section_rule_thickness: 0.6pt
  section_heading_sticky: true
  header_rule_color: "#9F9FA8"
  publications_link_style: "compact"
  publication_title_bold: false
  publication_autobold_authors: true
  publication_bold_author_names: []
  contact_font_size: 0.85em
  summary_font_size: 1em
  last_updated_font_size: 0.8em
  last_updated_label: "Last Updated on"
  contact_display_mode: "icon_label"
  contact_icon_spacing: 0.21em
visibility:
  show_location: false
  show_phone: true
  show_interests_summary: false
  show_languages: true
  show_interests: false
  show_references: false
  show_last_updated: true
  enable_links: true
  links_disabled_behavior: "label"
  show_publication_numbers: false
section_titles:
  work: "Experience"
  education: "Education"
  publications: "Publications"
  projects: "Projects"
  awards: "Honors and Awards"
  skills: "Skills"
section_order:
  - work
  - education
  - skills
`;

    const DEFAULT_SHORT_CONFIG_YAML = `variant: short
paper_size: "letter"
fonts:
  font: "Libertinus Serif"
  mono_font: "DejaVu Sans Mono"
  font_size: 10.2pt
  name_font_size: 1.5em
  section_font_size: 1em
  publications_font_size: 9.6pt
  awards_font_size: 10pt
  page_number_font_size: 0.8em
  header_title_font_size: 0.84em
  location_font_size: 0.74em
  work_role_font_size: 0.96em
layout:
  margin: 0.5in
  line_spacing: 0.33em
  skills_line_spacing: 0.33em
  list_spacing: 0.54em
  section_spacing: 1em
  post_section_spacing: 0.68em
  entry_spacing: 0.5em
  entry_inner_spacing: 0.42em
  pub_spacing: 0.54em
  publications_line_spacing: 0.33em
  publications_heading_tighten: 0pt
  skill_spacing: 0.54em
  header_rule_top_spacing: 0.36em
  header_bottom_spacing: 0.22em
  contact_separator_spacing: 0.18em
  last_updated_bottom_spacing: 0.18em
styling:
  section_smallcaps: false
  secondary_color: "#111111"
  link_color: "#1C398D"
  section_rule_color: "#9F9FA8"
  section_rule_thickness: 0.6pt
  section_heading_sticky: true
  header_rule_color: "#9F9FA8"
  publications_link_style: "compact"
  publication_title_bold: false
  publication_autobold_authors: true
  publication_bold_author_names: []
  contact_font_size: 0.74em
  summary_font_size: 0.92em
  last_updated_font_size: 0.66em
  last_updated_label: "Last Updated on"
  contact_display_mode: "icon_label"
  contact_icon_spacing: 0.16em
visibility:
  show_location: false
  show_phone: true
  show_interests_summary: false
  show_languages: false
  show_interests: false
  show_references: false
  show_last_updated: true
  enable_links: true
  links_disabled_behavior: "label"
  show_publication_numbers: false
section_titles:
  work: "Experience"
  education: "Education"
  publications: "Publications"
  projects: "Projects"
  awards: "Honors and Activities"
  skills: "Skills"
section_order:
  - work
  - publications
  - education
  - awards
  - skills
`;

    const DEFAULT_BIB = `@article{example2024,
  title={Your Paper Title},
  author={Last, First and Other, Author},
  journal={Conference or Journal Name},
  year={2024},
  url={https://example.com/paper.pdf}
}
`;

    const APP_STORAGE_SCOPE = (() => {
      const path = (window.location.pathname || '/').replace(/\/+$/, '');
      if (!path || path === '/') return 'root';
      const normalized = path
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
      return normalized || 'root';
    })();
    const APP_STORAGE_PREFIX = `resume_compiler__${APP_STORAGE_SCOPE}__`;
    const lsKey = (name) => `${APP_STORAGE_PREFIX}${name}`;

    const CACHE_VERSION = '2026-02-11-mode-v1';
    const LS_CACHE_VERSION = lsKey('cache_version');
    const LS_RESUME = lsKey('resume_yaml');
    const LS_CONFIG = lsKey('config_yaml');
    const LS_CONFIG_SHORT = lsKey('config_short_yaml');
    const LS_BIB = lsKey('publications_bib');
    const LS_PAPER = lsKey('paper_size');
    const LS_OVERRIDE_MODE_LEGACY = lsKey('override_mode');
    const LS_OVERRIDE_VARIANT = lsKey('override_variant');
    const LS_OVERRIDE_SOURCE = lsKey('override_source');
    const LS_OVERRIDE_LINK_MODE = lsKey('override_link_mode');
    const LS_COMPILE_MODE = lsKey('compile_mode');
    const LS_ACTIVE_TAB = lsKey('active_tab');
    const LS_MOBILE_VIEW = lsKey('mobile_view');
    const LS_EDITOR_HISTORY = lsKey('editor_history_v1');
    const LS_OVERRIDE_LINKS_DISABLED_BEHAVIOR = lsKey('override_links_disabled_behavior');
    const LS_OVERRIDE_PUBNUMS = lsKey('override_pubnums');
    const LS_OVERRIDE_CONTACT = lsKey('override_contact');
    const LS_OVERRIDE_FONT = lsKey('override_font');
    const LS_OVERRIDE_MONO_FONT = lsKey('override_mono_font');
    const LS_EDITOR_PANE_WIDTH = lsKey('editor_pane_width');
    const LS_KEYS = [
      LS_CACHE_VERSION,
      LS_RESUME,
      LS_CONFIG,
      LS_CONFIG_SHORT,
      LS_BIB,
      LS_PAPER,
      LS_OVERRIDE_MODE_LEGACY,
      LS_OVERRIDE_VARIANT,
      LS_OVERRIDE_SOURCE,
      LS_OVERRIDE_LINK_MODE,
      LS_COMPILE_MODE,
      LS_ACTIVE_TAB,
      LS_MOBILE_VIEW,
      LS_EDITOR_HISTORY,
      LS_OVERRIDE_LINKS_DISABLED_BEHAVIOR,
      LS_OVERRIDE_PUBNUMS,
      LS_OVERRIDE_CONTACT,
      LS_OVERRIDE_FONT,
      LS_OVERRIDE_MONO_FONT,
      LS_EDITOR_PANE_WIDTH,
    ];
    const EDITOR_CONTENT_KEYS = {
      resume: LS_RESUME,
      config: LS_CONFIG,
      'config-short': LS_CONFIG_SHORT,
      bib: LS_BIB,
    };
    const BIB_SOURCE_ALIASES = [
      '/publications.bib',
      '/default-publications.bib',
      '/web/publications.bib',
      '/web/default-publications.bib',
    ];

    const preview = document.getElementById('preview');
    const mainContainer = document.querySelector('.main-container');
    const paneResizer = document.getElementById('pane-resizer');
    const mobileViewButtons = Array.from(document.querySelectorAll('[data-mobile-view]'));
    const previewPages = document.getElementById('preview-pages');
    const previewFeedbackText = document.getElementById('preview-feedback-text');
    const statusBar = document.getElementById('status-bar');
    const btnDownload = document.getElementById('btn-download');
    const btnDownloadTyp = document.getElementById('btn-download-typ');
    const btnUndo = document.getElementById('btn-undo');
    const btnRedo = document.getElementById('btn-redo');
    const btnBibClean = document.getElementById('btn-bib-clean');
    const btnBibDownload = document.getElementById('btn-bib-download');
    const btnCompileNow = document.getElementById('btn-compile-now');
    const btnReset = document.getElementById('btn-reset');
    const compileModeHint = document.getElementById('compile-mode-hint');
    const paperSize = document.getElementById('paper-size');
    const compileModeInputs = Array.from(document.querySelectorAll('input[name="compile-mode"]'));
    const overrideVariant = document.getElementById('override-variant');
    const overrideSource = document.getElementById('override-source');
    const overrideLinkMode = document.getElementById('override-link-mode');
    const overrideLinksDisabledBehavior = document.getElementById('override-links-disabled-behavior');
    const overridePubnums = document.getElementById('override-pubnums');
    const overrideContact = document.getElementById('override-contact');
    const overrideFont = document.getElementById('override-font');
    const overrideMonoFont = document.getElementById('override-mono-font');
    const bibImportPanel = document.getElementById('bib-import-panel');
    const bibImportProvider = document.getElementById('bib-import-provider');
    const bibImportId = document.getElementById('bib-import-id');
    const btnBibImport = document.getElementById('btn-bib-import');
    const btnBibImportReplace = document.getElementById('btn-bib-import-replace');
    const bibImportStatus = document.getElementById('bib-import-status');
    const supportedKeysContent = document.getElementById('supported-keys-content');
    const overlay = document.getElementById('loading-overlay');
    const confirmModal = document.getElementById('confirm-modal');
    const confirmTitle = document.getElementById('confirm-title');
    const confirmMessage = document.getElementById('confirm-message');
    const confirmCancel = document.getElementById('confirm-cancel');
    const confirmAccept = document.getElementById('confirm-accept');

    const EDITOR_EXTRA_KEYS = {
      'Cmd-Z': () => performEditorUndo(),
      'Ctrl-Z': () => performEditorUndo(),
      'Cmd-Shift-Z': () => performEditorRedo(),
      'Ctrl-Shift-Z': () => performEditorRedo(),
      'Ctrl-Y': () => performEditorRedo(),
    };

    const cmResume = CodeMirror(document.getElementById('cm-resume'), {
      mode: 'yaml',
      lineNumbers: true,
      tabSize: 2,
      indentWithTabs: false,
      lineWrapping: true,
      viewportMargin: 20,
      extraKeys: EDITOR_EXTRA_KEYS,
    });

    const cmConfig = CodeMirror(document.getElementById('cm-config'), {
      mode: 'yaml',
      lineNumbers: true,
      tabSize: 2,
      indentWithTabs: false,
      lineWrapping: true,
      viewportMargin: 20,
      extraKeys: EDITOR_EXTRA_KEYS,
    });

    const cmConfigShort = CodeMirror(document.getElementById('cm-config-short'), {
      mode: 'yaml',
      lineNumbers: true,
      tabSize: 2,
      indentWithTabs: false,
      lineWrapping: true,
      viewportMargin: 20,
      extraKeys: EDITOR_EXTRA_KEYS,
    });

    const cmBib = CodeMirror(document.getElementById('cm-bib'), {
      mode: 'text/x-bibtex',
      lineNumbers: true,
      tabSize: 2,
      indentWithTabs: false,
      lineWrapping: true,
      viewportMargin: 20,
      extraKeys: EDITOR_EXTRA_KEYS,
    });

    let activeTab = 'resume';
    const editors = { resume: cmResume, config: cmConfig, "config-short": cmConfigShort, bib: cmBib };
    const containers = {
      resume: document.getElementById('cm-resume'),
      config: document.getElementById('cm-config'),
      "config-short": document.getElementById('cm-config-short'),
      bib: document.getElementById('cm-bib'),
    };

    let templateContent = '';
    let compileTimeout = null;
    let ready = false;
    let hasPendingManualChanges = false;
    let compileRequestId = 0;
    let activeCustomSelect = null;
    let pendingConfirmResolve = null;
    let pendingConfirmFocus = null;
    let suppressHistoryTracking = false;
    let historyPersistTimer = null;
    const editorHistoryTimers = {};
    const EDITOR_HISTORY_LIMIT = 25;
    const editorHistories = {};
    const DESKTOP_SPLIT_BREAKPOINT = 1024;
    const DEFAULT_EDITOR_WIDTH = 45;
    const MIN_EDITOR_WIDTH = 28;
    const MAX_EDITOR_WIDTH = 72;
    const GOOGLE_PROXY_PREFIX = 'https://r.jina.ai/http://';
    let bibtexTidyModulePromise = null;

    const TAB_SUPPORTED_KEYS_HTML = {
      resume: `
        <div>Schema style is standardized (no legacy aliases): use the keys below directly.</div>
        <div>Work: <code>work[].name</code>, <code>work[].positions[].name</code>, <code>work[].positions[].content[]</code></div>
        <div>Education: <code>education[].name</code>, optional <code>content[]</code>, <code>honors[]</code>, <code>courses[]</code>, <code>thesis</code></div>
        <div>Publications in YAML mode: <code>publications[].name</code>, optional <code>authors</code>, <code>publisher</code>, <code>year</code>, <code>links[]</code>, <code>section</code></div>
        <div>Generic sections: any extra top-level array (example <code>community_service</code>) auto-renders, even if omitted from <code>section_order</code>.</div>
      `,
      config: `
        <div>Main groups: <code>fonts</code>, <code>layout</code>, <code>styling</code>, <code>visibility</code>, <code>section_titles</code>, <code>section_order</code>.</div>
        <div>Publication defaults: <code>styling.publication_title_bold</code>, <code>styling.publication_autobold_authors</code>, <code>styling.publication_bold_author_names[]</code>.</div>
        <div>Link-off behavior: <code>visibility.links_disabled_behavior</code> = <code>label</code> or <code>label_with_url</code>.</div>
        <div>Contact style: <code>styling.contact_display_mode</code> = <code>label</code> or <code>icon_label</code>.</div>
      `,
      'config-short': `
        <div>Same key set as <code>config.yml</code>, but tuned for one-page/condensed output.</div>
        <div>Typical edits: tighter <code>layout.*</code> spacing, reduced <code>fonts.*</code> sizes, and shorter <code>section_order</code>.</div>
        <div>Publication settings stay available: <code>styling.publication_title_bold</code>, <code>styling.publication_autobold_authors</code>, <code>styling.publication_bold_author_names[]</code>.</div>
      `,
      bib: `
        <div>Use standard BibTeX entries: <code>@article</code>, <code>@inproceedings</code>, <code>@misc</code>, etc.</div>
        <div>Required in this app: citation key plus useful fields like <code>title</code>, <code>author</code>, <code>year</code>, and optional <code>url</code>.</div>
        <div>Use <code>Clean .bib</code> for formatting/normalization and <code>Download .bib</code> to export current editor contents.</div>
      `,
    };
    const BIB_IMPORT_PLACEHOLDERS = {
      dblp: 'Example: j/Geffner:Blai or https://dblp.org/pid/j/Geffner:Blai.html',
      semantic: 'Example: 1741102 or https://www.semanticscholar.org/author/.../1741102',
      google: 'Example: cLzCYMIAAAAJ or https://scholar.google.com/citations?user=cLzCYMIAAAAJ',
    };

    function setStatus(text, level) {
      statusBar.textContent = text;
      statusBar.className = 'status-bar' + (level ? ' ' + level : '');
    }

    function setBibImportStatus(text, level = '') {
      bibImportStatus.textContent = text;
      bibImportStatus.classList.toggle('warning', level === 'warning');
    }

    function updateSupportedKeysContent() {
      supportedKeysContent.innerHTML = TAB_SUPPORTED_KEYS_HTML[activeTab] || TAB_SUPPORTED_KEYS_HTML.resume;
    }

    function isDesktopSplitEnabled() {
      return window.innerWidth > DESKTOP_SPLIT_BREAKPOINT;
    }

    function clampEditorPaneWidth(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return DEFAULT_EDITOR_WIDTH;
      return Math.max(MIN_EDITOR_WIDTH, Math.min(MAX_EDITOR_WIDTH, numeric));
    }

    function refreshAllEditors() {
      Object.values(editors).forEach((editor) => editor.refresh());
    }

    function applyEditorPaneWidth(value, persist = true, refresh = true) {
      const clamped = clampEditorPaneWidth(value);
      if (!isDesktopSplitEnabled()) {
        mainContainer.style.removeProperty('--editor-pane-width');
        if (persist) {
          localStorage.setItem(LS_EDITOR_PANE_WIDTH, String(clamped));
        }
        if (refresh) refreshAllEditors();
        return;
      }
      mainContainer.style.setProperty('--editor-pane-width', `${clamped}%`);
      if (persist) {
        localStorage.setItem(LS_EDITOR_PANE_WIDTH, String(clamped));
      }
      if (refresh) refreshAllEditors();
    }

    function setupPaneResizer() {
      let dragging = false;
      let raf = null;

      const onPointerMove = (event) => {
        if (!dragging || !isDesktopSplitEnabled()) return;
        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          const rect = mainContainer.getBoundingClientRect();
          const width = rect.width || 1;
          const percentage = ((event.clientX - rect.left) / width) * 100;
          applyEditorPaneWidth(percentage, false, false);
        });
      };

      const stopDragging = () => {
        if (!dragging) return;
        dragging = false;
        if (raf) {
          cancelAnimationFrame(raf);
          raf = null;
        }
        mainContainer.classList.remove('is-resizing');
        const computed = getComputedStyle(mainContainer).getPropertyValue('--editor-pane-width').trim();
        if (computed.endsWith('%')) {
          localStorage.setItem(LS_EDITOR_PANE_WIDTH, String(clampEditorPaneWidth(computed.slice(0, -1))));
        }
        refreshAllEditors();
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', stopDragging);
      };

      paneResizer.addEventListener('pointerdown', (event) => {
        if (!isDesktopSplitEnabled()) return;
        event.preventDefault();
        dragging = true;
        mainContainer.classList.add('is-resizing');
        if (typeof paneResizer.setPointerCapture === 'function') {
          paneResizer.setPointerCapture(event.pointerId);
        }
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', stopDragging);
      });

      window.addEventListener('resize', () => {
        const storedWidth = localStorage.getItem(LS_EDITOR_PANE_WIDTH);
        applyEditorPaneWidth(storedWidth || DEFAULT_EDITOR_WIDTH, false);
      });
    }

    function updateTabScopedUI() {
      const onBibTab = activeTab === 'bib';
      document.querySelectorAll('.tab-bib-only').forEach((el) => {
        el.classList.toggle('visible', onBibTab);
      });
      bibImportPanel.classList.toggle('hidden', !onBibTab);
      updateSupportedKeysContent();
      if (onBibTab) updateBibHealthStatus();
    }

    function updateBibImportPlaceholder() {
      const provider = bibImportProvider.value;
      bibImportId.placeholder = BIB_IMPORT_PLACEHOLDERS[provider] || BIB_IMPORT_PLACEHOLDERS.dblp;
    }

    function showPreviewFeedback(text, isError = false) {
      previewFeedbackText.textContent = text;
      preview.classList.add('compiling');
      preview.classList.toggle('has-error', !!isError);
    }

    function hidePreviewFeedback() {
      preview.classList.remove('compiling');
      preview.classList.remove('has-error');
    }

    function closeActiveCustomSelect() {
      if (!activeCustomSelect) return;
      activeCustomSelect.classList.remove('open');
      const trigger = activeCustomSelect.querySelector('.custom-select-trigger');
      if (trigger) trigger.setAttribute('aria-expanded', 'false');
      activeCustomSelect = null;
    }

    function refreshCustomSelects() {
      document.querySelectorAll('select').forEach((select) => {
        if (typeof select._refreshCustomSelect === 'function') {
          select._refreshCustomSelect();
        }
      });
    }

    function enhanceSelect(select) {
      if (!select || select.dataset.customized === '1') return;
      select.dataset.customized = '1';
      select.classList.add('native-select-hidden');

      const custom = document.createElement('div');
      custom.className = 'custom-select';

      const trigger = document.createElement('button');
      trigger.type = 'button';
      trigger.className = 'custom-select-trigger';
      trigger.setAttribute('aria-haspopup', 'listbox');
      trigger.setAttribute('aria-expanded', 'false');

      const value = document.createElement('span');
      value.className = 'custom-select-value';
      trigger.appendChild(value);

      const chevron = document.createElement('span');
      chevron.className = 'custom-select-chevron';
      trigger.appendChild(chevron);

      const menu = document.createElement('div');
      menu.className = 'custom-select-menu';
      menu.setAttribute('role', 'listbox');

      const selectOption = (nextValue) => {
        if (select.value !== nextValue) {
          select.value = nextValue;
          select.dispatchEvent(new Event('change', { bubbles: true }));
        }
        syncFromNative();
        closeActiveCustomSelect();
      };

      const syncFromNative = () => {
        const selectedOption = select.options[select.selectedIndex];
        value.textContent = selectedOption ? selectedOption.textContent : '';
        Array.from(menu.querySelectorAll('.custom-select-option')).forEach((optionButton) => {
          const isSelected = optionButton.dataset.value === select.value;
          optionButton.classList.toggle('selected', isSelected);
          optionButton.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        });
      };

      Array.from(select.options).forEach((option) => {
        const optionButton = document.createElement('button');
        optionButton.type = 'button';
        optionButton.className = 'custom-select-option';
        optionButton.dataset.value = option.value;
        optionButton.textContent = option.textContent;
        optionButton.setAttribute('role', 'option');
        optionButton.addEventListener('click', () => selectOption(option.value));
        menu.appendChild(optionButton);
      });

      trigger.addEventListener('click', (event) => {
        event.preventDefault();
        if (activeCustomSelect === custom) {
          closeActiveCustomSelect();
          return;
        }
        closeActiveCustomSelect();
        custom.classList.add('open');
        trigger.setAttribute('aria-expanded', 'true');
        activeCustomSelect = custom;
      });

      trigger.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeActiveCustomSelect();
          return;
        }
        if (event.key !== 'ArrowDown' && event.key !== 'ArrowUp' && event.key !== 'Enter' && event.key !== ' ') return;
        event.preventDefault();
        if (activeCustomSelect !== custom) {
          closeActiveCustomSelect();
          custom.classList.add('open');
          trigger.setAttribute('aria-expanded', 'true');
          activeCustomSelect = custom;
        }
        const options = Array.from(select.options);
        const currentIndex = Math.max(select.selectedIndex, 0);
        if (event.key === 'ArrowDown') {
          const nextIndex = (currentIndex + 1) % options.length;
          selectOption(options[nextIndex].value);
        } else if (event.key === 'ArrowUp') {
          const nextIndex = (currentIndex - 1 + options.length) % options.length;
          selectOption(options[nextIndex].value);
        }
      });

      select.parentNode.insertBefore(custom, select.nextSibling);
      custom.appendChild(trigger);
      custom.appendChild(menu);
      select._refreshCustomSelect = syncFromNative;
      syncFromNative();

      if (select.id) {
        const boundLabel = document.querySelector(`label[for="${select.id}"]`);
        if (boundLabel) {
          boundLabel.addEventListener('click', (event) => {
            if (event.target.closest('.custom-select')) return;
            event.preventDefault();
            trigger.click();
          });
        }
      }
    }

    function enhanceAllSelects() {
      document.querySelectorAll('select').forEach(enhanceSelect);
      document.addEventListener('click', (event) => {
        if (event.target.closest('.custom-select')) return;
        closeActiveCustomSelect();
      });
      window.addEventListener('resize', closeActiveCustomSelect);
    }

    function openConfirmDialog({
      title = 'Confirm action',
      message = 'Proceed?',
      confirmText = 'Confirm',
      cancelText = 'Cancel',
      destructive = false,
    } = {}) {
      if (pendingConfirmResolve) {
        pendingConfirmResolve(false);
        pendingConfirmResolve = null;
      }

      confirmTitle.textContent = title;
      confirmMessage.textContent = message;
      confirmCancel.textContent = cancelText;
      confirmAccept.textContent = confirmText;
      confirmAccept.classList.toggle('danger', !!destructive);
      confirmModal.classList.add('open');
      confirmModal.setAttribute('aria-hidden', 'false');
      pendingConfirmFocus = document.activeElement;

      return new Promise((resolve) => {
        pendingConfirmResolve = resolve;
        confirmCancel.focus();
      });
    }

    function closeConfirmDialog(accepted) {
      if (!pendingConfirmResolve) return;
      const resolve = pendingConfirmResolve;
      pendingConfirmResolve = null;
      confirmModal.classList.remove('open');
      confirmModal.setAttribute('aria-hidden', 'true');
      resolve(accepted);
      if (pendingConfirmFocus && typeof pendingConfirmFocus.focus === 'function') {
        pendingConfirmFocus.focus();
      }
      pendingConfirmFocus = null;
    }

    confirmCancel.addEventListener('click', () => closeConfirmDialog(false));
    confirmAccept.addEventListener('click', () => closeConfirmDialog(true));
    confirmModal.addEventListener('click', (event) => {
      if (event.target === confirmModal) closeConfirmDialog(false);
    });
    document.addEventListener('keydown', (event) => {
      handleGlobalUndoRedoShortcut(event);
      if (event.key === 'Escape' && pendingConfirmResolve) closeConfirmDialog(false);
    });

    enhanceAllSelects();
    setupPaneResizer();

    const tabs = Array.from(document.querySelectorAll('.tab[data-tab]'));

    function getCompileMode() {
      const selected = compileModeInputs.find((input) => input.checked);
      return selected && selected.value === 'manual' ? 'manual' : 'auto';
    }

    function setCompileMode(value) {
      const normalized = value === 'manual' ? 'manual' : 'auto';
      compileModeInputs.forEach((input) => {
        input.checked = input.value === normalized;
      });
    }

    function updateCompileControlsUI() {
      const manual = getCompileMode() === 'manual';
      btnCompileNow.disabled = !manual || !ready;
      compileModeHint.classList.toggle('pending', manual && hasPendingManualChanges);
      if (!manual) {
        compileModeHint.textContent = 'Auto compile on every change';
      } else if (hasPendingManualChanges) {
        compileModeHint.textContent = 'Changes pending. Click compile';
      } else {
        compileModeHint.textContent = 'Manual mode. No pending changes';
      }
    }

    function getModeVariant() {
      return overrideVariant.value === 'short' ? 'short' : 'default';
    }

    function setModeVariant(value) {
      setSelectValue(overrideVariant, value, 'default');
    }

    function getModeSource() {
      return overrideSource.value === 'bibtex' ? 'bibtex' : 'resume';
    }

    function setModeSource(value) {
      setSelectValue(overrideSource, value, 'resume');
    }

    function getModeLinkMode() {
      return overrideLinkMode.value === 'no-js' ? 'no-js' : 'links';
    }

    function setModeLinkMode(value) {
      setSelectValue(overrideLinkMode, value, 'links');
    }

    function getMobileView() {
      if (mainContainer.classList.contains('mobile-preview')) return 'preview';
      return 'editor';
    }

    function setMobileView(view) {
      const normalized = view === 'preview' ? 'preview' : 'editor';
      mainContainer.classList.toggle('mobile-preview', normalized === 'preview');
      mainContainer.classList.toggle('mobile-editor', normalized === 'editor');
      mobileViewButtons.forEach((button) => {
        button.classList.toggle('active', button.dataset.mobileView === normalized);
      });
    }

    function persistPreferences() {
      localStorage.setItem(LS_PAPER, paperSize.value);
      localStorage.setItem(LS_OVERRIDE_VARIANT, getModeVariant());
      localStorage.setItem(LS_OVERRIDE_SOURCE, getModeSource());
      localStorage.setItem(LS_OVERRIDE_LINK_MODE, getModeLinkMode());
      localStorage.setItem(LS_COMPILE_MODE, getCompileMode());
      localStorage.setItem(LS_OVERRIDE_MODE_LEGACY, getSelectedMode());
      localStorage.setItem(LS_OVERRIDE_LINKS_DISABLED_BEHAVIOR, overrideLinksDisabledBehavior.value);
      localStorage.setItem(LS_OVERRIDE_PUBNUMS, overridePubnums.value);
      localStorage.setItem(LS_OVERRIDE_CONTACT, overrideContact.value);
      localStorage.setItem(LS_OVERRIDE_FONT, overrideFont.value);
      localStorage.setItem(LS_OVERRIDE_MONO_FONT, overrideMonoFont.value);
      localStorage.setItem(LS_ACTIVE_TAB, activeTab);
      localStorage.setItem(LS_MOBILE_VIEW, getMobileView());
      const computedWidth = getComputedStyle(mainContainer).getPropertyValue('--editor-pane-width').trim();
      if (computedWidth.endsWith('%')) {
        localStorage.setItem(LS_EDITOR_PANE_WIDTH, String(clampEditorPaneWidth(computedWidth.slice(0, -1))));
      }
    }

    function createDefaultHistory(value) {
      return { undo: [], redo: [], current: String(value || '') };
    }

    function trimHistoryStack(stack) {
      if (stack.length > EDITOR_HISTORY_LIMIT) {
        stack.splice(0, stack.length - EDITOR_HISTORY_LIMIT);
      }
    }

    function queuePersistHistories() {
      if (historyPersistTimer) clearTimeout(historyPersistTimer);
      historyPersistTimer = setTimeout(() => {
        localStorage.setItem(LS_EDITOR_HISTORY, JSON.stringify(editorHistories));
      }, 120);
    }

    function normalizeLoadedHistory(key, loaded, currentValue) {
      if (!loaded || typeof loaded !== 'object') return createDefaultHistory(currentValue);
      const normalized = {
        undo: Array.isArray(loaded.undo) ? loaded.undo.filter((v) => typeof v === 'string') : [],
        redo: Array.isArray(loaded.redo) ? loaded.redo.filter((v) => typeof v === 'string') : [],
        current: typeof loaded.current === 'string' ? loaded.current : String(currentValue || ''),
      };
      trimHistoryStack(normalized.undo);
      trimHistoryStack(normalized.redo);
      if (normalized.current !== currentValue) {
        return createDefaultHistory(currentValue);
      }
      return normalized;
    }

    function loadEditorHistoriesFromStorage() {
      let loaded = {};
      try {
        loaded = JSON.parse(localStorage.getItem(LS_EDITOR_HISTORY) || '{}') || {};
      } catch (err) {
        loaded = {};
      }

      Object.keys(editors).forEach((key) => {
        const currentValue = editors[key].getValue();
        editorHistories[key] = normalizeLoadedHistory(key, loaded[key], currentValue);
      });
      queuePersistHistories();
      updateUndoRedoButtons();
    }

    function flushEditorHistoryTimer(editorKey) {
      if (!editorHistoryTimers[editorKey]) return;
      clearTimeout(editorHistoryTimers[editorKey]);
      editorHistoryTimers[editorKey] = null;
      const editor = editors[editorKey];
      if (!editor) return;
      recordEditorSnapshot(editorKey, editor.getValue());
    }

    function recordEditorSnapshot(editorKey, nextValue) {
      if (suppressHistoryTracking) return;
      const history = editorHistories[editorKey] || createDefaultHistory('');
      const value = String(nextValue || '');
      if (history.current === value) return;
      history.undo.push(history.current);
      trimHistoryStack(history.undo);
      history.current = value;
      history.redo = [];
      editorHistories[editorKey] = history;
      const contentKey = EDITOR_CONTENT_KEYS[editorKey];
      if (contentKey) localStorage.setItem(contentKey, value);
      queuePersistHistories();
      updateUndoRedoButtons();
    }

    function scheduleEditorHistorySnapshot(editorKey) {
      if (suppressHistoryTracking) return;
      if (editorHistoryTimers[editorKey]) clearTimeout(editorHistoryTimers[editorKey]);
      editorHistoryTimers[editorKey] = setTimeout(() => {
        editorHistoryTimers[editorKey] = null;
        const editor = editors[editorKey];
        if (!editor) return;
        recordEditorSnapshot(editorKey, editor.getValue());
      }, 240);
    }

    function editorHasUndo(editorKey) {
      const history = editorHistories[editorKey];
      return !!(history && history.undo.length > 0);
    }

    function editorHasRedo(editorKey) {
      const history = editorHistories[editorKey];
      return !!(history && history.redo.length > 0);
    }

    function updateUndoRedoButtons() {
      btnUndo.disabled = !editorHasUndo(activeTab);
      btnRedo.disabled = !editorHasRedo(activeTab);
    }

    function applyHistoryValue(editorKey, nextValue) {
      const editor = editors[editorKey];
      if (!editor) return;
      suppressHistoryTracking = true;
      editor.setValue(nextValue);
      suppressHistoryTracking = false;
      const contentKey = EDITOR_CONTENT_KEYS[editorKey];
      if (contentKey) localStorage.setItem(contentKey, nextValue);
      queuePersistHistories();
      updateUndoRedoButtons();
      scheduleCompile();
      if (editorKey === 'bib') updateBibHealthStatus(true);
    }

    function performEditorUndo(editorKey = activeTab) {
      flushEditorHistoryTimer(editorKey);
      const history = editorHistories[editorKey];
      if (!history || history.undo.length === 0) return;
      const previous = history.undo.pop();
      history.redo.push(history.current);
      trimHistoryStack(history.redo);
      history.current = previous;
      applyHistoryValue(editorKey, previous);
    }

    function performEditorRedo(editorKey = activeTab) {
      flushEditorHistoryTimer(editorKey);
      const history = editorHistories[editorKey];
      if (!history || history.redo.length === 0) return;
      const next = history.redo.pop();
      history.undo.push(history.current);
      trimHistoryStack(history.undo);
      history.current = next;
      applyHistoryValue(editorKey, next);
    }

    function handleGlobalUndoRedoShortcut(event) {
      if (event.defaultPrevented) return;
      if (!(event.metaKey || event.ctrlKey) || event.altKey) return;
      if (pendingConfirmResolve) return;
      const target = event.target;
      const tag = target && target.tagName ? target.tagName.toUpperCase() : '';
      if ((tag === 'INPUT' || tag === 'TEXTAREA') && !target.closest('.CodeMirror')) return;
      if (target && target.isContentEditable) return;

      const key = String(event.key || '').toLowerCase();
      const wantsUndo = key === 'z' && !event.shiftKey;
      const wantsRedo = (key === 'z' && event.shiftKey) || (key === 'y' && event.ctrlKey && !event.metaKey);
      if (!wantsUndo && !wantsRedo) return;

      event.preventDefault();
      if (wantsUndo) {
        performEditorUndo();
      } else {
        performEditorRedo();
      }
    }

    function isTabRelevant(tabId) {
      if (tabId === 'bib') return getModeSource() === 'bibtex';
      if (tabId === 'config') return getModeVariant() === 'default';
      if (tabId === 'config-short') return getModeVariant() === 'short';
      return true;
    }

    function syncActiveTabView() {
      tabs.forEach((tab) => {
        tab.classList.toggle('active', tab.dataset.tab === activeTab && !tab.classList.contains('hidden'));
      });
      Object.entries(containers).forEach(([key, el]) => {
        el.classList.toggle('hidden', key !== activeTab);
      });
      if (editors[activeTab]) editors[activeTab].refresh();
      updateUndoRedoButtons();
      updateTabScopedUI();
    }

    function updateTabVisibility() {
      const visibleTabs = [];
      tabs.forEach((tab) => {
        const visible = isTabRelevant(tab.dataset.tab);
        tab.classList.toggle('hidden', !visible);
        if (visible) visibleTabs.push(tab.dataset.tab);
      });
      if (!visibleTabs.includes(activeTab)) {
        if (activeTab === 'config' && visibleTabs.includes('config-short')) {
          activeTab = 'config-short';
        } else if (activeTab === 'config-short' && visibleTabs.includes('config')) {
          activeTab = 'config';
        } else {
          activeTab = visibleTabs.includes('resume') ? 'resume' : (visibleTabs[0] || 'resume');
        }
      }
      syncActiveTabView();
    }

    tabs.forEach((tab) => {
      tab.addEventListener('click', () => {
        if (tab.classList.contains('hidden')) return;
        activeTab = tab.dataset.tab;
        syncActiveTabView();
        persistPreferences();
      });
    });

    mobileViewButtons.forEach((button) => {
      button.addEventListener('click', () => {
        setMobileView(button.dataset.mobileView);
        persistPreferences();
      });
    });

    const btnUpload = document.getElementById('btn-upload');
    const fileInput = document.getElementById('file-input');
    btnUpload.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        suppressHistoryTracking = true;
        editors[activeTab].setValue(ev.target.result);
        suppressHistoryTracking = false;
        editorHistories[activeTab] = createDefaultHistory(ev.target.result);
        const contentKey = EDITOR_CONTENT_KEYS[activeTab];
        if (contentKey) localStorage.setItem(contentKey, ev.target.result);
        queuePersistHistories();
        updateUndoRedoButtons();
        scheduleCompile();
      };
      reader.readAsText(file);
      fileInput.value = '';
    });

    function setEditorContent(editorKey, value) {
      const editor = editors[editorKey];
      if (!editor) return;
      const nextValue = String(value ?? '');
      suppressHistoryTracking = true;
      editor.setValue(nextValue);
      suppressHistoryTracking = false;
      editorHistories[editorKey] = createDefaultHistory(nextValue);
      const contentKey = EDITOR_CONTENT_KEYS[editorKey];
      if (contentKey) localStorage.setItem(contentKey, nextValue);
      queuePersistHistories();
      updateUndoRedoButtons();
      scheduleCompile();
    }

    function normalizeBibKey(raw) {
      const text = String(raw || '').trim();
      if (!text) return '';
      return text.replace(/[^A-Za-z0-9:_-]+/g, '');
    }

    function normalizeTitle(raw) {
      return String(raw || '')
        .toLowerCase()
        .replace(/[{}]/g, '')
        .replace(/[^a-z0-9]+/g, ' ')
        .trim();
    }

    function splitBibEntryTexts(text) {
      const input = String(text || '');
      const entries = [];
      let index = 0;

      while (index < input.length) {
        const at = input.indexOf('@', index);
        if (at < 0) break;
        const openBrace = input.indexOf('{', at);
        if (openBrace < 0) break;

        let depth = 0;
        let end = -1;
        for (let i = openBrace; i < input.length; i += 1) {
          const ch = input[i];
          if (ch === '{') depth += 1;
          if (ch === '}') {
            depth -= 1;
            if (depth === 0) {
              end = i + 1;
              break;
            }
          }
        }

        if (end < 0) break;
        const candidate = input.slice(at, end).trim();
        if (candidate) entries.push(candidate);
        index = end;
      }

      return entries;
    }

    function parseBibEntries(text) {
      return splitBibEntryTexts(text).map((entryText) => {
        const header = entryText.match(/^@([A-Za-z]+)\s*\{\s*([^,\s]+)\s*,/);
        const type = header ? String(header[1]).toLowerCase() : '';
        const key = normalizeBibKey(header ? header[2] : '');
        const titleMatch = entryText.match(/\btitle\s*=\s*(\{[\s\S]*?\}|\"[\s\S]*?\")\s*,?/i);
        const titleRaw = titleMatch ? titleMatch[1] : '';
        const title = normalizeTitle(titleRaw.replace(/^[{"]|[}"]$/g, ''));
        return { key, type, title, text: entryText };
      });
    }

    function getBibDuplicateStats(text) {
      const entries = parseBibEntries(text);
      const seenKeys = new Set();
      const seenTitles = new Set();
      let duplicateKeys = 0;
      let duplicateTitles = 0;

      entries.forEach((entry) => {
        if (entry.key) {
          if (seenKeys.has(entry.key)) duplicateKeys += 1;
          seenKeys.add(entry.key);
        }
        if (entry.title) {
          if (seenTitles.has(entry.title)) duplicateTitles += 1;
          seenTitles.add(entry.title);
        }
      });

      return { totalEntries: entries.length, duplicateKeys, duplicateTitles };
    }

    function updateBibHealthStatus(force = false) {
      const stats = getBibDuplicateStats(cmBib.getValue());
      const hasDupes = stats.duplicateKeys > 0 || stats.duplicateTitles > 0;
      btnBibClean.textContent = hasDupes ? 'Clean .bib*' : 'Clean .bib';
      if (activeTab !== 'bib' && !force) return;
      if (stats.totalEntries === 0) {
        setBibImportStatus('BibTeX tab is empty. Import by ID or paste entries manually.');
      } else if (hasDupes) {
        setBibImportStatus(
          `Detected overlap: ${stats.duplicateKeys} duplicate keys and ${stats.duplicateTitles} duplicate titles. Cleaning is recommended.`,
          'warning',
        );
      } else {
        setBibImportStatus(`Loaded ${stats.totalEntries} BibTeX entries. No obvious duplicates detected.`);
      }
    }

    function bibtexEsc(value) {
      return String(value || '')
        .replace(/[{}]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function slugifyBibToken(value) {
      return String(value || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '')
        .trim();
    }

    function inferBibType(paper = {}) {
      const venue = String(paper.venue || '').toLowerCase();
      const publicationTypes = Array.isArray(paper.publicationTypes) ? paper.publicationTypes.map((x) => String(x).toLowerCase()) : [];
      if (publicationTypes.some((x) => x.includes('journal'))) return 'article';
      if (publicationTypes.some((x) => x.includes('conference'))) return 'inproceedings';
      if (venue.includes('journal')) return 'article';
      if (venue.includes('conference') || venue.includes('symposium') || venue.includes('workshop')) return 'inproceedings';
      return 'misc';
    }

    function buildBibEntryFromPaper(paper, fallbackAuthorToken = 'author') {
      const title = bibtexEsc(paper.title || 'Untitled');
      const year = String(paper.year || '').match(/^\d{4}$/) ? String(paper.year) : 'n.d.';
      const authorNames = (Array.isArray(paper.authors) ? paper.authors : [])
        .map((author) => bibtexEsc(author?.name || ''))
        .filter(Boolean);
      const authors = authorNames.length > 0 ? authorNames.join(' and ') : fallbackAuthorToken;
      const firstAuthorToken = slugifyBibToken(authorNames[0] || fallbackAuthorToken) || 'author';
      const titleToken = slugifyBibToken(title).slice(0, 24) || 'paper';
      const key = normalizeBibKey(`${firstAuthorToken}${year}${titleToken}`);
      const venue = bibtexEsc(paper.venue || '');
      const urlCandidate = paper.url || (paper.externalIds?.DOI ? `https://doi.org/${paper.externalIds.DOI}` : '');
      const url = bibtexEsc(urlCandidate);
      const type = inferBibType(paper);
      const venueField = type === 'article' ? 'journal' : 'booktitle';
      const lines = [
        `@${type}{${key},`,
        `  title={${title}},`,
        `  author={${authors}},`,
      ];
      if (/^\d{4}$/.test(year)) {
        lines.push(`  year={${year}},`);
      }
      if (venue) {
        lines.push(`  ${venueField}={${venue}},`);
      }
      if (url) {
        lines.push(`  url={${url}},`);
      }
      lines.push('}');
      return lines.join('\n');
    }

    function extractIdFromUrl(value, pathToken) {
      const raw = String(value || '').trim();
      if (!raw) return '';
      if (!/^https?:\/\//i.test(raw)) return raw;
      try {
        const parsed = new URL(raw);
        if (pathToken === 'dblp') {
          const parts = parsed.pathname.split('/').filter(Boolean);
          const pidIndex = parts.findIndex((part) => part === 'pid');
          if (pidIndex >= 0 && parts[pidIndex + 1]) {
            return decodeURIComponent(parts.slice(pidIndex + 1).join('/').replace(/\.html$|\.bib$/i, ''));
          }
          return decodeURIComponent(parts.join('/').replace(/\.html$|\.bib$/i, ''));
        }
        if (pathToken === 'semantic') {
          const parts = parsed.pathname.split('/').filter(Boolean);
          const authorIdx = parts.findIndex((part) => part === 'author');
          if (authorIdx >= 0 && parts[authorIdx + 1]) {
            return decodeURIComponent(parts.at(-1));
          }
          return decodeURIComponent(parts.at(-1) || '');
        }
        if (pathToken === 'google') {
          return parsed.searchParams.get('user') || decodeURIComponent(parsed.pathname.split('/').filter(Boolean).at(-1) || '');
        }
      } catch (err) {
        return raw;
      }
      return raw;
    }

    async function fetchJson(url) {
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`Request failed (${resp.status}) for ${url}`);
      }
      return resp.json();
    }

    async function fetchTextContent(url) {
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`Request failed (${resp.status}) for ${url}`);
      }
      return resp.text();
    }

    async function importDblpBib(rawId) {
      const dblpId = extractIdFromUrl(rawId, 'dblp').replace(/^pid\//i, '').trim();
      if (!dblpId) throw new Error('Enter a valid DBLP author ID.');
      const encodedId = dblpId.split('/').filter(Boolean).map((part) => encodeURIComponent(part)).join('/');
      const bibUrl = `https://dblp.org/pid/${encodedId}.bib`;
      const bibText = await fetchTextContent(bibUrl);
      if (!/@[A-Za-z]+\s*\{/.test(bibText)) {
        throw new Error('DBLP did not return valid BibTeX entries for this ID.');
      }
      return bibText.trim();
    }

    async function fetchSemanticScholarPapers(authorId) {
      const out = [];
      let offset = 0;
      const limit = 100;
      const maxPapers = 1000;
      while (out.length < maxPapers) {
        const fields = 'title,year,venue,url,authors,publicationTypes,externalIds';
        const url = `https://api.semanticscholar.org/graph/v1/author/${encodeURIComponent(authorId)}/papers?offset=${offset}&limit=${limit}&fields=${fields}`;
        const payload = await fetchJson(url);
        const papers = Array.isArray(payload?.data) ? payload.data : [];
        if (papers.length === 0) break;
        out.push(...papers);
        if (papers.length < limit) break;
        offset += papers.length;
      }
      return out;
    }

    async function importSemanticScholarBib(rawId, fallbackAuthorName = 'Author') {
      const semanticId = extractIdFromUrl(rawId, 'semantic').trim();
      if (!semanticId) throw new Error('Enter a valid Semantic Scholar author ID.');
      const papers = await fetchSemanticScholarPapers(semanticId);
      if (!papers.length) throw new Error('No Semantic Scholar papers found for this author ID.');
      const entries = papers
        .filter((paper) => paper && paper.title)
        .map((paper) => buildBibEntryFromPaper(paper, fallbackAuthorName));
      return entries.join('\n\n');
    }

    async function importGoogleScholarBib(rawId) {
      const scholarId = extractIdFromUrl(rawId, 'google').trim();
      if (!scholarId) throw new Error('Enter a valid Google Scholar profile ID (user=...).');
      const scholarUrl = `${GOOGLE_PROXY_PREFIX}http://scholar.google.com/citations?hl=en&user=${encodeURIComponent(scholarId)}`;
      const profileText = await fetchTextContent(scholarUrl);
      const nameMatch = profileText.match(/Title:\s*([^\n]+?)\s*-\s*Google Scholar/i)
        || profileText.match(/<title>\s*([^<]+?)\s*-\s*Google Scholar/i);
      const scholarName = nameMatch ? nameMatch[1].trim() : '';
      if (!scholarName) {
        throw new Error('Could not resolve a Scholar profile name from this ID.');
      }
      const searchUrl = `https://api.semanticscholar.org/graph/v1/author/search?query=${encodeURIComponent(scholarName)}&limit=5&fields=authorId,name,paperCount`;
      const payload = await fetchJson(searchUrl);
      const candidates = Array.isArray(payload?.data) ? payload.data : [];
      if (candidates.length === 0) {
        throw new Error('Scholar profile found, but no matching Semantic Scholar author was found.');
      }
      const normalizedTarget = scholarName.toLowerCase().replace(/\s+/g, ' ').trim();
      const best = candidates.find((candidate) => String(candidate?.name || '').toLowerCase().trim() === normalizedTarget)
        || candidates.sort((a, b) => (b?.paperCount || 0) - (a?.paperCount || 0))[0];
      if (!best?.authorId) {
        throw new Error('Scholar profile found, but no usable author ID match was found.');
      }
      return importSemanticScholarBib(best.authorId, scholarName);
    }

    function mergeBibContent(existingBib, incomingBib, replaceAll = false) {
      const incomingEntries = parseBibEntries(incomingBib);
      if (replaceAll) {
        return {
          mergedBib: incomingEntries.map((entry) => entry.text).join('\n\n').trim(),
          imported: incomingEntries.length,
          skippedByKey: 0,
          skippedByTitle: 0,
        };
      }

      const existingEntries = parseBibEntries(existingBib);
      const seenKeys = new Set(existingEntries.map((entry) => entry.key).filter(Boolean));
      const seenTitles = new Set(existingEntries.map((entry) => entry.title).filter(Boolean));
      let skippedByKey = 0;
      let skippedByTitle = 0;
      const accepted = [];

      incomingEntries.forEach((entry) => {
        const keyDup = entry.key && seenKeys.has(entry.key);
        const titleDup = entry.title && seenTitles.has(entry.title);
        if (keyDup || titleDup) {
          if (keyDup) skippedByKey += 1;
          if (titleDup) skippedByTitle += 1;
          return;
        }
        accepted.push(entry.text);
        if (entry.key) seenKeys.add(entry.key);
        if (entry.title) seenTitles.add(entry.title);
      });

      const existingTrimmed = String(existingBib || '').trim();
      const mergedBib = [existingTrimmed, ...accepted].filter(Boolean).join('\n\n').trim();
      return {
        mergedBib,
        imported: accepted.length,
        skippedByKey,
        skippedByTitle,
      };
    }

    function downloadTextFile(content, filename, mimeType = 'text/plain;charset=utf-8') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);
    }

    function simpleBibCleanup(bibText) {
      const entries = parseBibEntries(bibText).map((entry) => entry.text);
      if (entries.length === 0) return String(bibText || '').trim();
      return entries.join('\n\n').trim() + '\n';
    }

    async function loadBibtexTidyApi() {
      if (!bibtexTidyModulePromise) {
        bibtexTidyModulePromise = import('https://cdn.skypack.dev/bibtex-tidy').catch(() => null);
      }
      const mod = await bibtexTidyModulePromise;
      if (!mod) return null;
      if (typeof mod.tidy === 'function') return mod.tidy;
      if (mod.default && typeof mod.default.tidy === 'function') return mod.default.tidy;
      if (typeof mod.default === 'function') return mod.default;
      return null;
    }

    async function cleanBibEditorContent() {
      const source = cmBib.getValue();
      if (!source.trim()) {
        setBibImportStatus('BibTeX is empty. Add entries before cleaning.');
        return;
      }
      btnBibClean.disabled = true;
      setBibImportStatus('Cleaning BibTeX...');
      try {
        const tidyFn = await loadBibtexTidyApi();
        let cleaned = source;
        if (tidyFn) {
          try {
            const maybeClean = tidyFn(source);
            cleaned = typeof maybeClean === 'string' ? maybeClean : source;
          } catch (err) {
            cleaned = source;
          }
        }
        if (!cleaned || typeof cleaned !== 'string') {
          cleaned = source;
        }
        cleaned = simpleBibCleanup(cleaned);
        setEditorContent('bib', cleaned);
        setBibImportStatus('BibTeX cleaned and normalized. You can now download the file.');
      } catch (err) {
        setEditorContent('bib', simpleBibCleanup(source));
        setBibImportStatus('Cleaned with fallback formatter (external tidy API unavailable).', 'warning');
      } finally {
        btnBibClean.disabled = false;
        updateBibHealthStatus(true);
      }
    }

    async function runBibImport(replaceAll = false) {
      const provider = bibImportProvider.value;
      const rawId = bibImportId.value.trim();
      if (!rawId) {
        setBibImportStatus('Enter an ID before importing.', 'warning');
        bibImportId.focus();
        return;
      }
      btnBibImport.disabled = true;
      btnBibImportReplace.disabled = true;
      setBibImportStatus(`Fetching entries from ${provider}...`);
      try {
        let importedBib = '';
        if (provider === 'dblp') {
          importedBib = await importDblpBib(rawId);
        } else if (provider === 'semantic') {
          importedBib = await importSemanticScholarBib(rawId);
        } else if (provider === 'google') {
          importedBib = await importGoogleScholarBib(rawId);
        } else {
          throw new Error('Unsupported provider.');
        }

        const existing = cmBib.getValue();
        const merged = mergeBibContent(existing, importedBib, replaceAll);
        if (!merged.mergedBib) {
          throw new Error('No valid BibTeX entries were parsed from the import result.');
        }
        setEditorContent('bib', `${merged.mergedBib}\n`);
        if (replaceAll) {
          setBibImportStatus(`Imported and replaced with ${merged.imported} entries from ${provider}.`);
        } else {
          const overlap = merged.skippedByKey + merged.skippedByTitle;
          if (overlap > 0) {
            setBibImportStatus(
              `Imported ${merged.imported} new entries (${overlap} overlapping entries skipped). Cleaning is recommended.`,
              'warning',
            );
          } else {
            setBibImportStatus(`Imported ${merged.imported} new entries from ${provider}.`);
          }
        }
      } catch (err) {
        const message = err && err.message ? err.message : String(err);
        setBibImportStatus(`Import failed: ${message}`, 'warning');
      } finally {
        btnBibImport.disabled = false;
        btnBibImportReplace.disabled = false;
        updateBibHealthStatus(true);
      }
    }

    btnBibClean.addEventListener('click', cleanBibEditorContent);
    btnBibDownload.addEventListener('click', () => {
      downloadTextFile(cmBib.getValue(), 'publications.bib', 'application/x-bibtex;charset=utf-8');
      setBibImportStatus('Downloaded current BibTeX as publications.bib.');
    });
    btnBibImport.addEventListener('click', () => runBibImport(false));
    btnBibImportReplace.addEventListener('click', async () => {
      const accepted = await openConfirmDialog({
        title: 'Replace current BibTeX?',
        message: 'This will replace the current BibTeX tab with imported entries.',
        confirmText: 'Replace',
        cancelText: 'Cancel',
        destructive: true,
      });
      if (!accepted) return;
      runBibImport(true);
    });
    bibImportId.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        runBibImport(false);
      }
    });
    bibImportProvider.addEventListener('change', () => {
      updateBibImportPlaceholder();
      setBibImportStatus('Provider changed. Enter an author ID and import.');
    });

    function scheduleCompile() {
      if (compileTimeout) clearTimeout(compileTimeout);
      if (getCompileMode() === 'manual') {
        hasPendingManualChanges = true;
        updateCompileControlsUI();
        if (ready) {
          setStatus('Manual mode: changes pending. Click compile.', 'pending');
        }
        return;
      }
      hasPendingManualChanges = false;
      updateCompileControlsUI();
      compileTimeout = setTimeout(compile, 600);
    }

    cmResume.on('change', () => {
      scheduleEditorHistorySnapshot('resume');
      scheduleCompile();
    });
    cmConfig.on('change', () => {
      scheduleEditorHistorySnapshot('config');
      scheduleCompile();
    });
    cmConfigShort.on('change', () => {
      scheduleEditorHistorySnapshot('config-short');
      scheduleCompile();
    });
    cmBib.on('change', () => {
      scheduleEditorHistorySnapshot('bib');
      scheduleCompile();
      updateBibHealthStatus();
    });

    function formatLastUpdatedDate(dateObj = new Date()) {
      return dateObj.toLocaleDateString('en-US', {
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });
    }

    function detectPaperSize(configText) {
      const m = configText.match(/^\s*paper_size\s*:\s*["']?([A-Za-z-]+)["']?\s*$/m);
      if (!m) return 'letter';
      return m[1].toLowerCase() === 'a4' ? 'a4' : 'letter';
    }

    function normalizeMode(mode) {
      return String(mode || 'default')
        .toLowerCase()
        .trim()
        .replace(/_/g, '-')
        .replace(/\s+/g, '');
    }

    function modeHas(mode, token) {
      const parts = normalizeMode(mode).split('+').filter(Boolean);
      return parts.includes(token);
    }

    function modeUsesShort(mode) {
      return modeHas(mode, 'short');
    }

    function modeUsesBib(mode) {
      return modeHas(mode, 'bibtex');
    }

    function modeDisablesLinks(mode) {
      return modeHas(mode, 'no-js');
    }

    function modeToControlValues(mode) {
      const normalized = normalizeMode(mode);
      return {
        variant: modeUsesShort(normalized) ? 'short' : 'default',
        source: modeUsesBib(normalized) ? 'bibtex' : 'resume',
        linkMode: modeDisablesLinks(normalized) ? 'no-js' : 'links',
      };
    }

    function setSelectValue(select, nextValue, fallbackValue) {
      const values = Array.from(select.options).map((option) => option.value);
      if (values.includes(nextValue)) {
        select.value = nextValue;
      } else {
        select.value = fallbackValue;
      }
    }

    function escapeTypstString(value) {
      return String(value).replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    }

    function clearSavedState() {
      LS_KEYS.forEach(key => localStorage.removeItem(key));
    }

    function getSelectedMode() {
      const parts = [];
      if (getModeLinkMode() === 'no-js') parts.push('no-js');
      if (getModeSource() === 'bibtex') parts.push('bibtex');
      if (getModeVariant() === 'short') parts.push('short');
      if (parts.length === 0) return 'default';
      return parts.join('+');
    }

    function getRuntimeOverridesObject() {
      const overrides = {
        last_updated: formatLastUpdatedDate(),
        paper_size: paperSize.value,
      };

      overrides.variant = getModeVariant() === 'short' ? 'short' : 'long';
      if (getModeLinkMode() === 'no-js') {
        overrides.enable_links = false;
      }
      if (overrideLinksDisabledBehavior.value !== 'config') {
        overrides.links_disabled_behavior = overrideLinksDisabledBehavior.value;
      }
      if (overridePubnums.value === 'on') {
        overrides.show_publication_numbers = true;
      } else if (overridePubnums.value === 'off') {
        overrides.show_publication_numbers = false;
      }
      if (overrideContact.value !== 'config') {
        overrides.contact_display_mode = overrideContact.value;
      }
      if (overrideFont.value !== 'config') {
        overrides.font = overrideFont.value;
      }
      if (overrideMonoFont.value !== 'config') {
        overrides.mono_font = overrideMonoFont.value;
      }

      return overrides;
    }

    function overridesToTypstDict(overrides) {
      const parts = [];
      Object.entries(overrides).forEach(([key, value]) => {
        if (typeof value === 'boolean') {
          parts.push(`${key}: ${value ? 'true' : 'false'}`);
        } else {
          parts.push(`${key}: "${escapeTypstString(value)}"`);
        }
      });
      return `(${parts.join(', ')})`;
    }

    function getResumeTypSource(options = {}) {
      const forDownload = !!options.forDownload;
      const paths = forDownload
        ? {
          template: 'template.typ',
          resume: 'resume.yml',
          bibResume: 'resume.yml',
          configLong: 'config.yml',
          configShort: 'config-short.yml',
          bib: 'publications.bib',
        }
        : {
          template: '/template.typ',
          resume: '/resume.yml',
          bibResume: '/resume.yml',
          configLong: '/config.yml',
          configShort: '/config-short.yml',
          bib: '/publications.bib',
        };
      const runtimeOverrides = overridesToTypstDict(getRuntimeOverridesObject());
      const selectedMode = escapeTypstString(getSelectedMode());
      return `#import "${paths.template}": build_resume

#let normalize_mode(mode) = {
  lower(str(mode).trim())
    .replace(" ", "")
    .replace("_", "")
    .replace("-", "")
    .replace("+", "")
}

#let build_resume_by_mode(
  mode: "default",
  runtime_overrides: (:),
  resume_file: "${paths.resume}",
  bib_resume_file: "${paths.bibResume}",
  config_long_file: "${paths.configLong}",
  config_short_file: "${paths.configShort}",
  bib_file: "${paths.bib}",
) = {
  let m = normalize_mode(mode)
  let use_short = m.contains("short")
  let use_bib = m.contains("bibtex")
  let use_no_js = m.contains("nojs")

  let config_file = if use_short { config_short_file } else { config_long_file }
  let active_resume_file = if use_bib { bib_resume_file } else { resume_file }
  let resume_data = yaml(active_resume_file)
  let overrides = runtime_overrides

  if use_no_js {
    overrides.insert("enable_links", false)
  }

  if use_bib {
    build_resume(resume_data, overrides, config_file: config_file, bib_file: bib_file)
  } else {
    build_resume(resume_data, overrides, config_file: config_file)
  }
}

#let runtime_overrides = ${runtimeOverrides}
#let selected_mode = "${selectedMode}"
#build_resume_by_mode(mode: selected_mode, runtime_overrides: runtime_overrides)`;
    }

    function getMainContent() {
      return `#include "/resume.typ"`;
    }

    async function registerTypstSources() {
      const bibContent = cmBib.getValue();
      await $typst.addSource('/template.typ', templateContent);
      await $typst.addSource('/resume.yml', cmResume.getValue());
      await $typst.addSource('/resume.typ', getResumeTypSource({ forDownload: false }));
      await $typst.addSource('/config.yml', cmConfig.getValue());
      await $typst.addSource('/config-short.yml', cmConfigShort.getValue());
      for (const bibPath of BIB_SOURCE_ALIASES) {
        await $typst.addSource(bibPath, bibContent);
      }
    }

    function modeOutputSuffix(mode) {
      const m = normalizeMode(mode);
      const noJs = modeDisablesLinks(m);
      const bib = modeUsesBib(m);
      const short = modeUsesShort(m);
      if (noJs && bib && short) return '_NBS';
      if (noJs && bib) return '_NB';
      if (noJs && short) return '_NS';
      if (noJs) return '_N';
      if (bib && short) return '_BS';
      if (bib) return '_B';
      if (short) return '_S';
      return '';
    }

    function deriveResumeFilename(resumeYamlText, mode) {
      const lines = resumeYamlText.split(/\r?\n/);
      let inPersonal = false;
      let fullName = '';
      for (const line of lines) {
        if (!inPersonal && /^\s*personal:\s*$/.test(line)) {
          inPersonal = true;
          continue;
        }
        if (inPersonal && /^[^\s#]/.test(line)) break;
        if (inPersonal) {
          const m = line.match(/^\s{2}name:\s*["']?([^"'\n]+)["']?\s*$/);
          if (m) {
            fullName = m[1].trim();
            break;
          }
        }
      }

      const variantSuffix = modeOutputSuffix(mode);
      if (!fullName) return `Resume${variantSuffix}.pdf`;
      const tokens = fullName.split(/\s+/).filter(Boolean);
      if (tokens.length === 0) return `Resume${variantSuffix}.pdf`;
      const first = tokens[0];
      const last = tokens.length > 1 ? tokens[tokens.length - 1] : '';
      const compact = `${first}${last}`.replace(/[^A-Za-z0-9]/g, '');
      if (!compact) return `Resume${variantSuffix}.pdf`;
      return `${compact}_Resume${variantSuffix}.pdf`;
    }

    async function compile() {
      if (!ready) return;
      Object.keys(editors).forEach((key) => flushEditorHistoryTimer(key));
      if (compileTimeout) {
        clearTimeout(compileTimeout);
        compileTimeout = null;
      }
      const requestId = ++compileRequestId;
      const hadPendingManualChanges = hasPendingManualChanges;
      hasPendingManualChanges = false;
      updateCompileControlsUI();

      setStatus('Compiling...', 'compiling');
      showPreviewFeedback('Compiling changes...');

      try {
        await registerTypstSources();

        const mainContent = getMainContent();
        const result = await $typst.svg({ mainContent });

        if (requestId !== compileRequestId) return;

        previewPages.innerHTML = '';

        if (typeof result === 'string') {
          const page = document.createElement('div');
          page.className = 'page';
          page.innerHTML = result;
          previewPages.appendChild(page);
        } else if (Array.isArray(result)) {
          result.forEach(pageSvg => {
            const page = document.createElement('div');
            page.className = 'page';
            page.innerHTML = pageSvg;
            previewPages.appendChild(page);
          });
        }

        localStorage.setItem(LS_RESUME, cmResume.getValue());
        localStorage.setItem(LS_CONFIG, cmConfig.getValue());
        localStorage.setItem(LS_CONFIG_SHORT, cmConfigShort.getValue());
        localStorage.setItem(LS_BIB, cmBib.getValue());
        persistPreferences();

        hidePreviewFeedback();
        hasPendingManualChanges = false;
        updateCompileControlsUI();
        setStatus('Ready', 'ready');
      } catch (err) {
        if (requestId !== compileRequestId) return;
        if (getCompileMode() === 'manual' || hadPendingManualChanges) {
          hasPendingManualChanges = true;
          updateCompileControlsUI();
        }
        showPreviewFeedback('Compilation failed. Fix the error and keep typing.', true);
        setStatus('Error: ' + err.message, 'error');
      }
    }

    btnDownload.addEventListener('click', async () => {
      if (!ready) return;
      btnDownload.disabled = true;
      setStatus('Generating PDF...', 'compiling');

      try {
        await registerTypstSources();

        const mainContent = getMainContent();
        const pdfData = await $typst.pdf({ mainContent });
        const blob = new Blob([pdfData], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = deriveResumeFilename(cmResume.getValue(), getSelectedMode());
        a.click();
        URL.revokeObjectURL(url);
        setStatus('Ready', 'ready');
      } catch (err) {
        setStatus('PDF error: ' + err.message, 'error');
      } finally {
        btnDownload.disabled = false;
      }
    });

    btnDownloadTyp.addEventListener('click', () => {
      const typSource = getResumeTypSource({ forDownload: true });
      const blob = new Blob([typSource], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'resume.typ';
      a.click();
      URL.revokeObjectURL(url);
    });

    btnReset.addEventListener('click', async () => {
      const accepted = await openConfirmDialog({
        title: 'Reset all editors?',
        message: 'This will clear local edits in this browser and reload defaults.',
        confirmText: 'Reset',
        cancelText: 'Cancel',
        destructive: true,
      });
      if (!accepted) return;
      clearSavedState();
      location.reload();
    });

    paperSize.addEventListener('change', () => {
      persistPreferences();
      scheduleCompile();
    });
    const onCompileModeChange = () => {
      persistPreferences();
      if (getCompileMode() === 'manual') {
        if (compileTimeout) {
          clearTimeout(compileTimeout);
          compileTimeout = null;
        }
        updateCompileControlsUI();
        if (ready) {
          setStatus(
            hasPendingManualChanges
              ? 'Manual mode: changes pending. Click compile.'
              : 'Manual mode enabled.',
            hasPendingManualChanges ? 'pending' : '',
          );
        }
        return;
      }

      if (hasPendingManualChanges) {
        hasPendingManualChanges = false;
        updateCompileControlsUI();
        scheduleCompile();
      } else {
        updateCompileControlsUI();
        if (ready) setStatus('Auto compile enabled.', '');
      }
    };
    compileModeInputs.forEach((input) => input.addEventListener('change', onCompileModeChange));

    const onModeControlChange = () => {
      updateTabVisibility();
      persistPreferences();
      scheduleCompile();
    };
    overrideVariant.addEventListener('change', onModeControlChange);
    overrideSource.addEventListener('change', onModeControlChange);
    overrideLinkMode.addEventListener('change', onModeControlChange);
    btnCompileNow.addEventListener('click', () => compile());
    btnUndo.addEventListener('click', () => performEditorUndo());
    btnRedo.addEventListener('click', () => performEditorRedo());
    const onOverridePreferenceChange = () => {
      persistPreferences();
      scheduleCompile();
    };
    overrideLinksDisabledBehavior.addEventListener('change', onOverridePreferenceChange);
    overridePubnums.addEventListener('change', onOverridePreferenceChange);
    overrideContact.addEventListener('change', onOverridePreferenceChange);
    overrideFont.addEventListener('change', onOverridePreferenceChange);
    overrideMonoFont.addEventListener('change', onOverridePreferenceChange);

    async function fetchText(url) {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status}`);
      return resp.text();
    }

    function computeRepoBasePrefix() {
      const path = window.location.pathname || '';
      const webWithSlashIdx = path.indexOf('/web/');
      if (webWithSlashIdx >= 0) return path.slice(0, webWithSlashIdx);
      if (path.endsWith('/web')) return path.slice(0, -4);
      return '';
    }

    function resolveRepoPath(filename) {
      const basePrefix = computeRepoBasePrefix().replace(/\/+$/, '');
      return `${basePrefix}/${filename}`.replace(/\/{2,}/g, '/');
    }

    async function loadDefaults() {
      let resumeYaml = DEFAULT_RESUME_YAML;
      let configYaml = DEFAULT_CONFIG_YAML;
      let configShortYaml = DEFAULT_SHORT_CONFIG_YAML;
      let bibContent = DEFAULT_BIB;
      templateContent = await fetchText(resolveRepoPath('template.typ'));

      try {
        resumeYaml = await fetchText(resolveRepoPath('resume.yml'));
      } catch (e) { }
      try {
        configYaml = await fetchText(resolveRepoPath('config.yml'));
      } catch (e) { }
      try {
        configShortYaml = await fetchText(resolveRepoPath('config-short.yml'));
      } catch (e) { }
      try {
        bibContent = await fetchText(resolveRepoPath('publications.bib'));
      } catch (e) { }

      return { resumeYaml, configYaml, configShortYaml, bibContent };
    }

    async function init() {
      setStatus('Loading defaults...', '');
      if (localStorage.getItem(LS_CACHE_VERSION) !== CACHE_VERSION) {
        clearSavedState();
        localStorage.setItem(LS_CACHE_VERSION, CACHE_VERSION);
      }
      let defaults = null;
      try {
        defaults = await loadDefaults();
      } catch (err) {
        overlay.querySelector('p').textContent = 'Failed: ' + err.message;
        setStatus('Init failed: ' + err.message, 'error');
        return;
      }

      suppressHistoryTracking = true;
      cmResume.setValue(localStorage.getItem(LS_RESUME) || defaults.resumeYaml);
      cmConfig.setValue(localStorage.getItem(LS_CONFIG) || defaults.configYaml);
      cmConfigShort.setValue(localStorage.getItem(LS_CONFIG_SHORT) || defaults.configShortYaml);
      cmBib.setValue(localStorage.getItem(LS_BIB) || defaults.bibContent);
      suppressHistoryTracking = false;

      const legacyMode = localStorage.getItem(LS_OVERRIDE_MODE_LEGACY) || 'default';
      const legacyControls = modeToControlValues(legacyMode);
      setModeVariant(localStorage.getItem(LS_OVERRIDE_VARIANT) || legacyControls.variant);
      setModeSource(localStorage.getItem(LS_OVERRIDE_SOURCE) || legacyControls.source);
      setModeLinkMode(localStorage.getItem(LS_OVERRIDE_LINK_MODE) || legacyControls.linkMode);
      setCompileMode(localStorage.getItem(LS_COMPILE_MODE) || 'auto');
      setMobileView(localStorage.getItem(LS_MOBILE_VIEW) || 'editor');
      const storedActiveTab = localStorage.getItem(LS_ACTIVE_TAB);
      if (storedActiveTab && storedActiveTab in editors) {
        activeTab = storedActiveTab;
      }
      hasPendingManualChanges = false;
      if (getCompileMode() === 'manual' && compileTimeout) {
        clearTimeout(compileTimeout);
        compileTimeout = null;
      }

      const storedPaper = localStorage.getItem(LS_PAPER);
      if (storedPaper === 'a4' || storedPaper === 'letter') {
        paperSize.value = storedPaper;
      } else {
        const activeConfigForPaper = getModeVariant() === 'short' ? cmConfigShort.getValue() : cmConfig.getValue();
        paperSize.value = detectPaperSize(activeConfigForPaper);
      }
      setSelectValue(
        overrideLinksDisabledBehavior,
        localStorage.getItem(LS_OVERRIDE_LINKS_DISABLED_BEHAVIOR) || 'config',
        'config',
      );
      setSelectValue(overridePubnums, localStorage.getItem(LS_OVERRIDE_PUBNUMS) || 'config', 'config');
      setSelectValue(overrideContact, localStorage.getItem(LS_OVERRIDE_CONTACT) || 'config', 'config');
      setSelectValue(overrideFont, localStorage.getItem(LS_OVERRIDE_FONT) || 'config', 'config');
      setSelectValue(overrideMonoFont, localStorage.getItem(LS_OVERRIDE_MONO_FONT) || 'config', 'config');
      const storedPaneWidth = localStorage.getItem(LS_EDITOR_PANE_WIDTH);
      applyEditorPaneWidth(storedPaneWidth || DEFAULT_EDITOR_WIDTH, false);
      updateBibImportPlaceholder();
      refreshCustomSelects();
      loadEditorHistoriesFromStorage();
      updateTabVisibility();
      updateBibHealthStatus(true);
      updateCompileControlsUI();
      persistPreferences();

      const typstScript = document.getElementById('typst');

      function tryInit() {
        if (typeof globalThis.$typst !== 'undefined') {
          initTypst();
        } else {
          setTimeout(tryInit, 200);
        }
      }

      if (typstScript.complete || typeof globalThis.$typst !== 'undefined') {
        setTimeout(tryInit, 100);
      } else {
        typstScript.addEventListener('load', () => setTimeout(tryInit, 100));
      }
    }

    async function initTypst() {
      try {
        $typst.setCompilerInitOptions({
          getModule: () =>
            'https://cdn.jsdelivr.net/npm/@myriaddreamin/typst-ts-web-compiler/pkg/typst_ts_web_compiler_bg.wasm',
        });
        $typst.setRendererInitOptions({
          getModule: () =>
            'https://cdn.jsdelivr.net/npm/@myriaddreamin/typst-ts-renderer/pkg/typst_ts_renderer_bg.wasm',
        });
        ready = true;
        overlay.style.display = 'none';
        btnDownload.disabled = false;
        updateCompileControlsUI();
        setStatus('Ready', 'ready');
        compile();
      } catch (err) {
        overlay.querySelector('p').textContent = 'Failed: ' + err.message;
        setStatus('Init failed: ' + err.message, 'error');
      }
    }

    init();

  </script>
</body>

</html>